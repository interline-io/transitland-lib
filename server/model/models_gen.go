// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/interline-io/transitland-lib/tt"
)

// Search options for agencies
type AgencyFilter struct {
	// Search for agencies with this operator OnestopID
	OnestopID *string `json:"onestop_id,omitempty"`
	// Search for agencies with this feed version SHA1 hash
	FeedVersionSha1 *string `json:"feed_version_sha1,omitempty"`
	// Search for agencies with this feed OnestopID
	FeedOnestopID *string `json:"feed_onestop_id,omitempty"`
	// Search for agencies with this GTFS agency_id
	AgencyID *string `json:"agency_id,omitempty"`
	// Search for records with this GTFS agency_name
	AgencyName *string `json:"agency_name,omitempty"`
	// Search for agencies within this bounding box
	Bbox *BoundingBox `json:"bbox,omitempty"`
	// Search for agencies within this geographic polygon
	Within *tt.Polygon `json:"within,omitempty"`
	// Search for agencies within specified radius of a point
	Near *PointRadius `json:"near,omitempty"`
	// Full text search
	Search *string `json:"search,omitempty"`
	// Search for agencies by city name (provided by Natural Earth)
	CityName *string `json:"city_name,omitempty"`
	// Search for agencies by country name (provided by Natural Earth)
	Adm0Name *string `json:"adm0_name,omitempty"`
	// Search for agencies by state/province/division name (provided by Natural Earth)
	Adm1Name *string `json:"adm1_name,omitempty"`
	// Search for agencies by country 2 letter ISO 3166 code (provided by Natural Earth)
	Adm0Iso *string `json:"adm0_iso,omitempty"`
	// Search for agencies by state/province/division ISO 3166-2 code (provided by Natural Earth)
	Adm1Iso *string `json:"adm1_iso,omitempty"`
	// Search for agencies with these license details
	License *LicenseFilter `json:"license,omitempty"`
}

// Place associated with an agency
type AgencyPlace struct {
	// Best-matched city name
	CityName *string `json:"city_name,omitempty"`
	// Best-matched state or province name
	Adm1Name *string `json:"adm1_name,omitempty"`
	// Best-matched state or province ISO code
	Adm1Iso *string `json:"adm1_iso,omitempty"`
	// Best-matched country name
	Adm0Name *string `json:"adm0_name,omitempty"`
	// Best-mached country ISO code
	Adm0Iso *string `json:"adm0_iso,omitempty"`
	// Relative weight of this place association
	Rank     *float64 `json:"rank,omitempty"`
	AgencyID int      `json:"-"`
}

// Search options for agency associated places
type AgencyPlaceFilter struct {
	// Search for associations with at least this rank value
	MinRank *float64 `json:"min_rank,omitempty"`
}

// [Alert](https://gtfs.org/reference/realtime/v2/#message-alert) message, also called a service alert, provided by a source GTFS Realtime feed.
type Alert struct {
	// GTFS-RT Alert active alert period. See https://gtfs.org/realtime/reference/#message-timerange
	ActivePeriod []*RTTimeRange `json:"active_period,omitempty"`
	// GTFS-RT Alert [cause](https://gtfs.org/realtime/reference/#enum-cause)
	Cause *string `json:"cause,omitempty"`
	// GTFS-RT Alert [effect](https://gtfs.org/realtime/reference/#enum-effect)
	Effect *string `json:"effect,omitempty"`
	// GTFS-RT Alert header text
	HeaderText []*RTTranslation `json:"header_text"`
	// GTFS-RT Alert description text
	DescriptionText []*RTTranslation `json:"description_text"`
	// GTFS-RT Alert TTS header text
	TtsHeaderText []*RTTranslation `json:"tts_header_text,omitempty"`
	// GTFS-RT Alert TTS description text
	TtsDescriptionText []*RTTranslation `json:"tts_description_text,omitempty"`
	// GTFS-RT Alert uRL for more information
	URL []*RTTranslation `json:"url,omitempty"`
	// GTFS-RT Alert severity level
	SeverityLevel *string `json:"severity_level,omitempty"`
}

// Search for entities within a specified bounding box
type BoundingBox struct {
	// Minimum longitude
	MinLon float64 `json:"min_lon"`
	// Minimum latitude
	MinLat float64 `json:"min_lat"`
	// Maximum longitude
	MaxLon float64 `json:"max_lon"`
	// Maximum latitude
	MaxLat float64 `json:"max_lat"`
}

// Search options for calendar dates
type CalendarDateFilter struct {
	// Search for calendar date exceptions on this date
	Date *tt.Date `json:"date,omitempty"`
	// Search for calendar date exceptions with this GTFS exception_type
	ExceptionType *int `json:"exception_type,omitempty"`
}

type CensusDataset struct {
	// Internal integer ID
	ID int `json:"id"`
	// Dataset name, e.g. acsdt5y2022
	Name string `json:"name"`
	// Dataset description
	Description *string `json:"description,omitempty"`
	// Dataset url
	URL *tt.Url `json:"url,omitempty"`
	// Minimum year of data in this dataset
	YearMin *int `json:"year_min,omitempty"`
	// Maximum year of data in this dataset
	YearMax     *int               `json:"year_max,omitempty"`
	Sources     []*CensusSource    `json:"sources,omitempty"`
	Geographies []*CensusGeography `json:"geographies,omitempty"`
	Tables      []*CensusTable     `json:"tables,omitempty"`
	Layers      []*CensusLayer     `json:"layers,omitempty"`
}

// Search options for census datasets
type CensusDatasetFilter struct {
	// Search for datasets with this name
	Name *string `json:"name,omitempty"`
	// Search for datasets matching this string
	Search *string `json:"search,omitempty"`
}

type CensusDatasetGeographyFilter struct {
	// Geographies with these integer IDs
	Ids []int `json:"ids,omitempty"`
	// Search within this layer
	Layer *string `json:"layer,omitempty"`
	// Search for geographies matching this string
	Search *string `json:"search,omitempty"`
	// Location search
	Location *CensusDatasetGeographyLocationFilter `json:"location,omitempty"`
}

type CensusDatasetGeographyLocationFilter struct {
	// Search within this bounding box
	Bbox *BoundingBox `json:"bbox,omitempty"`
	// Search within this geographic polygon
	Within *tt.Polygon `json:"within,omitempty"`
	// Search within specified radius of a point
	Near *PointRadius `json:"near,omitempty"`
	// Focus search on this point; results will be sorted by distance
	Focus *FocusPoint `json:"focus,omitempty"`
	// Search based on a buffer around these stop ids
	StopBuffer *StopBuffer `json:"stop_buffer,omitempty"`
}

type CensusField struct {
	// Internal integer ID
	ID int `json:"id"`
	// Census field name
	FieldName string `json:"field_name"`
	// Census field title
	FieldTitle string `json:"field_title"`
	// Census field column order
	ColumnOrder *float64 `json:"column_order,omitempty"`
	TableID     int      `json:"-"`
}

// Census geography data
type CensusGeography struct {
	// Internal integer ID
	ID int `json:"id"`
	// Dataset name, e.g. acsdt5y2022
	DatasetName string `json:"dataset_name"`
	// Source name, e.g. tl_2024_01_tract.zip
	SourceName string `json:"source_name"`
	// Census geography source layer
	LayerName string `json:"layer_name"`
	// Census geography GEOID
	Geoid *string `json:"geoid,omitempty"`
	// Census geography name
	Name *string `json:"name,omitempty"`
	// Geometry total area, in square meters
	GeometryArea *float64 `json:"geometry_area,omitempty"`
	// Land area, in square meters
	Aland *float64 `json:"aland,omitempty"`
	// Water area, in square meters
	Awater *float64 `json:"awater,omitempty"`
	// State or province name
	Adm1Name *string `json:"adm1_name,omitempty"`
	// State or province ISO code
	Adm1Iso *string `json:"adm1_iso,omitempty"`
	// Country name
	Adm0Name *string `json:"adm0_name,omitempty"`
	// Country ISO code
	Adm0Iso *string `json:"adm0_iso,omitempty"`
	// Census geography polygon
	Geometry *tt.MultiPolygon `json:"geometry,omitempty"`
	// Intersection area with a given geometry, in square meters
	IntersectionArea     *float64     `json:"intersection_area,omitempty"`
	IntersectionGeometry *tt.Geometry `json:"intersection_geometry,omitempty"`
	// Census tables containing data for this geography
	Values []*CensusValue `json:"values"`
	// Layer
	Layer *CensusLayer `json:"layer,omitempty"`
	// Source
	Source        *CensusSource `json:"source,omitempty"`
	DatasetID     int           `json:"-"`
	LayerID       int           `json:"-"`
	MatchEntityID int           `json:"-"`
	SourceID      int           `json:"-"`
}

// Search options for census geographies
type CensusGeographyFilter struct {
	Dataset *string  `json:"dataset,omitempty"`
	Layer   *string  `json:"layer,omitempty"`
	Radius  *float64 `json:"radius,omitempty"`
	Search  *string  `json:"search,omitempty"`
}

// "Census layer metadata
type CensusLayer struct {
	// Internal integer ID
	ID int `json:"id"`
	// Layer name, e.g. tl_2024_01_tract
	Name string `json:"name"`
	// Layer description
	Description *string            `json:"description,omitempty"`
	Geographies []*CensusGeography `json:"geographies,omitempty"`
	DatasetID   int                `json:"-"`
}

type CensusSource struct {
	// Internal integer ID
	ID int `json:"id"`
	// Source name, e.g. tl_2024_01_tract.zip
	Name string `json:"name"`
	// Source description
	Description *string `json:"description,omitempty"`
	// Source url
	URL tt.Url `json:"url"`
	// Source checksum
	Sha1        string             `json:"sha1"`
	Geographies []*CensusGeography `json:"geographies,omitempty"`
	Tables      []*CensusTable     `json:"tables,omitempty"`
	Layers      []*CensusLayer     `json:"layers,omitempty"`
	DatasetID   int                `json:"-"`
}

type CensusSourceFilter struct {
	Name   *string `json:"name,omitempty"`
	Search *string `json:"search,omitempty"`
}

type CensusSourceGeographyFilter struct {
	// Geographies with these integer IDs
	Ids []int `json:"ids,omitempty"`
	// Search for geographies matching this string
	Search *string `json:"search,omitempty"`
	// Location search
	Location *CensusDatasetGeographyLocationFilter `json:"location,omitempty"`
}

// Census table metadata
type CensusTable struct {
	// Internal integer ID
	ID int `json:"id"`
	// Census table name
	TableName string `json:"table_name"`
	// Census table title
	TableTitle string `json:"table_title"`
	// Census table group
	TableGroup *string `json:"table_group,omitempty"`
	// Additional details, e.g. population universe
	TableDetails *string `json:"table_details,omitempty"`
	// Individial field definitions for this table
	Fields    []*CensusField `json:"fields"`
	DatasetID int            `json:"-"`
}

type CensusTableFilter struct {
	Search *string `json:"search,omitempty"`
}

// Census values
type CensusValue struct {
	// Dataset name, e.g. acsdt5y2022
	DatasetName string `json:"dataset_name"`
	// Source name, e.g. tl_2024_01_tract.zip
	SourceName string `json:"source_name"`
	// Source table
	Table *CensusTable `json:"table"`
	// Column:Value for this table
	Values tt.Map `json:"values"`
	// GEOID of associated census geography
	Geoid       string `json:"geoid"`
	GeographyID int    `json:"-"`
	TableID     int    `json:"-"`
}

type DirectionRequest struct {
	To       *WaypointInput `json:"to"`
	From     *WaypointInput `json:"from"`
	Mode     StepMode       `json:"mode"`
	DepartAt *time.Time     `json:"depart_at,omitempty"`
}

type Directions struct {
	Success     bool         `json:"success"`
	Exception   *string      `json:"exception,omitempty"`
	DataSource  *string      `json:"data_source,omitempty"`
	Origin      *Waypoint    `json:"origin,omitempty"`
	Destination *Waypoint    `json:"destination,omitempty"`
	Duration    *Duration    `json:"duration,omitempty"`
	Distance    *Distance    `json:"distance,omitempty"`
	StartTime   *time.Time   `json:"start_time,omitempty"`
	EndTime     *time.Time   `json:"end_time,omitempty"`
	Itineraries []*Itinerary `json:"itineraries,omitempty"`
}

type Distance struct {
	Distance float64      `json:"distance"`
	Units    DistanceUnit `json:"units"`
}

type Duration struct {
	Duration float64      `json:"duration"`
	Units    DurationUnit `json:"units"`
}

// Result of entity delete operation
type EntityDeleteResult struct {
	// ID of deleted entity
	ID int `json:"id"`
}

type Feature struct {
	ID         *string      `json:"id,omitempty"`
	Geometry   *tt.Geometry `json:"geometry,omitempty"`
	Properties *tt.Map      `json:"properties,omitempty"`
	Type       *string      `json:"type,omitempty"`
}

// Search options for feed fetches
type FeedFetchFilter struct {
	// Search for feed fetches with success (true) or failure (false) or unspecified (null)
	Success *bool `json:"success,omitempty"`
}

// Search options for feeds
type FeedFilter struct {
	// Search for feed with a specific OnestopID
	OnestopID *string `json:"onestop_id,omitempty"`
	// Search for feeds of certain data types
	Spec []FeedSpecTypes `json:"spec,omitempty"`
	// Search for feeds with or without a fetch error
	FetchError *bool `json:"fetch_error,omitempty"`
	// Search for feeds by their import status
	ImportStatus *ImportStatus `json:"import_status,omitempty"`
	// Full text search
	Search *string `json:"search,omitempty"`
	// Search for feeds with a tag
	Tags *tt.Tags `json:"tags,omitempty"`
	// Search for feeds by their source URLs
	SourceURL *FeedSourceURL `json:"source_url,omitempty"`
	// Search for feeds with these license details
	License *LicenseFilter `json:"license,omitempty"`
	// Search for feeds within this bounding box
	Bbox *BoundingBox `json:"bbox,omitempty"`
	// Search for feeds within this geographic polygon
	Within *tt.Polygon `json:"within,omitempty"`
	// Search for feeds within specified radius of a point
	Near *PointRadius `json:"near,omitempty"`
}

// Search options for searching by source URL
type FeedSourceURL struct {
	// URL
	URL *string `json:"url,omitempty"`
	// URL type
	Type *FeedSourceURLTypes `json:"type,omitempty"`
	// Case sensitive search (true) or case insensitive search (false or null)
	CaseSensitive *bool `json:"case_sensitive,omitempty"`
}

// Result of feed version delete operation
type FeedVersionDeleteResult struct {
	// Did the delete succeed
	Success bool `json:"success"`
}

// Result of a feed fetch operation
type FeedVersionFetchResult struct {
	// Details of fetched feed version, if successful
	FeedVersion *FeedVersion `json:"feed_version,omitempty"`
	// Exception log if fetch failed
	FetchError *string `json:"fetch_error,omitempty"`
	// Set if the fetched feed version is already present in the database with the same directory contents
	FoundSha1 bool `json:"found_sha1"`
	// Set if the fetched feed version is already present in the database with the same SHA1 hash
	FoundDirSha1 bool `json:"found_dir_sha1"`
}

// Search options for feed versions
type FeedVersionFilter struct {
	// Restrict to specific ids
	Ids []int `json:"ids,omitempty"`
	// Search for feed versions with the specified import status
	ImportStatus *ImportStatus `json:"import_status,omitempty"`
	// Search for feed versions with this feed OnestopID
	FeedOnestopID *string `json:"feed_onestop_id,omitempty"`
	// Search for feed versions with this SHA1 hash
	Sha1 *string `json:"sha1,omitempty"`
	// Search for feed versions with this file identifier
	File *string `json:"file,omitempty"`
	// Search for feed versions with the specified feed integer IDs
	FeedIds []int `json:"feed_ids,omitempty"`
	// Search for feed versions that cover the specified date range
	Covers *ServiceCoversFilter `json:"covers,omitempty"`
	// Search for feed versions within this bounding box
	Bbox *BoundingBox `json:"bbox,omitempty"`
	// Search for feed versions within this geographic polygon
	Within *tt.Polygon `json:"within,omitempty"`
	// Search for feed versions within specified radius of a point
	Near *PointRadius `json:"near,omitempty"`
}

// Result of feed version import operation
type FeedVersionImportResult struct {
	// Did the import succeed
	Success bool `json:"success"`
}

// Specify a feed version
type FeedVersionInput struct {
	// Feed version integer ID
	ID *int `json:"id,omitempty"`
}

// Search options for feed version service level summaries
type FeedVersionServiceLevelFilter struct {
	// Search for service level summaries starting on or after this date
	StartDate *tt.Date `json:"start_date,omitempty"`
	// Search for service level summaries ending on or before this date
	EndDate *tt.Date `json:"end_date,omitempty"`
}

// Summary details on service dates in a feed version
type FeedVersionServiceWindow struct {
	// Internal integer ID
	ID int `json:"id"`
	// Feed start date from feed_info.txt, if available
	FeedStartDate *tt.Date `json:"feed_start_date,omitempty"`
	// Feed end date from feed_info.txt, if available
	FeedEndDate *tt.Date `json:"feed_end_date,omitempty"`
	// Calculated earliest calendar date in service schedule
	EarliestCalendarDate *tt.Date `json:"earliest_calendar_date,omitempty"`
	// Calculated latest calendar date in service schedule
	LatestCalendarDate *tt.Date `json:"latest_calendar_date,omitempty"`
	// Week with most typical service patterns inside the service window
	FallbackWeek *tt.Date `json:"fallback_week,omitempty"`
	// Default timezone for this feed version
	DefaultTimezone *string `json:"default_timezone,omitempty"`
	FeedVersionID   int     `json:"-"`
}

// Update a feed version entity
type FeedVersionSetInput struct {
	// Entity ID to update
	ID *int `json:"id,omitempty"`
	// Set entity name to this value
	Name *string `json:"name,omitempty"`
	// Set entity description to this value
	Description *string `json:"description,omitempty"`
}

// Result of feed version unimport operation
type FeedVersionUnimportResult struct {
	// Did the unimport succeed
	Success bool `json:"success"`
}

type FocusPoint struct {
	// Latitude
	Lat float64 `json:"lat"`
	// Longitude
	Lon float64 `json:"lon"`
}

type GbfsBikeRequest struct {
	Near *PointRadius `json:"near,omitempty"`
}

type GbfsDockRequest struct {
	Near *PointRadius `json:"near,omitempty"`
}

type Itinerary struct {
	Duration  *Duration `json:"duration"`
	Distance  *Distance `json:"distance"`
	StartTime time.Time `json:"start_time"`
	EndTime   time.Time `json:"end_time"`
	From      *Waypoint `json:"from"`
	To        *Waypoint `json:"to"`
	Legs      []*Leg    `json:"legs,omitempty"`
}

type Leg struct {
	Duration  *Duration            `json:"duration"`
	Distance  *Distance            `json:"distance"`
	StartTime time.Time            `json:"start_time"`
	EndTime   time.Time            `json:"end_time"`
	From      *Waypoint            `json:"from,omitempty"`
	To        *Waypoint            `json:"to,omitempty"`
	Mode      *StepMode            `json:"mode,omitempty"`
	Steps     []*Step              `json:"steps,omitempty"`
	Stops     []*WaypointDeparture `json:"stops,omitempty"`
	Geometry  tt.LineString        `json:"geometry"`
	Trip      *LegTrip             `json:"trip,omitempty"`
}

type LegRoute struct {
	RouteID        string          `json:"route_id"`
	RouteShortName string          `json:"route_short_name"`
	RouteLongName  string          `json:"route_long_name"`
	RouteOnestopID string          `json:"route_onestop_id"`
	RouteType      int             `json:"route_type"`
	RouteColor     *string         `json:"route_color,omitempty"`
	RouteTextColor *string         `json:"route_text_color,omitempty"`
	Agency         *LegRouteAgency `json:"agency"`
}

type LegRouteAgency struct {
	AgencyID        string `json:"agency_id"`
	AgencyName      string `json:"agency_name"`
	AgencyOnestopID string `json:"agency_onestop_id"`
}

type LegTrip struct {
	TripID          string    `json:"trip_id"`
	TripShortName   string    `json:"trip_short_name"`
	Headsign        string    `json:"headsign"`
	FeedID          string    `json:"feed_id"`
	FeedVersionSha1 string    `json:"feed_version_sha1"`
	Route           *LegRoute `json:"route"`
}

// Update a level entity
type LevelSetInput struct {
	// Entity ID to update
	ID *int `json:"id,omitempty"`
	// Feed version of entity to update
	FeedVersion *FeedVersionInput `json:"feed_version,omitempty"`
	// Set GTFS level_id to this value
	LevelID *string `json:"level_id,omitempty"`
	// Set GTFS level_name to this value
	LevelName *string `json:"level_name,omitempty"`
	// Set GTFS level_index to this value
	LevelIndex *float64 `json:"level_index,omitempty"`
	// Set level geometry to this value
	Geometry *tt.Polygon `json:"geometry,omitempty"`
	// Set level parent station to this stop
	Parent *StopSetInput `json:"parent,omitempty"`
}

// Search for entities with these license requirements. See feed license documentation.
type LicenseFilter struct {
	// Search for entities with this Share Alike license restriction
	ShareAlikeOptional *LicenseValue `json:"share_alike_optional,omitempty"`
	// Search for entities with this Create Derived Product license restriction
	CreateDerivedProduct *LicenseValue `json:"create_derived_product,omitempty"`
	// Search for entities with this Commercial Use Allowed restriction
	CommercialUseAllowed *LicenseValue `json:"commercial_use_allowed,omitempty"`
	// Search for entities with this Use Without Attribution restriction
	UseWithoutAttribution *LicenseValue `json:"use_without_attribution,omitempty"`
	// Search for entities with this Redistribution Allowed restriction
	RedistributionAllowed *LicenseValue `json:"redistribution_allowed,omitempty"`
}

// Current user metadata
type Me struct {
	// Internal identifier
	ID string `json:"id"`
	// User name
	Name *string `json:"name,omitempty"`
	// User email
	Email *string `json:"email,omitempty"`
	// User associated roles
	Roles []string `json:"roles,omitempty"`
	// User associated external data, e.g. metering service identifiers
	ExternalData tt.Map `json:"external_data"`
}

type Mutation struct {
}

// Search options for operators
type OperatorFilter struct {
	// Merge multiple agency-operator associations into single operator results
	Merged *bool `json:"merged,omitempty"`
	// Search for operators with this OnestopID
	OnestopID *string `json:"onestop_id,omitempty"`
	// Search for operators with this feed OnestopID
	FeedOnestopID *string `json:"feed_onestop_id,omitempty"`
	// Search for operators with agencies having this GTFS agency_id
	AgencyID *string `json:"agency_id,omitempty"`
	// Full-text search string
	Search *string `json:"search,omitempty"`
	// Search for operators with this set of tag key/values
	Tags *tt.Tags `json:"tags,omitempty"`
	// Search for operators by city name (provided by Natural Earth)
	CityName *string `json:"city_name,omitempty"`
	// Search for operators by country name (provided by Natural Earth)
	Adm0Name *string `json:"adm0_name,omitempty"`
	// Search for operators by state/province/division name (provided by Natural Earth)
	Adm1Name *string `json:"adm1_name,omitempty"`
	// Search for operators by country 2 letter ISO 3166 code (provided by Natural Earth)
	Adm0Iso *string `json:"adm0_iso,omitempty"`
	// Search for operators by state/province/division ISO 3166-2 code (provided by Natural Earth)
	Adm1Iso *string `json:"adm1_iso,omitempty"`
	// Search for operators with these license details
	License *LicenseFilter `json:"license,omitempty"`
	// Search for operators within this bounding box
	Bbox *BoundingBox `json:"bbox,omitempty"`
	// Search for operators within this geographic polygon
	Within *tt.Polygon `json:"within,omitempty"`
	// Search for operators within specified radius of a point
	Near *PointRadius `json:"near,omitempty"`
}

// Search options for pathways
type PathwayFilter struct {
	// Search for pathways with this GTFS pathway_mode
	PathwayMode *int `json:"pathway_mode,omitempty"`
}

// Update a pathway entity
type PathwaySetInput struct {
	// Entity ID to update
	ID *int `json:"id,omitempty"`
	// Feed version of entity to update
	FeedVersion *FeedVersionInput `json:"feed_version,omitempty"`
	// Set GTFS pathway_id to this value
	PathwayID *string `json:"pathway_id,omitempty"`
	// Set GTFS pathway_mode to this value
	PathwayMode *int `json:"pathway_mode,omitempty"`
	// Set GTFS is_bidirectional to this value
	IsBidirectional *int `json:"is_bidirectional,omitempty"`
	// Set GTFS length to this value
	Length *float64 `json:"length,omitempty"`
	// Set GTFS traversal_time to this value
	TraversalTime *int `json:"traversal_time,omitempty"`
	// Set GTFS stair_count to this value
	StairCount *int `json:"stair_count,omitempty"`
	// Set GTFS max_slope to this value
	MaxSlope *float64 `json:"max_slope,omitempty"`
	// Set GTFS min_width to this value
	MinWidth *float64 `json:"min_width,omitempty"`
	// Set GTFS signposted_as to this value
	SignpostedAs *string `json:"signposted_as,omitempty"`
	// Set GTFS reverse_signposted_as to this value
	ReverseSignpostedAs *string `json:"reverse_signposted_as,omitempty"`
	// Set pathway origin to this stop
	FromStop *StopSetInput `json:"from_stop,omitempty"`
	// Set pathway destination to this stop
	ToStop *StopSetInput `json:"to_stop,omitempty"`
}

// Place name and associated operators
type Place struct {
	// Country name
	Adm0Name *string `json:"adm0_name,omitempty"`
	// State or province name
	Adm1Name *string `json:"adm1_name,omitempty"`
	// City name
	CityName *string `json:"city_name,omitempty"`
	// Number of associated operators
	Count int `json:"count"`
	// Operators associated with this place
	Operators []*Operator `json:"operators,omitempty"`
	AgencyIDs tt.Ints     `db:"agency_ids"`
}

// Search options for associated places
type PlaceFilter struct {
	// Search for place associations with at least this rank value
	MinRank *float64 `json:"min_rank,omitempty"`
	// Search for place associations by country name (provided by Natural Earth)
	Adm0Name *string `json:"adm0_name,omitempty"`
	// Search for place associations by state/province/division name (provided by Natural Earth)
	Adm1Name *string `json:"adm1_name,omitempty"`
	// Search for place associations by city name (provided by Natural Earth)
	CityName *string `json:"city_name,omitempty"`
}

// Search for entities within specified radius of a point
type PointRadius struct {
	// Latitude
	Lat float64 `json:"lat"`
	// Longitude
	Lon float64 `json:"lon"`
	// Radius around specified point
	Radius float64 `json:"radius"`
}

type Query struct {
}

// See https://gtfs.org/reference/realtime/v2/#message-timerange
type RTTimeRange struct {
	// GTFS-RT TimeRange start time, in Unix epoch seconds
	Start *int `json:"start,omitempty"`
	// GTFS-RT TimeRange end time, in Unix epoch seconds
	End *int `json:"end,omitempty"`
}

// See https://gtfs.org/reference/realtime/v2/#message-translatedstring
type RTTranslation struct {
	// GTFS-RT TranslatedString translated text
	Text string `json:"text"`
	// GTFS-RT TranslatedString language for this translation
	Language *string `json:"language,omitempty"`
}

// See https://gtfs.org/reference/realtime/v2/#message-tripdescriptor
type RTTripDescriptor struct {
	// GTFS-RT TripDescriptor trip ID
	TripID *string `json:"trip_id,omitempty"`
	// GTFS-RT TripDescriptor route ID
	RouteID *string `json:"route_id,omitempty"`
	// GTFS-RT TripDescriptor trip direction
	DirectionID *int `json:"direction_id,omitempty"`
	// GTFS-RT TripDescriptor trip start time, in local time HH:MM:SS
	StartTime *tt.Seconds `json:"start_time,omitempty"`
	// GTFS-RT TripDescriptor trip start time, in local date
	StartDate *tt.Date `json:"start_date,omitempty"`
	// GTFS-RT TripDescriptor schedule relationship. See https://gtfs.org/realtime/reference/#enum-schedulerelationship-1
	ScheduleRelationship *string `json:"schedule_relationship,omitempty"`
}

// See https://gtfs.org/reference/realtime/v2/#message-vehicledescriptor
type RTVehicleDescriptor struct {
	// GTFS-RT VehicleDescriptor vehicle ID
	ID *string `json:"id,omitempty"`
	// GTFS-RT VehicleDescriptor vehicle label
	Label *string `json:"label,omitempty"`
	// GTFS-RT VehicleDescriptor vehicle license plate
	LicensePlate *string `json:"license_plate,omitempty"`
}

// MTC GTFS+ Extension: route_attributes.txt
type RouteAttribute struct {
	// Route category
	Category *int `json:"category,omitempty"`
	// Route subcategory
	Subcategory *int `json:"subcategory,omitempty"`
	// Route running way category
	RunningWay *int `json:"running_way,omitempty"`
	RouteID    int  `json:"-"`
}

// Search options for routes
type RouteFilter struct {
	// Search for routes with this OnestopID
	OnestopID *string `json:"onestop_id,omitempty"`
	// Search for routes with these OnestopIDs
	OnestopIds []string `json:"onestop_ids,omitempty"`
	// Include previously used OnestopIDs that match the same (feed,route_id)
	AllowPreviousOnestopIds *bool `json:"allow_previous_onestop_ids,omitempty"`
	// Search for routes with this feed version SHA1 hash
	FeedVersionSha1 *string `json:"feed_version_sha1,omitempty"`
	// Search for routes with this feed OnestopID
	FeedOnestopID *string `json:"feed_onestop_id,omitempty"`
	// Search for routes with this GTFS route_id
	RouteID *string `json:"route_id,omitempty"`
	// Search for routes with this GTFS route_type
	RouteType *int `json:"route_type,omitempty"`
	// Search for routes with any of these GTFS route_types
	RouteTypes []int `json:"route_types,omitempty"`
	// Search for routes with 1 or more trips (true) or 0 or more trips (false or null)
	Serviced *bool `json:"serviced,omitempty"`
	// Search for routes within this bounding box
	Bbox *BoundingBox `json:"bbox,omitempty"`
	// Search for routes within this geographic polygon
	Within *tt.Polygon `json:"within,omitempty"`
	// Search for routes within specified radius of a point
	Near *PointRadius `json:"near,omitempty"`
	// Full text search
	Search *string `json:"search,omitempty"`
	// Search for routes operated by operators with this OnestopID
	OperatorOnestopID *string `json:"operator_onestop_id,omitempty"`
	// Search for routes with these license details
	License *LicenseFilter `json:"license,omitempty"`
	// Search for routes with these agency integer IDs. Deprecated.
	AgencyIds []int `json:"agency_ids,omitempty"`
}

// Representative route geometries
type RouteGeometry struct {
	// If true, the source GTFS feed provides no shapes. This route geometry is based on straight lines between stop points.
	Generated bool `json:"generated"`
	// A single LineString of this most common shape
	Geometry *tt.LineString `json:"geometry,omitempty"`
	// MultiLineString ensemble of the most common shapes for each direction
	CombinedGeometry *tt.Geometry `json:"combined_geometry,omitempty"`
	// Length (in meters) of the simple geometry
	Length *float64 `json:"length,omitempty"`
	// Maximum point-to-point distance in the geometry
	MaxSegmentLength *float64 `json:"max_segment_length,omitempty"`
	// First point max distance
	FirstPointMaxDistance *float64 `json:"first_point_max_distance,omitempty"`
	RouteID               int      `json:"-"`
}

// Calculated route headways
type RouteHeadway struct {
	// Stop used for the headway calculation
	Stop *Stop `json:"stop"`
	// Day of week category; 1=Weekday, 6=Saturday, 7=Sunday
	DowCategory *int `json:"dow_category,omitempty"`
	// Trip direction
	DirectionID *int `json:"direction_id,omitempty"`
	// Typical number of seconds between departing trips at this stop in this direction on this day of the week
	HeadwaySecs *int `json:"headway_secs,omitempty"`
	// Date used for the headway calculation
	ServiceDate *tt.Date `json:"service_date,omitempty"`
	// Number of departures on this stop, day, and direction
	StopTripCount *int `json:"stop_trip_count,omitempty"`
	// Actual departure times on this stop, day, and direction
	DeparturesUnused []*tt.Seconds `json:"departures,omitempty"`
	DepartureInts    tt.Ints       `db:"departures"`
	RouteID          int           `json:"-"`
	SelectedStopID   int           `json:"-"`
}

// RouteStops describe associations between stops, routes, and agencies.
type RouteStop struct {
	// Internal integer ID
	ID int `json:"id"`
	// Internal integer ID for this associated stop
	StopID int `json:"stop_id"`
	// Internal integer ID for this associated route
	RouteID int `json:"route_id"`
	// Internal integer ID for this associated agency
	AgencyID int `json:"agency_id"`
	// Associated route
	Route *Route `json:"route"`
	// Associated stop
	Stop *Stop `json:"stop"`
	// Associated agency
	Agency *Agency `json:"agency"`
}

// Geographic buffer around a route
type RouteStopBuffer struct {
	// Geographic buffer around route, based on requested meters
	StopBuffer *tt.Geometry `json:"stop_buffer,omitempty"`
	// Matching set of points (e.g. stops) found inside buffer
	StopPoints *tt.Geometry `json:"stop_points,omitempty"`
	// Convex hull of matching points
	StopConvexhull *tt.Polygon `json:"stop_convexhull,omitempty"`
}

// RouteStopPattern describes a unique pattern of stops for a route
type RouteStopPattern struct {
	// An identifier for this stop pattern; an integer scoped to this particular feed version
	StopPatternID int `json:"stop_pattern_id"`
	// Direction ID of the trip
	DirectionID int `json:"direction_id"`
	// Count of trips for this stop pattern
	Count int `json:"count"`
	// Trips for this stop pattern
	Trips   []*Trip `json:"trips,omitempty"`
	RouteID int     `json:"-"`
}

// Normalized route segments
type Segment struct {
	// Internal integer ID
	ID int `json:"id"`
	// OSM Way ID, if any, associated with this segment
	WayID int `json:"way_id"`
	// Geometry for this segment
	Geometry tt.LineString `json:"geometry"`
	// Routes and stop patterns associated with this segment
	SegmentPatterns []*SegmentPattern `json:"segment_patterns,omitempty"`
	FeedVersionID   int               `json:"-"`
	WithRouteID     int               `json:"-"`
}

// Search options for route segments
type SegmentFilter struct {
	// Search for segments associated with this layer name
	Layer *string `json:"layer,omitempty"`
}

// Normalized route segment patterns
type SegmentPattern struct {
	// Internal integer ID
	ID int `json:"id"`
	// Route for this segment pattern
	Route *Route `json:"route"`
	// Stop pattern for this segment pattern
	StopPatternID int `json:"stop_pattern_id"`
	// Segment geometry for this pattern
	Segment   *Segment `json:"segment"`
	RouteID   int      `json:"-"`
	SegmentID int      `json:"-"`
}

// Search options for route segment patterns
type SegmentPatternFilter struct {
	// Search for segments patterns associated with this layer name
	Layer *string `json:"layer,omitempty"`
}

// Search options for feed version date range coverage
type ServiceCoversFilter struct {
	// Search for feed versions fetched after this time
	FetchedAfter *time.Time `json:"fetched_after,omitempty"`
	// Search for feed versions fetched before this time
	FetchedBefore *time.Time `json:"fetched_before,omitempty"`
	// Search using only feed_info.txt values
	FeedStartDate *tt.Date `json:"feed_start_date,omitempty"`
	// Search using only feed_info.txt values
	FeedEndDate *tt.Date `json:"feed_end_date,omitempty"`
	// Search using feed_info.txt values or calendar maximum service extent
	StartDate *tt.Date `json:"start_date,omitempty"`
	// Search using feed_info.txt values or calendar maximum service extent
	EndDate *tt.Date `json:"end_date,omitempty"`
	// Search using calendar maximum service extent
	EarliestCalendarDate *tt.Date `json:"earliest_calendar_date,omitempty"`
	// Search using calendar maximum service extent
	LatestCalendarDate *tt.Date `json:"latest_calendar_date,omitempty"`
}

type Step struct {
	Duration       *Duration `json:"duration"`
	Distance       *Distance `json:"distance"`
	StartTime      time.Time `json:"start_time"`
	EndTime        time.Time `json:"end_time"`
	To             *Waypoint `json:"to,omitempty"`
	Mode           StepMode  `json:"mode"`
	Instruction    string    `json:"instruction"`
	GeometryOffset int       `json:"geometry_offset"`
}

type StopBuffer struct {
	// Search for geographies with these stop IDs
	StopIds []int `json:"stop_ids,omitempty"`
	// Stop ID search radius, in meters
	Radius *float64 `json:"radius,omitempty"`
}

type StopExternalReferenceSetInput struct {
	TargetFeedOnestopID *string `json:"target_feed_onestop_id,omitempty"`
	TargetStopID        *string `json:"target_stop_id,omitempty"`
}

// Search options for stops
type StopFilter struct {
	// Search for stops with this OnestopID
	OnestopID *string `json:"onestop_id,omitempty"`
	// Search for stops with these OnestopIDs
	OnestopIds []string `json:"onestop_ids,omitempty"`
	// Include previous used OnestopIDs that match the same (feed,stop_id)
	AllowPreviousOnestopIds *bool `json:"allow_previous_onestop_ids,omitempty"`
	// Search for stops with this feed version SHA1 hash
	FeedVersionSha1 *string `json:"feed_version_sha1,omitempty"`
	// Search for stops with this feed OnestopID
	FeedOnestopID *string `json:"feed_onestop_id,omitempty"`
	// Search for stops with this GTFS stop_id
	StopID *string `json:"stop_id,omitempty"`
	// Search for stops with this GTFS stop_code
	StopCode *string `json:"stop_code,omitempty"`
	// Search for stops with this GTFS location_type
	LocationType *int `json:"location_type,omitempty"`
	// Search for stops with 1 or more trips (true) or 0 or more trips (false or null)
	Serviced *bool `json:"serviced,omitempty"`
	// Full text search
	Search *string `json:"search,omitempty"`
	// Search for stops with these license details
	License *LicenseFilter `json:"license,omitempty"`
	// Search for stops with service by routes or operators with these OnestopIDs
	ServedByOnestopIds []string `json:"served_by_onestop_ids,omitempty"`
	// Search for stopswith service by routes with the specified GTFS route_type
	ServedByRouteType *int `json:"served_by_route_type,omitempty"`
	// Search for stopswith service by routes with any of the specified GTFS route_types
	ServedByRouteTypes []int `json:"served_by_route_types,omitempty"`
	// Search for stops with these agency integer IDs. Deprecated.
	AgencyIds []int `json:"agency_ids,omitempty"`
	// Search geographically
	Location *StopLocationFilter `json:"location,omitempty"`
	// Backwards compat: Search for stops within this bounding box
	Bbox *BoundingBox `json:"bbox,omitempty"`
	// Backwards compat: Search for stops within this geographic polygon
	Within *tt.Polygon `json:"within,omitempty"`
	// Backwards compat: Search for stops within specified radius of a point
	Near *PointRadius `json:"near,omitempty"`
}

type StopLocationFilter struct {
	// Search for stops within this bounding box
	Bbox *BoundingBox `json:"bbox,omitempty"`
	// Search for stops within this geographic polygon
	Polygon *tt.Polygon `json:"polygon,omitempty"`
	// Search within these enclosing features, and return the matching feature ids
	Features []*Feature `json:"features,omitempty"`
	// Search for stops within specified radius of a point
	Near *PointRadius `json:"near,omitempty"`
	// Search within these geography ids
	GeographyIds []*int `json:"geography_ids,omitempty"`
}

// Measurements of observed arrival times based on GTFS-RT data
type StopObservation struct {
	// GTFS-RT TripUpdate schedule relationship
	ScheduleRelationship *string `json:"schedule_relationship,omitempty"`
	// GTFS-RT TripUpdate trip start date
	TripStartDate *tt.Date `json:"trip_start_date,omitempty"`
	// GTFS-RT TripUpdate trip start time
	TripStartTime *tt.Seconds `json:"trip_start_time,omitempty"`
	// GTFS static origin stop id
	FromStopID *string `json:"from_stop_id,omitempty"`
	// GTFS static destination stop id
	ToStopID *string `json:"to_stop_id,omitempty"`
	// Agency ID for route
	AgencyID *string `json:"agency_id,omitempty"`
	// Route ID for trip
	RouteID *string `json:"route_id,omitempty"`
	// Trip ID
	TripID *string `json:"trip_id,omitempty"`
	// Stop sequence for origin stop
	StopSequence *int `json:"stop_sequence,omitempty"`
	// Source data used to calculate this stop observation. Can be trip update or vehicle positions.
	Source *string `json:"source,omitempty"`
	// GTFS static scheduled arrival time
	ScheduledArrivalTime *tt.Seconds `json:"scheduled_arrival_time,omitempty"`
	// GTFS static scheduled departure time
	ScheduledDepartureTime *tt.Seconds `json:"scheduled_departure_time,omitempty"`
	// GTFS-RT calculated arrival time
	ObservedArrivalTime *tt.Seconds `json:"observed_arrival_time,omitempty"`
	// GTFS-RT calculated departure time
	ObservedDepartureTime *tt.Seconds `json:"observed_departure_time,omitempty"`
	StopID                int         `json:"-"`
}

// Search options for stop observations
type StopObservationFilter struct {
	// Search for stop observations derived from the specified source
	Source string `json:"source"`
	// Search for stop observations associated with this feed version integer ID
	FeedVersionID int `json:"feed_version_id"`
	// Search for stop observations made on this trip start date
	TripStartDate tt.Date `json:"trip_start_date"`
}

// Place associated with a stop
type StopPlace struct {
	// Best-matched state or province name
	Adm1Name *string `json:"adm1_name,omitempty"`
	// Best-matched state or province ISO code
	Adm1Iso *string `json:"adm1_iso,omitempty"`
	// Best-matched country name
	Adm0Name *string `json:"adm0_name,omitempty"`
	// Best-mached country ISO code
	Adm0Iso *string `json:"adm0_iso,omitempty"`
}

// Update a stop entity
type StopSetInput struct {
	// Entity ID to update
	ID *int `json:"id,omitempty"`
	// Feed version of entity to update
	FeedVersion *FeedVersionInput `json:"feed_version,omitempty"`
	// Set GTFS location_type to this value
	LocationType *int `json:"location_type,omitempty"`
	// Set GTFS stop_code to this value
	StopCode *string `json:"stop_code,omitempty"`
	// Set GTFS stop_desc to this value
	StopDesc *string `json:"stop_desc,omitempty"`
	// Set GTFS stop_id to this value
	StopID *string `json:"stop_id,omitempty"`
	// Set GTFS stop_name to this value
	StopName *string `json:"stop_name,omitempty"`
	// Set GTFS stop_timezone to this value
	StopTimezone *string `json:"stop_timezone,omitempty"`
	// Set GTFS stop_url to this value
	StopURL *string `json:"stop_url,omitempty"`
	// Set GTFS wheelchair_boarding to this value
	WheelchairBoarding *int `json:"wheelchair_boarding,omitempty"`
	// Set GTFS zone_id to this value
	ZoneID *string `json:"zone_id,omitempty"`
	// Set GTFS platform_code to this value
	PlatformCode *string `json:"platform_code,omitempty"`
	// Set GTFS tts_stop_name to this value
	TtsStopName *string `json:"tts_stop_name,omitempty"`
	// Set stop geometry to this value
	Geometry *tt.Point `json:"geometry,omitempty"`
	// Set stop parent station to this stop
	Parent *StopSetInput `json:"parent,omitempty"`
	// Set stop level to this level
	Level *LevelSetInput `json:"level,omitempty"`
	// Set or update external reference for this stop
	ExternalReference *StopExternalReferenceSetInput `json:"external_reference,omitempty"`
}

// StopTimeEvent combines scheduled arrival/departure data with data sourced from GTFS-RT
//
// Each scheduled StopTime will try to be matched with a relevant GTFS-RT TripUpdate and StopTimeUpdate.
// If the StopTime has a matching TripUpdate (based on trip_id) and StopTimeUpdate (stop_sequence and/or stop_id), the estimated times will be used directly.
// If a TripUpdate is matched, but no StopTimeUpdate, the last available delay value in the trip will be applied to later StopTimes in that trip.
// If the Trip is ADDED and does not match a static schedule StopTime, the scheduled times will be absent.
//
// See:
// - https://gtfs.org/realtime/reference/#message-tripupdate
// - https://gtfs.org/realtime/reference/#message-stoptimeupdate
// - https://gtfs.org/realtime/reference/#message-stoptimeevent
type StopTimeEvent struct {
	// Local time for stop
	StopTimezone string `json:"stop_timezone"`
	// Estimated time in UTC
	EstimatedUtc *time.Time `json:"estimated_utc,omitempty"`
	// Estimated time in Unix epoch seconds
	EstimatedUnix *int `json:"estimated_unix,omitempty"`
	// Estimated time in the local time zone
	EstimatedLocal *time.Time `json:"estimated_local,omitempty"`
	// Estimated schedule delay, in seconds, based on either a timestamp or overall trip delay.
	//
	// This value can be set directly from a matching GTFS-RT StopTimeUpdate timestamp or delay value or set via an estimated overall trip delay. The value is capped at +/- 86,400 seconds (24 hours). Values larger than that are are likely erroneous and will be set to null.
	EstimatedDelay *int `json:"estimated_delay,omitempty"`
	// Estimated time in local time HH:MM:SS
	Estimated *tt.Seconds `json:"estimated,omitempty"`
	// Scheduled time in UTC
	ScheduledUtc *time.Time `json:"scheduled_utc,omitempty"`
	// Scheduled time in Unix epoch seconds
	ScheduledUnix *int `json:"scheduled_unix,omitempty"`
	// Sceduled time in the local time zone
	ScheduledLocal *time.Time `json:"scheduled_local,omitempty"`
	// Scheduled time local time HH:MM:SS
	Scheduled *tt.Seconds `json:"scheduled,omitempty"`
	// Estimated time in UTC, source directly from matching GTFS-RT StopTimeUpdate. See https://gtfs.org/realtime/reference/#message-stoptimeevent
	TimeUtc *time.Time `json:"time_utc,omitempty"`
	// Estimated time in Unix epoch seconds, source directly from matching GTFS-RT StopTimeUpdate. See https://gtfs.org/realtime/reference/#message-stoptimeevent
	TimeUnix *int `json:"time_unix,omitempty"`
	// Estimated schedule delay, in seconds. This value is set when there is a directly matching GTFS-RT StopTimeUpdate for this stop and passed through as-is. See GTFS Realtime documentation. See https://gtfs.org/realtime/reference/#message-stoptimeevent
	Delay *int `json:"delay,omitempty"`
	// Estimation uncertainty. This value is set when there is a directly matching GTFS-RT StopTimeUpdate for this stop and passed through as-is. See https://gtfs.org/realtime/reference/#message-stoptimeevent
	Uncertainty *int `json:"uncertainty,omitempty"`
}

// Search options for stop times, optionally on a given date
type StopTimeFilter struct {
	// Search for trips scheduled on the specified calendar date
	Date *tt.Date `json:"date,omitempty"`
	// Search for trips scheduled on the specified relative date
	RelativeDate *RelativeDate `json:"relative_date,omitempty"`
	// Search for trips scheduled on the specified GTFS calendar service date
	ServiceDate *tt.Date `json:"service_date,omitempty"`
	// Use the feed version fallback week for dates outside the normal service window for that feed version
	UseServiceWindow *bool `json:"use_service_window,omitempty"`
	// Search for stop times with departure times later than the specified time, in seconds since midnight
	StartTime *int `json:"start_time,omitempty"`
	// Search for stop times with arrival times before the specified time, in seconds since midnight
	EndTime *int `json:"end_time,omitempty"`
	// Search for stop times with departure times later than the specified time, in local time HH:MM:SS
	Start *tt.Seconds `json:"start,omitempty"`
	// Search for stop times with arrival times before the specified time, in local time HH:MM:SS
	End *tt.Seconds `json:"end,omitempty"`
	// Search for stop times with departures within the specified number of seconds (in local time)
	Next *int `json:"next,omitempty"`
	// Search for stop times with service by routes with the specified route OnestopIDs
	RouteOnestopIds []string `json:"route_onestop_ids,omitempty"`
	// Include previously used route OnestopIDs that match the same (feed,route_id)
	AllowPreviousRouteOnestopIds *bool `json:"allow_previous_route_onestop_ids,omitempty"`
	// Exclude the first stop_time in a trip
	ExcludeFirst *bool `json:"exclude_first,omitempty"`
	// Exclude the last stop_time in a trip
	ExcludeLast *bool `json:"exclude_last,omitempty"`
}

// Search options for trips
type TripFilter struct {
	// Search for trips scheduled on the specified GTFS calendar service date
	ServiceDate *tt.Date `json:"service_date,omitempty"`
	// Search for trips scheduled on the specified relative date
	RelativeDate *RelativeDate `json:"relative_date,omitempty"`
	// Use the feed version fallback week for dates outside the normal service window for that feed version
	UseServiceWindow *bool `json:"use_service_window,omitempty"`
	// Search for trips with this GTFS trip_id
	TripID *string `json:"trip_id,omitempty"`
	// Search for trips with this stop pattern ID
	StopPatternID *int `json:"stop_pattern_id,omitempty"`
	// Search for trips with these license details
	License *LicenseFilter `json:"license,omitempty"`
	// Search for trips associated with these route integer IDs. Deprecated.
	RouteIds []int `json:"route_ids,omitempty"`
	// Search for trips associated with these route OnestopIDs
	RouteOnestopIds []string `json:"route_onestop_ids,omitempty"`
	// Search for trips with this feed version SHA1 hash
	FeedVersionSha1 *string `json:"feed_version_sha1,omitempty"`
	// Search for trips with this feed OnestopID
	FeedOnestopID *string `json:"feed_onestop_id,omitempty"`
}

// Search options for stop times for a trip with no date specified
type TripStopTimeFilter struct {
	// Search for stop times with departure times later than the specified time, in local time HH:MM:SS
	Start *tt.Seconds `json:"start,omitempty"`
	// Search for stop times with arrival times before the specified time, in local time HH:MM:SS
	End *tt.Seconds `json:"end,omitempty"`
}

// Source URL and JSON representation of GTFS-RT data used for validation
type ValidationRealtimeResult struct {
	// Source URL
	URL string `json:"url"`
	// JSON representation of GTFS-RT data
	JSON tt.Map `json:"json"`
}

// Validation report for GTFS static and/or GTFS-RT data
type ValidationReport struct {
	// Internal integer ID
	ID int `json:"id"`
	// Time the report was generated, in UTC
	ReportedAt *time.Time `json:"reported_at,omitempty"`
	// Time the reported was generated, in feed local time
	ReportedAtLocal *time.Time `json:"reported_at_local,omitempty"`
	// Time the report was generated, local timezone
	ReportedAtLocalTimezone *string `json:"reported_at_local_timezone,omitempty"`
	// Validation completed successfully
	Success bool `json:"success"`
	// Exception log if feed failed to validate
	FailureReason *string `json:"failure_reason,omitempty"`
	// The report includes GTFS static data
	IncludesStatic *bool `json:"includes_static,omitempty"`
	// The report includes GTFS-RT data
	IncludesRt *bool `json:"includes_rt,omitempty"`
	// Name of validator used
	Validator *string `json:"validator,omitempty"`
	// Version of validator used
	ValidatorVersion *string `json:"validator_version,omitempty"`
	// Validation errors, grouped by filename, if present
	Errors []*ValidationReportErrorGroup `json:"errors"`
	// Validation warnings, grouped by filename, if present
	Warnings []*ValidationReportErrorGroup `json:"warnings"`
	// Details about the validated feed
	Details       *ValidationReportDetails `json:"details,omitempty"`
	FeedVersionID int                      `json:"-"`
}

// Details about the validated feed, including selected entities, metadata of contained files, calendar extent, etc.
type ValidationReportDetails struct {
	// SHA1 hash of the validated feed
	Sha1 string `json:"sha1"`
	// Calculated earliest calendar date in service schedule
	EarliestCalendarDate *tt.Date `json:"earliest_calendar_date,omitempty"`
	// Calculated latest calendar date in service schedule
	LatestCalendarDate *tt.Date `json:"latest_calendar_date,omitempty"`
	// Details for each file contained in the feed
	Files []*FeedVersionFileInfo `json:"files"`
	// Calculated service levels for feed
	ServiceLevels []*FeedVersionServiceLevel `json:"service_levels"`
	// Selected agencies contained in feed
	Agencies []*Agency `json:"agencies"`
	// Selected routes contained in feed
	Routes []*Route `json:"routes"`
	// Selected stops contained in feed
	Stops []*Stop `json:"stops"`
	// Feed info data contained in feed
	FeedInfos []*FeedInfo `json:"feed_infos"`
	// Detailed information about GTFS-RT sources used in validation
	Realtime []*ValidationRealtimeResult `json:"realtime,omitempty"`
}

// An individual validation error or warning.
type ValidationReportError struct {
	// Source filename
	Filename string `json:"filename"`
	// Error type
	ErrorType string `json:"error_type"`
	// Error code (for GTFS-RT)
	ErrorCode string `json:"error_code"`
	// Key for this error group
	GroupKey string `json:"group_key"`
	// Affected entity ID
	EntityID string `json:"entity_id"`
	// Affected entity field
	Field string `json:"field"`
	// Affected entity line number (for static)
	Line int `json:"line"`
	// Value of affected field
	Value string `json:"value"`
	// Error message describing problem
	Message string `json:"message"`
	// Entity geometry, if available
	Geometry *tt.Geometry `json:"geometry,omitempty"`
	// JSON representation of entity, if available
	EntityJSON                   tt.Map `json:"entity_json"`
	ID                           int    `json:"-"`
	ValidationReportErrorGroupID int    `json:"-"`
}

// Validation errors and warnings for a particular file or RT source
type ValidationReportErrorGroup struct {
	// Filename for error group
	Filename string `json:"filename"`
	// Error type
	ErrorType string `json:"error_type"`
	// Error code (for GTFS-RT)
	ErrorCode string `json:"error_code"`
	// Key for this error group
	GroupKey string `json:"group_key"`
	// Affected entity field for this error group
	Field string `json:"field"`
	// Number of affected entities for this error group
	Count int `json:"count"`
	// Examples of this error
	Errors             []*ValidationReportError `json:"errors"`
	ID                 int                      `json:"-"`
	ValidationReportID int                      `json:"-"`
}

// Search options for validation reports
type ValidationReportFilter struct {
	// Search for validation reports with the following integer IDs
	ReportIds []int `json:"report_ids,omitempty"`
	// Search for successful validation reports
	Success *bool `json:"success,omitempty"`
	// Search for validation reports generated by the specified validator
	Validator *string `json:"validator,omitempty"`
	// Search for validation reports generated using the specified validator version
	ValidatorVersion *string `json:"validator_version,omitempty"`
	// Search for validation reports that include/exclude GTFS-RT data
	IncludesRt *bool `json:"includes_rt,omitempty"`
	// Search for validation reports that include/exclude GTFS static data
	IncludesStatic *bool `json:"includes_static,omitempty"`
}

// [Vehicle Position](https://gtfs.org/reference/realtime/v2/#message-vehicleposition) message provided by a source GTFS Realtime feed.
type VehiclePosition struct {
	// GTFS-RT VehiclePosition vehicle. See https://gtfs.org/realtime/reference/#message-vehicledescriptor
	Vehicle *RTVehicleDescriptor `json:"vehicle,omitempty"`
	// GTFS-RT VehiclePosition current vehicle position
	Position *tt.Point `json:"position,omitempty"`
	// GTFS-RT VehiclePosition current stop sequence in trip
	CurrentStopSequence *int `json:"current_stop_sequence,omitempty"`
	// GTFS-RT VehiclePosition current stop in trip
	StopID *Stop `json:"stop_id,omitempty"`
	// GTFS-RT VehiclePosition current status string
	CurrentStatus *string `json:"current_status,omitempty"`
	// GTFS-RT VehiclePosition timestamp
	Timestamp *time.Time `json:"timestamp,omitempty"`
	// GTFS-RT VehiclePosition congestion level estimate
	CongestionLevel *string `json:"congestion_level,omitempty"`
}

type Waypoint struct {
	Lon  float64       `json:"lon"`
	Lat  float64       `json:"lat"`
	Name *string       `json:"name,omitempty"`
	Stop *WaypointStop `json:"stop,omitempty"`
}

type WaypointDeparture struct {
	Lon           float64   `json:"lon"`
	Lat           float64   `json:"lat"`
	Departure     time.Time `json:"departure"`
	StopID        string    `json:"stop_id"`
	StopName      string    `json:"stop_name"`
	StopCode      string    `json:"stop_code"`
	StopOnestopID string    `json:"stop_onestop_id"`
	StopIndex     *int      `json:"stop_index,omitempty"`
	StopSequence  *int      `json:"stop_sequence,omitempty"`
}

type WaypointInput struct {
	Lon  float64 `json:"lon"`
	Lat  float64 `json:"lat"`
	Name *string `json:"name,omitempty"`
}

type WaypointStop struct {
	Lon           float64   `json:"lon"`
	Lat           float64   `json:"lat"`
	Departure     time.Time `json:"departure"`
	StopID        string    `json:"stop_id"`
	StopName      string    `json:"stop_name"`
	StopCode      string    `json:"stop_code"`
	StopOnestopID string    `json:"stop_onestop_id"`
}

type DistanceUnit string

const (
	DistanceUnitKilometers DistanceUnit = "KILOMETERS"
	DistanceUnitMeters     DistanceUnit = "METERS"
	DistanceUnitMiles      DistanceUnit = "MILES"
)

var AllDistanceUnit = []DistanceUnit{
	DistanceUnitKilometers,
	DistanceUnitMeters,
	DistanceUnitMiles,
}

func (e DistanceUnit) IsValid() bool {
	switch e {
	case DistanceUnitKilometers, DistanceUnitMeters, DistanceUnitMiles:
		return true
	}
	return false
}

func (e DistanceUnit) String() string {
	return string(e)
}

func (e *DistanceUnit) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DistanceUnit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DistanceUnit", str)
	}
	return nil
}

func (e DistanceUnit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DistanceUnit) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DistanceUnit) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DurationUnit string

const (
	DurationUnitSeconds DurationUnit = "SECONDS"
)

var AllDurationUnit = []DurationUnit{
	DurationUnitSeconds,
}

func (e DurationUnit) IsValid() bool {
	switch e {
	case DurationUnitSeconds:
		return true
	}
	return false
}

func (e DurationUnit) String() string {
	return string(e)
}

func (e *DurationUnit) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DurationUnit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DurationUnit", str)
	}
	return nil
}

func (e DurationUnit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DurationUnit) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DurationUnit) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Feed source URL types
type FeedSourceURLTypes string

const (
	// URL to the current static GTFS
	FeedSourceURLTypesStaticCurrent FeedSourceURLTypes = "static_current"
	// URL to a previously used static GTFS
	FeedSourceURLTypesStaticHistoric FeedSourceURLTypes = "static_historic"
	// URL to a planned future static GTFS
	FeedSourceURLTypesStaticPlanned FeedSourceURLTypes = "static_planned"
	// URL to a proposed future static GTFS
	FeedSourceURLTypesStaticHypothetical FeedSourceURLTypes = "static_hypothetical"
	// URL to GTFS-RT vehicle positions
	FeedSourceURLTypesRealtimeVehiclePositions FeedSourceURLTypes = "realtime_vehicle_positions"
	// URL to GTFS-RT trip updates
	FeedSourceURLTypesRealtimeTripUpdates FeedSourceURLTypes = "realtime_trip_updates"
	// URL to GTFS-RT alerts
	FeedSourceURLTypesRealtimeAlerts FeedSourceURLTypes = "realtime_alerts"
	// URL to a GBFS service auto-discovery endpoint
	FeedSourceURLTypesGbfsAutoDiscovery FeedSourceURLTypes = "gbfs_auto_discovery"
	// URL to a MDS data set
	FeedSourceURLTypesMdsProvider FeedSourceURLTypes = "mds_provider"
)

var AllFeedSourceURLTypes = []FeedSourceURLTypes{
	FeedSourceURLTypesStaticCurrent,
	FeedSourceURLTypesStaticHistoric,
	FeedSourceURLTypesStaticPlanned,
	FeedSourceURLTypesStaticHypothetical,
	FeedSourceURLTypesRealtimeVehiclePositions,
	FeedSourceURLTypesRealtimeTripUpdates,
	FeedSourceURLTypesRealtimeAlerts,
	FeedSourceURLTypesGbfsAutoDiscovery,
	FeedSourceURLTypesMdsProvider,
}

func (e FeedSourceURLTypes) IsValid() bool {
	switch e {
	case FeedSourceURLTypesStaticCurrent, FeedSourceURLTypesStaticHistoric, FeedSourceURLTypesStaticPlanned, FeedSourceURLTypesStaticHypothetical, FeedSourceURLTypesRealtimeVehiclePositions, FeedSourceURLTypesRealtimeTripUpdates, FeedSourceURLTypesRealtimeAlerts, FeedSourceURLTypesGbfsAutoDiscovery, FeedSourceURLTypesMdsProvider:
		return true
	}
	return false
}

func (e FeedSourceURLTypes) String() string {
	return string(e)
}

func (e *FeedSourceURLTypes) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeedSourceURLTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeedSourceUrlTypes", str)
	}
	return nil
}

func (e FeedSourceURLTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FeedSourceURLTypes) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FeedSourceURLTypes) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of data contained in a source feed
type FeedSpecTypes string

const (
	// Static data
	FeedSpecTypesGtfs FeedSpecTypes = "GTFS"
	// GTFS-RT data
	FeedSpecTypesGtfsRt FeedSpecTypes = "GTFS_RT"
	// GBFS data
	FeedSpecTypesGbfs FeedSpecTypes = "GBFS"
	// MDS data
	FeedSpecTypesMds FeedSpecTypes = "MDS"
)

var AllFeedSpecTypes = []FeedSpecTypes{
	FeedSpecTypesGtfs,
	FeedSpecTypesGtfsRt,
	FeedSpecTypesGbfs,
	FeedSpecTypesMds,
}

func (e FeedSpecTypes) IsValid() bool {
	switch e {
	case FeedSpecTypesGtfs, FeedSpecTypesGtfsRt, FeedSpecTypesGbfs, FeedSpecTypesMds:
		return true
	}
	return false
}

func (e FeedSpecTypes) String() string {
	return string(e)
}

func (e *FeedSpecTypes) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeedSpecTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeedSpecTypes", str)
	}
	return nil
}

func (e FeedSpecTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FeedSpecTypes) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FeedSpecTypes) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Import status for a feed version
type ImportStatus string

const (
	// Imported successfully
	ImportStatusSuccess ImportStatus = "SUCCESS"
	// Did not import successfully
	ImportStatusError ImportStatus = "ERROR"
	// Import is currently in progress
	ImportStatusInProgress ImportStatus = "IN_PROGRESS"
)

var AllImportStatus = []ImportStatus{
	ImportStatusSuccess,
	ImportStatusError,
	ImportStatusInProgress,
}

func (e ImportStatus) IsValid() bool {
	switch e {
	case ImportStatusSuccess, ImportStatusError, ImportStatusInProgress:
		return true
	}
	return false
}

func (e ImportStatus) String() string {
	return string(e)
}

func (e *ImportStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImportStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImportStatus", str)
	}
	return nil
}

func (e ImportStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ImportStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ImportStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Permissable and impermissable actions for a given license use
type LicenseValue string

const (
	// Use is allowed
	LicenseValueYes LicenseValue = "YES"
	// Use is not allowed
	LicenseValueNo LicenseValue = "NO"
	// Use is YES or UNKNOWN
	LicenseValueExcludeNo LicenseValue = "EXCLUDE_NO"
	// Use is not known
	LicenseValueUnknown LicenseValue = "UNKNOWN"
)

var AllLicenseValue = []LicenseValue{
	LicenseValueYes,
	LicenseValueNo,
	LicenseValueExcludeNo,
	LicenseValueUnknown,
}

func (e LicenseValue) IsValid() bool {
	switch e {
	case LicenseValueYes, LicenseValueNo, LicenseValueExcludeNo, LicenseValueUnknown:
		return true
	}
	return false
}

func (e LicenseValue) String() string {
	return string(e)
}

func (e *LicenseValue) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseValue(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseValue", str)
	}
	return nil
}

func (e LicenseValue) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LicenseValue) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LicenseValue) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// PlaceAggregationLevel controls the level of aggregation in a places query
type PlaceAggregationLevel string

const (
	// Aggregate places based on country
	PlaceAggregationLevelAdm0 PlaceAggregationLevel = "ADM0"
	// Aggregate places based on country and state/province
	PlaceAggregationLevelAdm0Adm1 PlaceAggregationLevel = "ADM0_ADM1"
	// Aggregate places based on country, state/province, and city
	PlaceAggregationLevelAdm0Adm1City PlaceAggregationLevel = "ADM0_ADM1_CITY"
	// Aggregate places based on country and city
	PlaceAggregationLevelAdm0City PlaceAggregationLevel = "ADM0_CITY"
	// Aggregate places based on state/province and city
	PlaceAggregationLevelAdm1City PlaceAggregationLevel = "ADM1_CITY"
	// Aggregate places based on city
	PlaceAggregationLevelCity PlaceAggregationLevel = "CITY"
)

var AllPlaceAggregationLevel = []PlaceAggregationLevel{
	PlaceAggregationLevelAdm0,
	PlaceAggregationLevelAdm0Adm1,
	PlaceAggregationLevelAdm0Adm1City,
	PlaceAggregationLevelAdm0City,
	PlaceAggregationLevelAdm1City,
	PlaceAggregationLevelCity,
}

func (e PlaceAggregationLevel) IsValid() bool {
	switch e {
	case PlaceAggregationLevelAdm0, PlaceAggregationLevelAdm0Adm1, PlaceAggregationLevelAdm0Adm1City, PlaceAggregationLevelAdm0City, PlaceAggregationLevelAdm1City, PlaceAggregationLevelCity:
		return true
	}
	return false
}

func (e PlaceAggregationLevel) String() string {
	return string(e)
}

func (e *PlaceAggregationLevel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlaceAggregationLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlaceAggregationLevel", str)
	}
	return nil
}

func (e PlaceAggregationLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PlaceAggregationLevel) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PlaceAggregationLevel) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// RelativeDate specifies a calendar date relative to the current local time
type RelativeDate string

const (
	// The current date
	RelativeDateToday RelativeDate = "TODAY"
	// Next Monday, or today if it is currently Monday
	RelativeDateMonday RelativeDate = "MONDAY"
	// Next Tuesday, or today if it is currently Tuesday
	RelativeDateTuesday RelativeDate = "TUESDAY"
	// Next Wednesday, or today if it is currently Wednesday
	RelativeDateWednesday RelativeDate = "WEDNESDAY"
	// Next Thursday, or today if it is currently Thursday
	RelativeDateThursday RelativeDate = "THURSDAY"
	// Next Friday, or today if it is currently Friday
	RelativeDateFriday RelativeDate = "FRIDAY"
	// Next Saturday, or today if it is currently Saturday
	RelativeDateSaturday RelativeDate = "SATURDAY"
	// Next Sunday, or today if it is currently Sunday
	RelativeDateSunday RelativeDate = "SUNDAY"
	// Next Monday, not inclusive of today
	RelativeDateNextMonday RelativeDate = "NEXT_MONDAY"
	// Next Tuesday, not inclusive of today
	RelativeDateNextTuesday RelativeDate = "NEXT_TUESDAY"
	// Next Wednesday, not inclusive of today
	RelativeDateNextWednesday RelativeDate = "NEXT_WEDNESDAY"
	// Next Thursday, not inclusive of today
	RelativeDateNextThursday RelativeDate = "NEXT_THURSDAY"
	// Next Friday, not inclusive of today
	RelativeDateNextFriday RelativeDate = "NEXT_FRIDAY"
	// Next Saturday, not inclusive of today
	RelativeDateNextSaturday RelativeDate = "NEXT_SATURDAY"
	// Next Sunday, not inclusive of today
	RelativeDateNextSunday RelativeDate = "NEXT_SUNDAY"
)

var AllRelativeDate = []RelativeDate{
	RelativeDateToday,
	RelativeDateMonday,
	RelativeDateTuesday,
	RelativeDateWednesday,
	RelativeDateThursday,
	RelativeDateFriday,
	RelativeDateSaturday,
	RelativeDateSunday,
	RelativeDateNextMonday,
	RelativeDateNextTuesday,
	RelativeDateNextWednesday,
	RelativeDateNextThursday,
	RelativeDateNextFriday,
	RelativeDateNextSaturday,
	RelativeDateNextSunday,
}

func (e RelativeDate) IsValid() bool {
	switch e {
	case RelativeDateToday, RelativeDateMonday, RelativeDateTuesday, RelativeDateWednesday, RelativeDateThursday, RelativeDateFriday, RelativeDateSaturday, RelativeDateSunday, RelativeDateNextMonday, RelativeDateNextTuesday, RelativeDateNextWednesday, RelativeDateNextThursday, RelativeDateNextFriday, RelativeDateNextSaturday, RelativeDateNextSunday:
		return true
	}
	return false
}

func (e RelativeDate) String() string {
	return string(e)
}

func (e *RelativeDate) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RelativeDate(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RelativeDate", str)
	}
	return nil
}

func (e RelativeDate) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RelativeDate) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RelativeDate) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// GTFS-RT TripUpdate and StopTimeEvent schedule relationship.
//
// This enum combines possible values from both schedule relationship types, plus an additional STATIC value.
//
// See:
// - [ScheduleRelationship](https://gtfs.org/realtime/reference/#enum-schedulerelationship)
// - [ScheduleRelationship](https://gtfs.org/realtime/reference/#enum-schedulerelationship-1)
type ScheduleRelationship string

const (
	ScheduleRelationshipScheduled   ScheduleRelationship = "SCHEDULED"
	ScheduleRelationshipAdded       ScheduleRelationship = "ADDED"
	ScheduleRelationshipUnscheduled ScheduleRelationship = "UNSCHEDULED"
	ScheduleRelationshipCanceled    ScheduleRelationship = "CANCELED"
	ScheduleRelationshipStatic      ScheduleRelationship = "STATIC"
	ScheduleRelationshipSkipped     ScheduleRelationship = "SKIPPED"
	ScheduleRelationshipNoData      ScheduleRelationship = "NO_DATA"
	ScheduleRelationshipReplacement ScheduleRelationship = "REPLACEMENT"
	ScheduleRelationshipDuplicated  ScheduleRelationship = "DUPLICATED"
	ScheduleRelationshipDeleted     ScheduleRelationship = "DELETED"
)

var AllScheduleRelationship = []ScheduleRelationship{
	ScheduleRelationshipScheduled,
	ScheduleRelationshipAdded,
	ScheduleRelationshipUnscheduled,
	ScheduleRelationshipCanceled,
	ScheduleRelationshipStatic,
	ScheduleRelationshipSkipped,
	ScheduleRelationshipNoData,
	ScheduleRelationshipReplacement,
	ScheduleRelationshipDuplicated,
	ScheduleRelationshipDeleted,
}

func (e ScheduleRelationship) IsValid() bool {
	switch e {
	case ScheduleRelationshipScheduled, ScheduleRelationshipAdded, ScheduleRelationshipUnscheduled, ScheduleRelationshipCanceled, ScheduleRelationshipStatic, ScheduleRelationshipSkipped, ScheduleRelationshipNoData, ScheduleRelationshipReplacement, ScheduleRelationshipDuplicated, ScheduleRelationshipDeleted:
		return true
	}
	return false
}

func (e ScheduleRelationship) String() string {
	return string(e)
}

func (e *ScheduleRelationship) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScheduleRelationship(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScheduleRelationship", str)
	}
	return nil
}

func (e ScheduleRelationship) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ScheduleRelationship) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ScheduleRelationship) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StepMode string

const (
	StepModeWalk    StepMode = "WALK"
	StepModeAuto    StepMode = "AUTO"
	StepModeBicycle StepMode = "BICYCLE"
	StepModeTransit StepMode = "TRANSIT"
	StepModeLine    StepMode = "LINE"
)

var AllStepMode = []StepMode{
	StepModeWalk,
	StepModeAuto,
	StepModeBicycle,
	StepModeTransit,
	StepModeLine,
}

func (e StepMode) IsValid() bool {
	switch e {
	case StepModeWalk, StepModeAuto, StepModeBicycle, StepModeTransit, StepModeLine:
		return true
	}
	return false
}

func (e StepMode) String() string {
	return string(e)
}

func (e *StepMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StepMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StepMode", str)
	}
	return nil
}

func (e StepMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StepMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StepMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
