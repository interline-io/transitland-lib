// Copyright 2015 The GTFS Specifications Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Protocol definition file for GTFS Realtime.
//
// GTFS Realtime lets transit agencies provide consumers with realtime
// information about disruptions to their service (stations closed, lines not
// operating, important delays etc), location of their vehicles and expected
// arrival times.
//
// This protocol is published at:
// https://github.com/google/transit/tree/master/gtfs-realtime

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v6.33.2
// source: gtfs-realtime.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Determines whether the current fetch is incremental.  Currently,
// DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
// that use this mode.  There are discussions on the GTFS Realtime mailing
// list around fully specifying the behavior of DIFFERENTIAL mode and the
// documentation will be updated when those discussions are finalized.
type FeedHeader_Incrementality int32

const (
	FeedHeader_FULL_DATASET FeedHeader_Incrementality = 0
	FeedHeader_DIFFERENTIAL FeedHeader_Incrementality = 1
)

// Enum value maps for FeedHeader_Incrementality.
var (
	FeedHeader_Incrementality_name = map[int32]string{
		0: "FULL_DATASET",
		1: "DIFFERENTIAL",
	}
	FeedHeader_Incrementality_value = map[string]int32{
		"FULL_DATASET": 0,
		"DIFFERENTIAL": 1,
	}
)

func (x FeedHeader_Incrementality) Enum() *FeedHeader_Incrementality {
	p := new(FeedHeader_Incrementality)
	*p = x
	return p
}

func (x FeedHeader_Incrementality) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FeedHeader_Incrementality) Descriptor() protoreflect.EnumDescriptor {
	return file_gtfs_realtime_proto_enumTypes[0].Descriptor()
}

func (FeedHeader_Incrementality) Type() protoreflect.EnumType {
	return &file_gtfs_realtime_proto_enumTypes[0]
}

func (x FeedHeader_Incrementality) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *FeedHeader_Incrementality) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = FeedHeader_Incrementality(num)
	return nil
}

// Deprecated: Use FeedHeader_Incrementality.Descriptor instead.
func (FeedHeader_Incrementality) EnumDescriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{1, 0}
}

// The relation between the StopTimeEvents and the static schedule.
type TripUpdate_StopTimeUpdate_ScheduleRelationship int32

const (
	// The vehicle is proceeding in accordance with its static schedule of
	// stops, although not necessarily according to the times of the schedule.
	// At least one of arrival and departure must be provided. If the schedule
	// for this stop contains both arrival and departure times then so must
	// this update. Frequency-based trips (GTFS frequencies.txt with exact_times = 0)
	// should not have a SCHEDULED value and should use UNSCHEDULED instead.
	TripUpdate_StopTimeUpdate_SCHEDULED TripUpdate_StopTimeUpdate_ScheduleRelationship = 0
	// The stop is skipped, i.e., the vehicle will not stop at this stop.
	// Arrival and departure are optional.
	TripUpdate_StopTimeUpdate_SKIPPED TripUpdate_StopTimeUpdate_ScheduleRelationship = 1
	// No StopTimeEvents are given for this stop.
	// The main intention for this value is to give time predictions only for
	// part of a trip, i.e., if the last update for a trip has a NO_DATA
	// specifier, then StopTimeEvents for the rest of the stops in the trip
	// are considered to be unspecified as well.
	// Neither arrival nor departure should be supplied.
	TripUpdate_StopTimeUpdate_NO_DATA TripUpdate_StopTimeUpdate_ScheduleRelationship = 2
	// The vehicle is operating a trip defined in GTFS frequencies.txt with exact_times = 0.
	// This value should not be used for trips that are not defined in GTFS frequencies.txt,
	// or trips in GTFS frequencies.txt with exact_times = 1. Trips containing StopTimeUpdates
	// with ScheduleRelationship=UNSCHEDULED must also set TripDescriptor.ScheduleRelationship=UNSCHEDULED.
	// NOTE: This field is still experimental, and subject to change. It may be
	// formally adopted in the future.
	TripUpdate_StopTimeUpdate_UNSCHEDULED TripUpdate_StopTimeUpdate_ScheduleRelationship = 3
)

// Enum value maps for TripUpdate_StopTimeUpdate_ScheduleRelationship.
var (
	TripUpdate_StopTimeUpdate_ScheduleRelationship_name = map[int32]string{
		0: "SCHEDULED",
		1: "SKIPPED",
		2: "NO_DATA",
		3: "UNSCHEDULED",
	}
	TripUpdate_StopTimeUpdate_ScheduleRelationship_value = map[string]int32{
		"SCHEDULED":   0,
		"SKIPPED":     1,
		"NO_DATA":     2,
		"UNSCHEDULED": 3,
	}
)

func (x TripUpdate_StopTimeUpdate_ScheduleRelationship) Enum() *TripUpdate_StopTimeUpdate_ScheduleRelationship {
	p := new(TripUpdate_StopTimeUpdate_ScheduleRelationship)
	*p = x
	return p
}

func (x TripUpdate_StopTimeUpdate_ScheduleRelationship) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TripUpdate_StopTimeUpdate_ScheduleRelationship) Descriptor() protoreflect.EnumDescriptor {
	return file_gtfs_realtime_proto_enumTypes[1].Descriptor()
}

func (TripUpdate_StopTimeUpdate_ScheduleRelationship) Type() protoreflect.EnumType {
	return &file_gtfs_realtime_proto_enumTypes[1]
}

func (x TripUpdate_StopTimeUpdate_ScheduleRelationship) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *TripUpdate_StopTimeUpdate_ScheduleRelationship) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = TripUpdate_StopTimeUpdate_ScheduleRelationship(num)
	return nil
}

// Deprecated: Use TripUpdate_StopTimeUpdate_ScheduleRelationship.Descriptor instead.
func (TripUpdate_StopTimeUpdate_ScheduleRelationship) EnumDescriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{3, 1, 0}
}

type VehiclePosition_VehicleStopStatus int32

const (
	// The vehicle is just about to arrive at the stop (on a stop
	// display, the vehicle symbol typically flashes).
	VehiclePosition_INCOMING_AT VehiclePosition_VehicleStopStatus = 0
	// The vehicle is standing at the stop.
	VehiclePosition_STOPPED_AT VehiclePosition_VehicleStopStatus = 1
	// The vehicle has departed and is in transit to the next stop.
	VehiclePosition_IN_TRANSIT_TO VehiclePosition_VehicleStopStatus = 2
)

// Enum value maps for VehiclePosition_VehicleStopStatus.
var (
	VehiclePosition_VehicleStopStatus_name = map[int32]string{
		0: "INCOMING_AT",
		1: "STOPPED_AT",
		2: "IN_TRANSIT_TO",
	}
	VehiclePosition_VehicleStopStatus_value = map[string]int32{
		"INCOMING_AT":   0,
		"STOPPED_AT":    1,
		"IN_TRANSIT_TO": 2,
	}
)

func (x VehiclePosition_VehicleStopStatus) Enum() *VehiclePosition_VehicleStopStatus {
	p := new(VehiclePosition_VehicleStopStatus)
	*p = x
	return p
}

func (x VehiclePosition_VehicleStopStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VehiclePosition_VehicleStopStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_gtfs_realtime_proto_enumTypes[2].Descriptor()
}

func (VehiclePosition_VehicleStopStatus) Type() protoreflect.EnumType {
	return &file_gtfs_realtime_proto_enumTypes[2]
}

func (x VehiclePosition_VehicleStopStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *VehiclePosition_VehicleStopStatus) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = VehiclePosition_VehicleStopStatus(num)
	return nil
}

// Deprecated: Use VehiclePosition_VehicleStopStatus.Descriptor instead.
func (VehiclePosition_VehicleStopStatus) EnumDescriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{4, 0}
}

// Congestion level that is affecting this vehicle.
type VehiclePosition_CongestionLevel int32

const (
	VehiclePosition_UNKNOWN_CONGESTION_LEVEL VehiclePosition_CongestionLevel = 0
	VehiclePosition_RUNNING_SMOOTHLY         VehiclePosition_CongestionLevel = 1
	VehiclePosition_STOP_AND_GO              VehiclePosition_CongestionLevel = 2
	VehiclePosition_CONGESTION               VehiclePosition_CongestionLevel = 3
	VehiclePosition_SEVERE_CONGESTION        VehiclePosition_CongestionLevel = 4 // People leaving their cars.
)

// Enum value maps for VehiclePosition_CongestionLevel.
var (
	VehiclePosition_CongestionLevel_name = map[int32]string{
		0: "UNKNOWN_CONGESTION_LEVEL",
		1: "RUNNING_SMOOTHLY",
		2: "STOP_AND_GO",
		3: "CONGESTION",
		4: "SEVERE_CONGESTION",
	}
	VehiclePosition_CongestionLevel_value = map[string]int32{
		"UNKNOWN_CONGESTION_LEVEL": 0,
		"RUNNING_SMOOTHLY":         1,
		"STOP_AND_GO":              2,
		"CONGESTION":               3,
		"SEVERE_CONGESTION":        4,
	}
)

func (x VehiclePosition_CongestionLevel) Enum() *VehiclePosition_CongestionLevel {
	p := new(VehiclePosition_CongestionLevel)
	*p = x
	return p
}

func (x VehiclePosition_CongestionLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VehiclePosition_CongestionLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_gtfs_realtime_proto_enumTypes[3].Descriptor()
}

func (VehiclePosition_CongestionLevel) Type() protoreflect.EnumType {
	return &file_gtfs_realtime_proto_enumTypes[3]
}

func (x VehiclePosition_CongestionLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *VehiclePosition_CongestionLevel) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = VehiclePosition_CongestionLevel(num)
	return nil
}

// Deprecated: Use VehiclePosition_CongestionLevel.Descriptor instead.
func (VehiclePosition_CongestionLevel) EnumDescriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{4, 1}
}

// The state of passenger occupancy for the vehicle or carriage.
// Individual producers may not publish all OccupancyStatus values. Therefore, consumers
// must not assume that the OccupancyStatus values follow a linear scale.
// Consumers should represent OccupancyStatus values as the state indicated
// and intended by the producer. Likewise, producers must use OccupancyStatus values that
// correspond to actual vehicle occupancy states.
// For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`.
// This field is still experimental, and subject to change. It may be formally adopted in the future.
type VehiclePosition_OccupancyStatus int32

const (
	// The vehicle or carriage is considered empty by most measures, and has few or no
	// passengers onboard, but is still accepting passengers.
	VehiclePosition_EMPTY VehiclePosition_OccupancyStatus = 0
	// The vehicle or carriage has a large number of seats available.
	// The amount of free seats out of the total seats available to be
	// considered large enough to fall into this category is determined at the
	// discretion of the producer.
	VehiclePosition_MANY_SEATS_AVAILABLE VehiclePosition_OccupancyStatus = 1
	// The vehicle or carriage has a relatively small number of seats available.
	// The amount of free seats out of the total seats available to be
	// considered small enough to fall into this category is determined at the
	// discretion of the feed producer.
	VehiclePosition_FEW_SEATS_AVAILABLE VehiclePosition_OccupancyStatus = 2
	// The vehicle or carriage can currently accommodate only standing passengers.
	VehiclePosition_STANDING_ROOM_ONLY VehiclePosition_OccupancyStatus = 3
	// The vehicle or carriage can currently accommodate only standing passengers
	// and has limited space for them.
	VehiclePosition_CRUSHED_STANDING_ROOM_ONLY VehiclePosition_OccupancyStatus = 4
	// The vehicle or carriage is considered full by most measures, but may still be
	// allowing passengers to board.
	VehiclePosition_FULL VehiclePosition_OccupancyStatus = 5
	// The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding.
	VehiclePosition_NOT_ACCEPTING_PASSENGERS VehiclePosition_OccupancyStatus = 6
	// The vehicle or carriage doesn't have any occupancy data available at that time.
	VehiclePosition_NO_DATA_AVAILABLE VehiclePosition_OccupancyStatus = 7
	// The vehicle or carriage is not boardable and never accepts passengers.
	// Useful for special vehicles or carriages (engine, maintenance carriage, etcâ€¦).
	VehiclePosition_NOT_BOARDABLE VehiclePosition_OccupancyStatus = 8
)

// Enum value maps for VehiclePosition_OccupancyStatus.
var (
	VehiclePosition_OccupancyStatus_name = map[int32]string{
		0: "EMPTY",
		1: "MANY_SEATS_AVAILABLE",
		2: "FEW_SEATS_AVAILABLE",
		3: "STANDING_ROOM_ONLY",
		4: "CRUSHED_STANDING_ROOM_ONLY",
		5: "FULL",
		6: "NOT_ACCEPTING_PASSENGERS",
		7: "NO_DATA_AVAILABLE",
		8: "NOT_BOARDABLE",
	}
	VehiclePosition_OccupancyStatus_value = map[string]int32{
		"EMPTY":                      0,
		"MANY_SEATS_AVAILABLE":       1,
		"FEW_SEATS_AVAILABLE":        2,
		"STANDING_ROOM_ONLY":         3,
		"CRUSHED_STANDING_ROOM_ONLY": 4,
		"FULL":                       5,
		"NOT_ACCEPTING_PASSENGERS":   6,
		"NO_DATA_AVAILABLE":          7,
		"NOT_BOARDABLE":              8,
	}
)

func (x VehiclePosition_OccupancyStatus) Enum() *VehiclePosition_OccupancyStatus {
	p := new(VehiclePosition_OccupancyStatus)
	*p = x
	return p
}

func (x VehiclePosition_OccupancyStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VehiclePosition_OccupancyStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_gtfs_realtime_proto_enumTypes[4].Descriptor()
}

func (VehiclePosition_OccupancyStatus) Type() protoreflect.EnumType {
	return &file_gtfs_realtime_proto_enumTypes[4]
}

func (x VehiclePosition_OccupancyStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *VehiclePosition_OccupancyStatus) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = VehiclePosition_OccupancyStatus(num)
	return nil
}

// Deprecated: Use VehiclePosition_OccupancyStatus.Descriptor instead.
func (VehiclePosition_OccupancyStatus) EnumDescriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{4, 2}
}

// Cause of this alert. If cause_detail is included, then Cause must also be included.
type Alert_Cause int32

const (
	Alert_UNKNOWN_CAUSE     Alert_Cause = 1
	Alert_OTHER_CAUSE       Alert_Cause = 2 // Not machine-representable.
	Alert_TECHNICAL_PROBLEM Alert_Cause = 3
	Alert_STRIKE            Alert_Cause = 4 // Public transit agency employees stopped working.
	Alert_DEMONSTRATION     Alert_Cause = 5 // People are blocking the streets.
	Alert_ACCIDENT          Alert_Cause = 6
	Alert_HOLIDAY           Alert_Cause = 7
	Alert_WEATHER           Alert_Cause = 8
	Alert_MAINTENANCE       Alert_Cause = 9
	Alert_CONSTRUCTION      Alert_Cause = 10
	Alert_POLICE_ACTIVITY   Alert_Cause = 11
	Alert_MEDICAL_EMERGENCY Alert_Cause = 12
)

// Enum value maps for Alert_Cause.
var (
	Alert_Cause_name = map[int32]string{
		1:  "UNKNOWN_CAUSE",
		2:  "OTHER_CAUSE",
		3:  "TECHNICAL_PROBLEM",
		4:  "STRIKE",
		5:  "DEMONSTRATION",
		6:  "ACCIDENT",
		7:  "HOLIDAY",
		8:  "WEATHER",
		9:  "MAINTENANCE",
		10: "CONSTRUCTION",
		11: "POLICE_ACTIVITY",
		12: "MEDICAL_EMERGENCY",
	}
	Alert_Cause_value = map[string]int32{
		"UNKNOWN_CAUSE":     1,
		"OTHER_CAUSE":       2,
		"TECHNICAL_PROBLEM": 3,
		"STRIKE":            4,
		"DEMONSTRATION":     5,
		"ACCIDENT":          6,
		"HOLIDAY":           7,
		"WEATHER":           8,
		"MAINTENANCE":       9,
		"CONSTRUCTION":      10,
		"POLICE_ACTIVITY":   11,
		"MEDICAL_EMERGENCY": 12,
	}
)

func (x Alert_Cause) Enum() *Alert_Cause {
	p := new(Alert_Cause)
	*p = x
	return p
}

func (x Alert_Cause) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Alert_Cause) Descriptor() protoreflect.EnumDescriptor {
	return file_gtfs_realtime_proto_enumTypes[5].Descriptor()
}

func (Alert_Cause) Type() protoreflect.EnumType {
	return &file_gtfs_realtime_proto_enumTypes[5]
}

func (x Alert_Cause) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Alert_Cause) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Alert_Cause(num)
	return nil
}

// Deprecated: Use Alert_Cause.Descriptor instead.
func (Alert_Cause) EnumDescriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{5, 0}
}

// What is the effect of this problem on the affected entity. If effect_detail is included, then Effect must also be included.
type Alert_Effect int32

const (
	Alert_NO_SERVICE      Alert_Effect = 1
	Alert_REDUCED_SERVICE Alert_Effect = 2
	// We don't care about INsignificant delays: they are hard to detect, have
	// little impact on the user, and would clutter the results as they are too
	// frequent.
	Alert_SIGNIFICANT_DELAYS  Alert_Effect = 3
	Alert_DETOUR              Alert_Effect = 4
	Alert_ADDITIONAL_SERVICE  Alert_Effect = 5
	Alert_MODIFIED_SERVICE    Alert_Effect = 6
	Alert_OTHER_EFFECT        Alert_Effect = 7
	Alert_UNKNOWN_EFFECT      Alert_Effect = 8
	Alert_STOP_MOVED          Alert_Effect = 9
	Alert_NO_EFFECT           Alert_Effect = 10
	Alert_ACCESSIBILITY_ISSUE Alert_Effect = 11
)

// Enum value maps for Alert_Effect.
var (
	Alert_Effect_name = map[int32]string{
		1:  "NO_SERVICE",
		2:  "REDUCED_SERVICE",
		3:  "SIGNIFICANT_DELAYS",
		4:  "DETOUR",
		5:  "ADDITIONAL_SERVICE",
		6:  "MODIFIED_SERVICE",
		7:  "OTHER_EFFECT",
		8:  "UNKNOWN_EFFECT",
		9:  "STOP_MOVED",
		10: "NO_EFFECT",
		11: "ACCESSIBILITY_ISSUE",
	}
	Alert_Effect_value = map[string]int32{
		"NO_SERVICE":          1,
		"REDUCED_SERVICE":     2,
		"SIGNIFICANT_DELAYS":  3,
		"DETOUR":              4,
		"ADDITIONAL_SERVICE":  5,
		"MODIFIED_SERVICE":    6,
		"OTHER_EFFECT":        7,
		"UNKNOWN_EFFECT":      8,
		"STOP_MOVED":          9,
		"NO_EFFECT":           10,
		"ACCESSIBILITY_ISSUE": 11,
	}
)

func (x Alert_Effect) Enum() *Alert_Effect {
	p := new(Alert_Effect)
	*p = x
	return p
}

func (x Alert_Effect) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Alert_Effect) Descriptor() protoreflect.EnumDescriptor {
	return file_gtfs_realtime_proto_enumTypes[6].Descriptor()
}

func (Alert_Effect) Type() protoreflect.EnumType {
	return &file_gtfs_realtime_proto_enumTypes[6]
}

func (x Alert_Effect) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Alert_Effect) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Alert_Effect(num)
	return nil
}

// Deprecated: Use Alert_Effect.Descriptor instead.
func (Alert_Effect) EnumDescriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{5, 1}
}

// Severity of this alert.
type Alert_SeverityLevel int32

const (
	Alert_UNKNOWN_SEVERITY Alert_SeverityLevel = 1
	Alert_INFO             Alert_SeverityLevel = 2
	Alert_WARNING          Alert_SeverityLevel = 3
	Alert_SEVERE           Alert_SeverityLevel = 4
)

// Enum value maps for Alert_SeverityLevel.
var (
	Alert_SeverityLevel_name = map[int32]string{
		1: "UNKNOWN_SEVERITY",
		2: "INFO",
		3: "WARNING",
		4: "SEVERE",
	}
	Alert_SeverityLevel_value = map[string]int32{
		"UNKNOWN_SEVERITY": 1,
		"INFO":             2,
		"WARNING":          3,
		"SEVERE":           4,
	}
)

func (x Alert_SeverityLevel) Enum() *Alert_SeverityLevel {
	p := new(Alert_SeverityLevel)
	*p = x
	return p
}

func (x Alert_SeverityLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Alert_SeverityLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_gtfs_realtime_proto_enumTypes[7].Descriptor()
}

func (Alert_SeverityLevel) Type() protoreflect.EnumType {
	return &file_gtfs_realtime_proto_enumTypes[7]
}

func (x Alert_SeverityLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Alert_SeverityLevel) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Alert_SeverityLevel(num)
	return nil
}

// Deprecated: Use Alert_SeverityLevel.Descriptor instead.
func (Alert_SeverityLevel) EnumDescriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{5, 2}
}

// The relation between this trip and the static schedule. If a trip is done
// in accordance with temporary schedule, not reflected in GTFS, then it
// shouldn't be marked as SCHEDULED, but likely as ADDED.
type TripDescriptor_ScheduleRelationship int32

const (
	// Trip that is running in accordance with its GTFS schedule, or is close
	// enough to the scheduled trip to be associated with it.
	TripDescriptor_SCHEDULED TripDescriptor_ScheduleRelationship = 0
	// An extra trip that was added in addition to a running schedule, for
	// example, to replace a broken vehicle or to respond to sudden passenger
	// load.
	// NOTE: Currently, behavior is unspecified for feeds that use this mode. There are discussions on the GTFS GitHub
	// [(1)](https://github.com/google/transit/issues/106) [(2)](https://github.com/google/transit/pull/221)
	// [(3)](https://github.com/google/transit/pull/219) around fully specifying or deprecating ADDED trips and the
	// documentation will be updated when those discussions are finalized.
	TripDescriptor_ADDED TripDescriptor_ScheduleRelationship = 1
	// A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0).
	// Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED.
	TripDescriptor_UNSCHEDULED TripDescriptor_ScheduleRelationship = 2
	// A trip that existed in the schedule but was removed.
	TripDescriptor_CANCELED TripDescriptor_ScheduleRelationship = 3
	// Should not be used - for backwards-compatibility only.
	//
	// Deprecated: Marked as deprecated in gtfs-realtime.proto.
	TripDescriptor_REPLACEMENT TripDescriptor_ScheduleRelationship = 5
	// An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to
	// respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date,
	// and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service
	// date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS
	// (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is
	// identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by
	// TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate
	// TripUpdate with the value of CANCELED or DELETED. Trips defined in GTFS frequencies.txt with exact_times that is
	// empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain
	// the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship
	// must also be set to DUPLICATED.
	// Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow
	// the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)
	// to transition to the DUPLICATED enumeration.
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	TripDescriptor_DUPLICATED TripDescriptor_ScheduleRelationship = 6
	// A trip that existed in the schedule but was removed and must not be shown to users.
	// DELETED should be used instead of CANCELED to indicate that a transit provider would like to entirely remove
	// information about the corresponding trip from consuming applications, so the trip is not shown as cancelled to
	// riders, e.g. a trip that is entirely being replaced by another trip.
	// This designation becomes particularly important if several trips are cancelled and replaced with substitute service.
	// If consumers were to show explicit information about the cancellations it would distract from the more important
	// real-time predictions.
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	TripDescriptor_DELETED TripDescriptor_ScheduleRelationship = 7
)

// Enum value maps for TripDescriptor_ScheduleRelationship.
var (
	TripDescriptor_ScheduleRelationship_name = map[int32]string{
		0: "SCHEDULED",
		1: "ADDED",
		2: "UNSCHEDULED",
		3: "CANCELED",
		5: "REPLACEMENT",
		6: "DUPLICATED",
		7: "DELETED",
	}
	TripDescriptor_ScheduleRelationship_value = map[string]int32{
		"SCHEDULED":   0,
		"ADDED":       1,
		"UNSCHEDULED": 2,
		"CANCELED":    3,
		"REPLACEMENT": 5,
		"DUPLICATED":  6,
		"DELETED":     7,
	}
)

func (x TripDescriptor_ScheduleRelationship) Enum() *TripDescriptor_ScheduleRelationship {
	p := new(TripDescriptor_ScheduleRelationship)
	*p = x
	return p
}

func (x TripDescriptor_ScheduleRelationship) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TripDescriptor_ScheduleRelationship) Descriptor() protoreflect.EnumDescriptor {
	return file_gtfs_realtime_proto_enumTypes[8].Descriptor()
}

func (TripDescriptor_ScheduleRelationship) Type() protoreflect.EnumType {
	return &file_gtfs_realtime_proto_enumTypes[8]
}

func (x TripDescriptor_ScheduleRelationship) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *TripDescriptor_ScheduleRelationship) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = TripDescriptor_ScheduleRelationship(num)
	return nil
}

// Deprecated: Use TripDescriptor_ScheduleRelationship.Descriptor instead.
func (TripDescriptor_ScheduleRelationship) EnumDescriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{8, 0}
}

type VehicleDescriptor_WheelchairAccessible int32

const (
	// The trip doesn't have information about wheelchair accessibility.
	// This is the **default** behavior. If the static GTFS contains a
	// _wheelchair_accessible_ value, it won't be overwritten.
	VehicleDescriptor_NO_VALUE VehicleDescriptor_WheelchairAccessible = 0
	// The trip has no accessibility value present.
	// This value will overwrite the value from the GTFS.
	VehicleDescriptor_UNKNOWN VehicleDescriptor_WheelchairAccessible = 1
	// The trip is wheelchair accessible.
	// This value will overwrite the value from the GTFS.
	VehicleDescriptor_WHEELCHAIR_ACCESSIBLE VehicleDescriptor_WheelchairAccessible = 2
	// The trip is **not** wheelchair accessible.
	// This value will overwrite the value from the GTFS.
	VehicleDescriptor_WHEELCHAIR_INACCESSIBLE VehicleDescriptor_WheelchairAccessible = 3
)

// Enum value maps for VehicleDescriptor_WheelchairAccessible.
var (
	VehicleDescriptor_WheelchairAccessible_name = map[int32]string{
		0: "NO_VALUE",
		1: "UNKNOWN",
		2: "WHEELCHAIR_ACCESSIBLE",
		3: "WHEELCHAIR_INACCESSIBLE",
	}
	VehicleDescriptor_WheelchairAccessible_value = map[string]int32{
		"NO_VALUE":                0,
		"UNKNOWN":                 1,
		"WHEELCHAIR_ACCESSIBLE":   2,
		"WHEELCHAIR_INACCESSIBLE": 3,
	}
)

func (x VehicleDescriptor_WheelchairAccessible) Enum() *VehicleDescriptor_WheelchairAccessible {
	p := new(VehicleDescriptor_WheelchairAccessible)
	*p = x
	return p
}

func (x VehicleDescriptor_WheelchairAccessible) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VehicleDescriptor_WheelchairAccessible) Descriptor() protoreflect.EnumDescriptor {
	return file_gtfs_realtime_proto_enumTypes[9].Descriptor()
}

func (VehicleDescriptor_WheelchairAccessible) Type() protoreflect.EnumType {
	return &file_gtfs_realtime_proto_enumTypes[9]
}

func (x VehicleDescriptor_WheelchairAccessible) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *VehicleDescriptor_WheelchairAccessible) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = VehicleDescriptor_WheelchairAccessible(num)
	return nil
}

// Deprecated: Use VehicleDescriptor_WheelchairAccessible.Descriptor instead.
func (VehicleDescriptor_WheelchairAccessible) EnumDescriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{9, 0}
}

type Stop_WheelchairBoarding int32

const (
	Stop_UNKNOWN       Stop_WheelchairBoarding = 0
	Stop_AVAILABLE     Stop_WheelchairBoarding = 1
	Stop_NOT_AVAILABLE Stop_WheelchairBoarding = 2
)

// Enum value maps for Stop_WheelchairBoarding.
var (
	Stop_WheelchairBoarding_name = map[int32]string{
		0: "UNKNOWN",
		1: "AVAILABLE",
		2: "NOT_AVAILABLE",
	}
	Stop_WheelchairBoarding_value = map[string]int32{
		"UNKNOWN":       0,
		"AVAILABLE":     1,
		"NOT_AVAILABLE": 2,
	}
)

func (x Stop_WheelchairBoarding) Enum() *Stop_WheelchairBoarding {
	p := new(Stop_WheelchairBoarding)
	*p = x
	return p
}

func (x Stop_WheelchairBoarding) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Stop_WheelchairBoarding) Descriptor() protoreflect.EnumDescriptor {
	return file_gtfs_realtime_proto_enumTypes[10].Descriptor()
}

func (Stop_WheelchairBoarding) Type() protoreflect.EnumType {
	return &file_gtfs_realtime_proto_enumTypes[10]
}

func (x Stop_WheelchairBoarding) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Stop_WheelchairBoarding) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Stop_WheelchairBoarding(num)
	return nil
}

// Deprecated: Use Stop_WheelchairBoarding.Descriptor instead.
func (Stop_WheelchairBoarding) EnumDescriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{14, 0}
}

// The contents of a feed message.
// A feed is a continuous stream of feed messages. Each message in the stream is
// obtained as a response to an appropriate HTTP GET request.
// A realtime feed is always defined with relation to an existing GTFS feed.
// All the entity ids are resolved with respect to the GTFS feed.
// Note that "required" and "optional" as stated in this file refer to Protocol
// Buffer cardinality, not semantic cardinality.  See reference.md at
// https://github.com/google/transit/tree/master/gtfs-realtime for field
// semantic cardinality.
type FeedMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Metadata about this feed and feed message.
	Header *FeedHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	// Contents of the feed.
	Entity          []*FeedEntity `protobuf:"bytes,2,rep,name=entity" json:"entity,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *FeedMessage) Reset() {
	*x = FeedMessage{}
	mi := &file_gtfs_realtime_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeedMessage) ProtoMessage() {}

func (x *FeedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeedMessage.ProtoReflect.Descriptor instead.
func (*FeedMessage) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{0}
}

func (x *FeedMessage) GetHeader() *FeedHeader {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *FeedMessage) GetEntity() []*FeedEntity {
	if x != nil {
		return x.Entity
	}
	return nil
}

// Metadata about a feed, included in feed messages.
type FeedHeader struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version of the feed specification.
	// The current version is 2.0.  Valid versions are "2.0", "1.0".
	GtfsRealtimeVersion *string                    `protobuf:"bytes,1,req,name=gtfs_realtime_version,json=gtfsRealtimeVersion" json:"gtfs_realtime_version,omitempty"`
	Incrementality      *FeedHeader_Incrementality `protobuf:"varint,2,opt,name=incrementality,enum=transit_realtime.FeedHeader_Incrementality,def=0" json:"incrementality,omitempty"`
	// This timestamp identifies the moment when the content of this feed has been
	// created (in server time). In POSIX time (i.e., number of seconds since
	// January 1st 1970 00:00:00 UTC).
	Timestamp *uint64 `protobuf:"varint,3,opt,name=timestamp" json:"timestamp,omitempty"`
	// String that matches the feed_info.feed_version from the GTFS feed that the real
	// time data is based on. Consumers can use this to identify which GTFS feed is
	// currently active or when a new one is available to download.
	FeedVersion     *string `protobuf:"bytes,4,opt,name=feed_version,json=feedVersion" json:"feed_version,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

// Default values for FeedHeader fields.
const (
	Default_FeedHeader_Incrementality = FeedHeader_FULL_DATASET
)

func (x *FeedHeader) Reset() {
	*x = FeedHeader{}
	mi := &file_gtfs_realtime_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeedHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeedHeader) ProtoMessage() {}

func (x *FeedHeader) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeedHeader.ProtoReflect.Descriptor instead.
func (*FeedHeader) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{1}
}

func (x *FeedHeader) GetGtfsRealtimeVersion() string {
	if x != nil && x.GtfsRealtimeVersion != nil {
		return *x.GtfsRealtimeVersion
	}
	return ""
}

func (x *FeedHeader) GetIncrementality() FeedHeader_Incrementality {
	if x != nil && x.Incrementality != nil {
		return *x.Incrementality
	}
	return Default_FeedHeader_Incrementality
}

func (x *FeedHeader) GetTimestamp() uint64 {
	if x != nil && x.Timestamp != nil {
		return *x.Timestamp
	}
	return 0
}

func (x *FeedHeader) GetFeedVersion() string {
	if x != nil && x.FeedVersion != nil {
		return *x.FeedVersion
	}
	return ""
}

// A definition (or update) of an entity in the transit feed.
type FeedEntity struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ids are used only to provide incrementality support. The id should be
	// unique within a FeedMessage. Consequent FeedMessages may contain
	// FeedEntities with the same id. In case of a DIFFERENTIAL update the new
	// FeedEntity with some id will replace the old FeedEntity with the same id
	// (or delete it - see is_deleted below).
	// The actual GTFS entities (e.g. stations, routes, trips) referenced by the
	// feed must be specified by explicit selectors (see EntitySelector below for
	// more info).
	Id *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	// Whether this entity is to be deleted. Relevant only for incremental
	// fetches.
	IsDeleted *bool `protobuf:"varint,2,opt,name=is_deleted,json=isDeleted,def=0" json:"is_deleted,omitempty"`
	// Data about the entity itself. Exactly one of the following fields must be
	// present (unless the entity is being deleted).
	TripUpdate *TripUpdate      `protobuf:"bytes,3,opt,name=trip_update,json=tripUpdate" json:"trip_update,omitempty"`
	Vehicle    *VehiclePosition `protobuf:"bytes,4,opt,name=vehicle" json:"vehicle,omitempty"`
	Alert      *Alert           `protobuf:"bytes,5,opt,name=alert" json:"alert,omitempty"`
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	Shape             *Shape             `protobuf:"bytes,6,opt,name=shape" json:"shape,omitempty"`
	Stop              *Stop              `protobuf:"bytes,7,opt,name=stop" json:"stop,omitempty"`
	TripModifications *TripModifications `protobuf:"bytes,8,opt,name=trip_modifications,json=tripModifications" json:"trip_modifications,omitempty"`
	extensionFields   protoimpl.ExtensionFields
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

// Default values for FeedEntity fields.
const (
	Default_FeedEntity_IsDeleted = bool(false)
)

func (x *FeedEntity) Reset() {
	*x = FeedEntity{}
	mi := &file_gtfs_realtime_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeedEntity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeedEntity) ProtoMessage() {}

func (x *FeedEntity) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeedEntity.ProtoReflect.Descriptor instead.
func (*FeedEntity) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{2}
}

func (x *FeedEntity) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *FeedEntity) GetIsDeleted() bool {
	if x != nil && x.IsDeleted != nil {
		return *x.IsDeleted
	}
	return Default_FeedEntity_IsDeleted
}

func (x *FeedEntity) GetTripUpdate() *TripUpdate {
	if x != nil {
		return x.TripUpdate
	}
	return nil
}

func (x *FeedEntity) GetVehicle() *VehiclePosition {
	if x != nil {
		return x.Vehicle
	}
	return nil
}

func (x *FeedEntity) GetAlert() *Alert {
	if x != nil {
		return x.Alert
	}
	return nil
}

func (x *FeedEntity) GetShape() *Shape {
	if x != nil {
		return x.Shape
	}
	return nil
}

func (x *FeedEntity) GetStop() *Stop {
	if x != nil {
		return x.Stop
	}
	return nil
}

func (x *FeedEntity) GetTripModifications() *TripModifications {
	if x != nil {
		return x.TripModifications
	}
	return nil
}

// Realtime update of the progress of a vehicle along a trip.
// Depending on the value of ScheduleRelationship, a TripUpdate can specify:
// - A trip that proceeds along the schedule.
// - A trip that proceeds along a route but has no fixed schedule.
// - A trip that have been added or removed with regard to schedule.
//
// The updates can be for future, predicted arrival/departure events, or for
// past events that already occurred.
// Normally, updates should get more precise and more certain (see
// uncertainty below) as the events gets closer to current time.
// Even if that is not possible, the information for past events should be
// precise and certain. In particular, if an update points to time in the past
// but its update's uncertainty is not 0, the client should conclude that the
// update is a (wrong) prediction and that the trip has not completed yet.
//
// Note that the update can describe a trip that is already completed.
// To this end, it is enough to provide an update for the last stop of the trip.
// If the time of that is in the past, the client will conclude from that that
// the whole trip is in the past (it is possible, although inconsequential, to
// also provide updates for preceding stops).
// This option is most relevant for a trip that has completed ahead of schedule,
// but according to the schedule, the trip is still proceeding at the current
// time. Removing the updates for this trip could make the client assume
// that the trip is still proceeding.
// Note that the feed provider is allowed, but not required, to purge past
// updates - this is one case where this would be practically useful.
type TripUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Trip that this message applies to. There can be at most one
	// TripUpdate entity for each actual trip instance.
	// If there is none, that means there is no prediction information available.
	// It does *not* mean that the trip is progressing according to schedule.
	Trip *TripDescriptor `protobuf:"bytes,1,req,name=trip" json:"trip,omitempty"`
	// Additional information on the vehicle that is serving this trip.
	Vehicle *VehicleDescriptor `protobuf:"bytes,3,opt,name=vehicle" json:"vehicle,omitempty"`
	// Updates to StopTimes for the trip (both future, i.e., predictions, and in
	// some cases, past ones, i.e., those that already happened).
	// The updates must be sorted by stop_sequence, and apply for all the
	// following stops of the trip up to the next specified one.
	//
	// Example 1:
	// For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
	// delay of 0 for stop_sequence of the current stop means that the trip is
	// exactly on time.
	//
	// Example 2:
	// For the same trip instance, 3 StopTimeUpdates are provided:
	// - delay of 5 min for stop_sequence 3
	// - delay of 1 min for stop_sequence 8
	// - delay of unspecified duration for stop_sequence 10
	// This will be interpreted as:
	// - stop_sequences 3,4,5,6,7 have delay of 5 min.
	// - stop_sequences 8,9 have delay of 1 min.
	// - stop_sequences 10,... have unknown delay.
	StopTimeUpdate []*TripUpdate_StopTimeUpdate `protobuf:"bytes,2,rep,name=stop_time_update,json=stopTimeUpdate" json:"stop_time_update,omitempty"`
	// The most recent moment at which the vehicle's real-time progress was measured
	// to estimate StopTimes in the future. When StopTimes in the past are provided,
	// arrival/departure times may be earlier than this value. In POSIX
	// time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
	Timestamp *uint64 `protobuf:"varint,4,opt,name=timestamp" json:"timestamp,omitempty"`
	// The current schedule deviation for the trip.  Delay should only be
	// specified when the prediction is given relative to some existing schedule
	// in GTFS.
	//
	// Delay (in seconds) can be positive (meaning that the vehicle is late) or
	// negative (meaning that the vehicle is ahead of schedule). Delay of 0
	// means that the vehicle is exactly on time.
	//
	// Delay information in StopTimeUpdates take precedent of trip-level delay
	// information, such that trip-level delay is only propagated until the next
	// stop along the trip with a StopTimeUpdate delay value specified.
	//
	// Feed providers are strongly encouraged to provide a TripUpdate.timestamp
	// value indicating when the delay value was last updated, in order to
	// evaluate the freshness of the data.
	//
	// NOTE: This field is still experimental, and subject to change. It may be
	// formally adopted in the future.
	Delay           *int32                     `protobuf:"varint,5,opt,name=delay" json:"delay,omitempty"`
	TripProperties  *TripUpdate_TripProperties `protobuf:"bytes,6,opt,name=trip_properties,json=tripProperties" json:"trip_properties,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TripUpdate) Reset() {
	*x = TripUpdate{}
	mi := &file_gtfs_realtime_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripUpdate) ProtoMessage() {}

func (x *TripUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripUpdate.ProtoReflect.Descriptor instead.
func (*TripUpdate) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{3}
}

func (x *TripUpdate) GetTrip() *TripDescriptor {
	if x != nil {
		return x.Trip
	}
	return nil
}

func (x *TripUpdate) GetVehicle() *VehicleDescriptor {
	if x != nil {
		return x.Vehicle
	}
	return nil
}

func (x *TripUpdate) GetStopTimeUpdate() []*TripUpdate_StopTimeUpdate {
	if x != nil {
		return x.StopTimeUpdate
	}
	return nil
}

func (x *TripUpdate) GetTimestamp() uint64 {
	if x != nil && x.Timestamp != nil {
		return *x.Timestamp
	}
	return 0
}

func (x *TripUpdate) GetDelay() int32 {
	if x != nil && x.Delay != nil {
		return *x.Delay
	}
	return 0
}

func (x *TripUpdate) GetTripProperties() *TripUpdate_TripProperties {
	if x != nil {
		return x.TripProperties
	}
	return nil
}

// Realtime positioning information for a given vehicle.
type VehiclePosition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Trip that this vehicle is serving.
	// Can be empty or partial if the vehicle can not be identified with a given
	// trip instance.
	Trip *TripDescriptor `protobuf:"bytes,1,opt,name=trip" json:"trip,omitempty"`
	// Additional information on the vehicle that is serving this trip.
	Vehicle *VehicleDescriptor `protobuf:"bytes,8,opt,name=vehicle" json:"vehicle,omitempty"`
	// Current position of this vehicle.
	Position *Position `protobuf:"bytes,2,opt,name=position" json:"position,omitempty"`
	// The stop sequence index of the current stop. The meaning of
	// current_stop_sequence (i.e., the stop that it refers to) is determined by
	// current_status.
	// If current_status is missing IN_TRANSIT_TO is assumed.
	CurrentStopSequence *uint32 `protobuf:"varint,3,opt,name=current_stop_sequence,json=currentStopSequence" json:"current_stop_sequence,omitempty"`
	// Identifies the current stop. The value must be the same as in stops.txt in
	// the corresponding GTFS feed.
	StopId *string `protobuf:"bytes,7,opt,name=stop_id,json=stopId" json:"stop_id,omitempty"`
	// The exact status of the vehicle with respect to the current stop.
	// Ignored if current_stop_sequence is missing.
	CurrentStatus *VehiclePosition_VehicleStopStatus `protobuf:"varint,4,opt,name=current_status,json=currentStatus,enum=transit_realtime.VehiclePosition_VehicleStopStatus,def=2" json:"current_status,omitempty"`
	// Moment at which the vehicle's position was measured. In POSIX time
	// (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
	Timestamp       *uint64                          `protobuf:"varint,5,opt,name=timestamp" json:"timestamp,omitempty"`
	CongestionLevel *VehiclePosition_CongestionLevel `protobuf:"varint,6,opt,name=congestion_level,json=congestionLevel,enum=transit_realtime.VehiclePosition_CongestionLevel" json:"congestion_level,omitempty"`
	// If multi_carriage_status is populated with per-carriage OccupancyStatus,
	// then this field should describe the entire vehicle with all carriages accepting passengers considered.
	OccupancyStatus *VehiclePosition_OccupancyStatus `protobuf:"varint,9,opt,name=occupancy_status,json=occupancyStatus,enum=transit_realtime.VehiclePosition_OccupancyStatus" json:"occupancy_status,omitempty"`
	// A percentage value indicating the degree of passenger occupancy in the vehicle.
	// The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
	// The value 100 should represent the total maximum occupancy the vehicle was designed for,
	// including both seated and standing capacity, and current operating regulations allow.
	// The value may exceed 100 if there are more passengers than the maximum designed capacity.
	// The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
	// If multi_carriage_status is populated with per-carriage occupancy_percentage,
	// then this field should describe the entire vehicle with all carriages accepting passengers considered.
	// This field is still experimental, and subject to change. It may be formally adopted in the future.
	OccupancyPercentage *uint32 `protobuf:"varint,10,opt,name=occupancy_percentage,json=occupancyPercentage" json:"occupancy_percentage,omitempty"`
	// Details of the multiple carriages of this given vehicle.
	// The first occurrence represents the first carriage of the vehicle,
	// given the current direction of travel.
	// The number of occurrences of the multi_carriage_details
	// field represents the number of carriages of the vehicle.
	// It also includes non boardable carriages,
	// like engines, maintenance carriages, etcâ€¦ as they provide valuable
	// information to passengers about where to stand on a platform.
	// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
	MultiCarriageDetails []*VehiclePosition_CarriageDetails `protobuf:"bytes,11,rep,name=multi_carriage_details,json=multiCarriageDetails" json:"multi_carriage_details,omitempty"`
	extensionFields      protoimpl.ExtensionFields
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

// Default values for VehiclePosition fields.
const (
	Default_VehiclePosition_CurrentStatus = VehiclePosition_IN_TRANSIT_TO
)

func (x *VehiclePosition) Reset() {
	*x = VehiclePosition{}
	mi := &file_gtfs_realtime_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VehiclePosition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VehiclePosition) ProtoMessage() {}

func (x *VehiclePosition) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VehiclePosition.ProtoReflect.Descriptor instead.
func (*VehiclePosition) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{4}
}

func (x *VehiclePosition) GetTrip() *TripDescriptor {
	if x != nil {
		return x.Trip
	}
	return nil
}

func (x *VehiclePosition) GetVehicle() *VehicleDescriptor {
	if x != nil {
		return x.Vehicle
	}
	return nil
}

func (x *VehiclePosition) GetPosition() *Position {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *VehiclePosition) GetCurrentStopSequence() uint32 {
	if x != nil && x.CurrentStopSequence != nil {
		return *x.CurrentStopSequence
	}
	return 0
}

func (x *VehiclePosition) GetStopId() string {
	if x != nil && x.StopId != nil {
		return *x.StopId
	}
	return ""
}

func (x *VehiclePosition) GetCurrentStatus() VehiclePosition_VehicleStopStatus {
	if x != nil && x.CurrentStatus != nil {
		return *x.CurrentStatus
	}
	return Default_VehiclePosition_CurrentStatus
}

func (x *VehiclePosition) GetTimestamp() uint64 {
	if x != nil && x.Timestamp != nil {
		return *x.Timestamp
	}
	return 0
}

func (x *VehiclePosition) GetCongestionLevel() VehiclePosition_CongestionLevel {
	if x != nil && x.CongestionLevel != nil {
		return *x.CongestionLevel
	}
	return VehiclePosition_UNKNOWN_CONGESTION_LEVEL
}

func (x *VehiclePosition) GetOccupancyStatus() VehiclePosition_OccupancyStatus {
	if x != nil && x.OccupancyStatus != nil {
		return *x.OccupancyStatus
	}
	return VehiclePosition_EMPTY
}

func (x *VehiclePosition) GetOccupancyPercentage() uint32 {
	if x != nil && x.OccupancyPercentage != nil {
		return *x.OccupancyPercentage
	}
	return 0
}

func (x *VehiclePosition) GetMultiCarriageDetails() []*VehiclePosition_CarriageDetails {
	if x != nil {
		return x.MultiCarriageDetails
	}
	return nil
}

// An alert, indicating some sort of incident in the public transit network.
type Alert struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Time when the alert should be shown to the user. If missing, the
	// alert will be shown as long as it appears in the feed.
	// If multiple ranges are given, the alert will be shown during all of them.
	ActivePeriod []*TimeRange `protobuf:"bytes,1,rep,name=active_period,json=activePeriod" json:"active_period,omitempty"`
	// Entities whose users we should notify of this alert.
	InformedEntity []*EntitySelector `protobuf:"bytes,5,rep,name=informed_entity,json=informedEntity" json:"informed_entity,omitempty"`
	Cause          *Alert_Cause      `protobuf:"varint,6,opt,name=cause,enum=transit_realtime.Alert_Cause,def=1" json:"cause,omitempty"`
	Effect         *Alert_Effect     `protobuf:"varint,7,opt,name=effect,enum=transit_realtime.Alert_Effect,def=8" json:"effect,omitempty"`
	// The URL which provides additional information about the alert.
	Url *TranslatedString `protobuf:"bytes,8,opt,name=url" json:"url,omitempty"`
	// Alert header. Contains a short summary of the alert text as plain-text.
	HeaderText *TranslatedString `protobuf:"bytes,10,opt,name=header_text,json=headerText" json:"header_text,omitempty"`
	// Full description for the alert as plain-text. The information in the
	// description should add to the information of the header.
	DescriptionText *TranslatedString `protobuf:"bytes,11,opt,name=description_text,json=descriptionText" json:"description_text,omitempty"`
	// Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
	TtsHeaderText *TranslatedString `protobuf:"bytes,12,opt,name=tts_header_text,json=ttsHeaderText" json:"tts_header_text,omitempty"`
	// Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
	TtsDescriptionText *TranslatedString    `protobuf:"bytes,13,opt,name=tts_description_text,json=ttsDescriptionText" json:"tts_description_text,omitempty"`
	SeverityLevel      *Alert_SeverityLevel `protobuf:"varint,14,opt,name=severity_level,json=severityLevel,enum=transit_realtime.Alert_SeverityLevel,def=1" json:"severity_level,omitempty"`
	// TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
	// The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information.
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	Image *TranslatedImage `protobuf:"bytes,15,opt,name=image" json:"image,omitempty"`
	// Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
	// or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	ImageAlternativeText *TranslatedString `protobuf:"bytes,16,opt,name=image_alternative_text,json=imageAlternativeText" json:"image_alternative_text,omitempty"`
	// Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	CauseDetail *TranslatedString `protobuf:"bytes,17,opt,name=cause_detail,json=causeDetail" json:"cause_detail,omitempty"`
	// Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	EffectDetail    *TranslatedString `protobuf:"bytes,18,opt,name=effect_detail,json=effectDetail" json:"effect_detail,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

// Default values for Alert fields.
const (
	Default_Alert_Cause         = Alert_UNKNOWN_CAUSE
	Default_Alert_Effect        = Alert_UNKNOWN_EFFECT
	Default_Alert_SeverityLevel = Alert_UNKNOWN_SEVERITY
)

func (x *Alert) Reset() {
	*x = Alert{}
	mi := &file_gtfs_realtime_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Alert) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Alert) ProtoMessage() {}

func (x *Alert) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Alert.ProtoReflect.Descriptor instead.
func (*Alert) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{5}
}

func (x *Alert) GetActivePeriod() []*TimeRange {
	if x != nil {
		return x.ActivePeriod
	}
	return nil
}

func (x *Alert) GetInformedEntity() []*EntitySelector {
	if x != nil {
		return x.InformedEntity
	}
	return nil
}

func (x *Alert) GetCause() Alert_Cause {
	if x != nil && x.Cause != nil {
		return *x.Cause
	}
	return Default_Alert_Cause
}

func (x *Alert) GetEffect() Alert_Effect {
	if x != nil && x.Effect != nil {
		return *x.Effect
	}
	return Default_Alert_Effect
}

func (x *Alert) GetUrl() *TranslatedString {
	if x != nil {
		return x.Url
	}
	return nil
}

func (x *Alert) GetHeaderText() *TranslatedString {
	if x != nil {
		return x.HeaderText
	}
	return nil
}

func (x *Alert) GetDescriptionText() *TranslatedString {
	if x != nil {
		return x.DescriptionText
	}
	return nil
}

func (x *Alert) GetTtsHeaderText() *TranslatedString {
	if x != nil {
		return x.TtsHeaderText
	}
	return nil
}

func (x *Alert) GetTtsDescriptionText() *TranslatedString {
	if x != nil {
		return x.TtsDescriptionText
	}
	return nil
}

func (x *Alert) GetSeverityLevel() Alert_SeverityLevel {
	if x != nil && x.SeverityLevel != nil {
		return *x.SeverityLevel
	}
	return Default_Alert_SeverityLevel
}

func (x *Alert) GetImage() *TranslatedImage {
	if x != nil {
		return x.Image
	}
	return nil
}

func (x *Alert) GetImageAlternativeText() *TranslatedString {
	if x != nil {
		return x.ImageAlternativeText
	}
	return nil
}

func (x *Alert) GetCauseDetail() *TranslatedString {
	if x != nil {
		return x.CauseDetail
	}
	return nil
}

func (x *Alert) GetEffectDetail() *TranslatedString {
	if x != nil {
		return x.EffectDetail
	}
	return nil
}

// A time interval. The interval is considered active at time 't' if 't' is
// greater than or equal to the start time and less than the end time.
type TimeRange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Start time, in POSIX time (i.e., number of seconds since January 1st 1970
	// 00:00:00 UTC).
	// If missing, the interval starts at minus infinity.
	Start *uint64 `protobuf:"varint,1,opt,name=start" json:"start,omitempty"`
	// End time, in POSIX time (i.e., number of seconds since January 1st 1970
	// 00:00:00 UTC).
	// If missing, the interval ends at plus infinity.
	End             *uint64 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TimeRange) Reset() {
	*x = TimeRange{}
	mi := &file_gtfs_realtime_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimeRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeRange) ProtoMessage() {}

func (x *TimeRange) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimeRange.ProtoReflect.Descriptor instead.
func (*TimeRange) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{6}
}

func (x *TimeRange) GetStart() uint64 {
	if x != nil && x.Start != nil {
		return *x.Start
	}
	return 0
}

func (x *TimeRange) GetEnd() uint64 {
	if x != nil && x.End != nil {
		return *x.End
	}
	return 0
}

// A position.
type Position struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Degrees North, in the WGS-84 coordinate system.
	Latitude *float32 `protobuf:"fixed32,1,req,name=latitude" json:"latitude,omitempty"`
	// Degrees East, in the WGS-84 coordinate system.
	Longitude *float32 `protobuf:"fixed32,2,req,name=longitude" json:"longitude,omitempty"`
	// Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
	// This can be the compass bearing, or the direction towards the next stop
	// or intermediate location.
	// This should not be direction deduced from the sequence of previous
	// positions, which can be computed from previous data.
	Bearing *float32 `protobuf:"fixed32,3,opt,name=bearing" json:"bearing,omitempty"`
	// Odometer value, in meters.
	Odometer *float64 `protobuf:"fixed64,4,opt,name=odometer" json:"odometer,omitempty"`
	// Momentary speed measured by the vehicle, in meters per second.
	Speed           *float32 `protobuf:"fixed32,5,opt,name=speed" json:"speed,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Position) Reset() {
	*x = Position{}
	mi := &file_gtfs_realtime_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Position) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Position) ProtoMessage() {}

func (x *Position) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Position.ProtoReflect.Descriptor instead.
func (*Position) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{7}
}

func (x *Position) GetLatitude() float32 {
	if x != nil && x.Latitude != nil {
		return *x.Latitude
	}
	return 0
}

func (x *Position) GetLongitude() float32 {
	if x != nil && x.Longitude != nil {
		return *x.Longitude
	}
	return 0
}

func (x *Position) GetBearing() float32 {
	if x != nil && x.Bearing != nil {
		return *x.Bearing
	}
	return 0
}

func (x *Position) GetOdometer() float64 {
	if x != nil && x.Odometer != nil {
		return *x.Odometer
	}
	return 0
}

func (x *Position) GetSpeed() float32 {
	if x != nil && x.Speed != nil {
		return *x.Speed
	}
	return 0
}

// A descriptor that identifies an instance of a GTFS trip, or all instances of
// a trip along a route.
//   - To specify a single trip instance, the trip_id (and if necessary,
//     start_time) is set. If route_id is also set, then it should be same as one
//     that the given trip corresponds to.
//   - To specify all the trips along a given route, only the route_id should be
//     set. Note that if the trip_id is not known, then stop sequence ids in
//     TripUpdate are not sufficient, and stop_ids must be provided as well. In
//     addition, absolute arrival/departure times must be provided.
type TripDescriptor struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The trip_id from the GTFS feed that this selector refers to.
	// For non frequency-based trips, this field is enough to uniquely identify
	// the trip. For frequency-based trip, start_time and start_date might also be
	// necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
	// static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
	// identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
	TripId *string `protobuf:"bytes,1,opt,name=trip_id,json=tripId" json:"trip_id,omitempty"`
	// The route_id from the GTFS that this selector refers to.
	RouteId *string `protobuf:"bytes,5,opt,name=route_id,json=routeId" json:"route_id,omitempty"`
	// The direction_id from the GTFS feed trips.txt file, indicating the
	// direction of travel for trips this selector refers to.
	DirectionId *uint32 `protobuf:"varint,6,opt,name=direction_id,json=directionId" json:"direction_id,omitempty"`
	// The initially scheduled start time of this trip instance.
	// When the trip_id corresponds to a non-frequency-based trip, this field
	// should either be omitted or be equal to the value in the GTFS feed. When
	// the trip_id correponds to a frequency-based trip, the start_time must be
	// specified for trip updates and vehicle positions. If the trip corresponds
	// to exact_times=1 GTFS record, then start_time must be some multiple
	// (including zero) of headway_secs later than frequencies.txt start_time for
	// the corresponding time period. If the trip corresponds to exact_times=0,
	// then its start_time may be arbitrary, and is initially expected to be the
	// first departure of the trip. Once established, the start_time of this
	// frequency-based trip should be considered immutable, even if the first
	// departure time changes -- that time change may instead be reflected in a
	// StopTimeUpdate.
	// Format and semantics of the field is same as that of
	// GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
	StartTime *string `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// The scheduled start date of this trip instance.
	// Must be provided to disambiguate trips that are so late as to collide with
	// a scheduled trip on a next day. For example, for a train that departs 8:00
	// and 20:00 every day, and is 12 hours late, there would be two distinct
	// trips on the same time.
	// This field can be provided but is not mandatory for schedules in which such
	// collisions are impossible - for example, a service running on hourly
	// schedule where a vehicle that is one hour late is not considered to be
	// related to schedule anymore.
	// In YYYYMMDD format.
	StartDate            *string                              `protobuf:"bytes,3,opt,name=start_date,json=startDate" json:"start_date,omitempty"`
	ScheduleRelationship *TripDescriptor_ScheduleRelationship `protobuf:"varint,4,opt,name=schedule_relationship,json=scheduleRelationship,enum=transit_realtime.TripDescriptor_ScheduleRelationship" json:"schedule_relationship,omitempty"`
	// Linkage to any modifications done to this trip (shape changes, removal or addition of stops).
	// If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value.
	ModifiedTrip    *TripDescriptor_ModifiedTripSelector `protobuf:"bytes,7,opt,name=modified_trip,json=modifiedTrip" json:"modified_trip,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TripDescriptor) Reset() {
	*x = TripDescriptor{}
	mi := &file_gtfs_realtime_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripDescriptor) ProtoMessage() {}

func (x *TripDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripDescriptor.ProtoReflect.Descriptor instead.
func (*TripDescriptor) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{8}
}

func (x *TripDescriptor) GetTripId() string {
	if x != nil && x.TripId != nil {
		return *x.TripId
	}
	return ""
}

func (x *TripDescriptor) GetRouteId() string {
	if x != nil && x.RouteId != nil {
		return *x.RouteId
	}
	return ""
}

func (x *TripDescriptor) GetDirectionId() uint32 {
	if x != nil && x.DirectionId != nil {
		return *x.DirectionId
	}
	return 0
}

func (x *TripDescriptor) GetStartTime() string {
	if x != nil && x.StartTime != nil {
		return *x.StartTime
	}
	return ""
}

func (x *TripDescriptor) GetStartDate() string {
	if x != nil && x.StartDate != nil {
		return *x.StartDate
	}
	return ""
}

func (x *TripDescriptor) GetScheduleRelationship() TripDescriptor_ScheduleRelationship {
	if x != nil && x.ScheduleRelationship != nil {
		return *x.ScheduleRelationship
	}
	return TripDescriptor_SCHEDULED
}

func (x *TripDescriptor) GetModifiedTrip() *TripDescriptor_ModifiedTripSelector {
	if x != nil {
		return x.ModifiedTrip
	}
	return nil
}

// Identification information for the vehicle performing the trip.
type VehicleDescriptor struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Internal system identification of the vehicle. Should be unique per
	// vehicle, and can be used for tracking the vehicle as it proceeds through
	// the system.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// User visible label, i.e., something that must be shown to the passenger to
	// help identify the correct vehicle.
	Label *string `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	// The license plate of the vehicle.
	LicensePlate         *string                                 `protobuf:"bytes,3,opt,name=license_plate,json=licensePlate" json:"license_plate,omitempty"`
	WheelchairAccessible *VehicleDescriptor_WheelchairAccessible `protobuf:"varint,4,opt,name=wheelchair_accessible,json=wheelchairAccessible,enum=transit_realtime.VehicleDescriptor_WheelchairAccessible,def=0" json:"wheelchair_accessible,omitempty"`
	extensionFields      protoimpl.ExtensionFields
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

// Default values for VehicleDescriptor fields.
const (
	Default_VehicleDescriptor_WheelchairAccessible = VehicleDescriptor_NO_VALUE
)

func (x *VehicleDescriptor) Reset() {
	*x = VehicleDescriptor{}
	mi := &file_gtfs_realtime_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VehicleDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VehicleDescriptor) ProtoMessage() {}

func (x *VehicleDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VehicleDescriptor.ProtoReflect.Descriptor instead.
func (*VehicleDescriptor) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{9}
}

func (x *VehicleDescriptor) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *VehicleDescriptor) GetLabel() string {
	if x != nil && x.Label != nil {
		return *x.Label
	}
	return ""
}

func (x *VehicleDescriptor) GetLicensePlate() string {
	if x != nil && x.LicensePlate != nil {
		return *x.LicensePlate
	}
	return ""
}

func (x *VehicleDescriptor) GetWheelchairAccessible() VehicleDescriptor_WheelchairAccessible {
	if x != nil && x.WheelchairAccessible != nil {
		return *x.WheelchairAccessible
	}
	return Default_VehicleDescriptor_WheelchairAccessible
}

// A selector for an entity in a GTFS feed.
type EntitySelector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The values of the fields should correspond to the appropriate fields in the
	// GTFS feed.
	// At least one specifier must be given. If several are given, then the
	// matching has to apply to all the given specifiers.
	AgencyId *string `protobuf:"bytes,1,opt,name=agency_id,json=agencyId" json:"agency_id,omitempty"`
	RouteId  *string `protobuf:"bytes,2,opt,name=route_id,json=routeId" json:"route_id,omitempty"`
	// corresponds to route_type in GTFS.
	RouteType *int32          `protobuf:"varint,3,opt,name=route_type,json=routeType" json:"route_type,omitempty"`
	Trip      *TripDescriptor `protobuf:"bytes,4,opt,name=trip" json:"trip,omitempty"`
	StopId    *string         `protobuf:"bytes,5,opt,name=stop_id,json=stopId" json:"stop_id,omitempty"`
	// Corresponds to trip direction_id in GTFS trips.txt. If provided the
	// route_id must also be provided.
	DirectionId     *uint32 `protobuf:"varint,6,opt,name=direction_id,json=directionId" json:"direction_id,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *EntitySelector) Reset() {
	*x = EntitySelector{}
	mi := &file_gtfs_realtime_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EntitySelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EntitySelector) ProtoMessage() {}

func (x *EntitySelector) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EntitySelector.ProtoReflect.Descriptor instead.
func (*EntitySelector) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{10}
}

func (x *EntitySelector) GetAgencyId() string {
	if x != nil && x.AgencyId != nil {
		return *x.AgencyId
	}
	return ""
}

func (x *EntitySelector) GetRouteId() string {
	if x != nil && x.RouteId != nil {
		return *x.RouteId
	}
	return ""
}

func (x *EntitySelector) GetRouteType() int32 {
	if x != nil && x.RouteType != nil {
		return *x.RouteType
	}
	return 0
}

func (x *EntitySelector) GetTrip() *TripDescriptor {
	if x != nil {
		return x.Trip
	}
	return nil
}

func (x *EntitySelector) GetStopId() string {
	if x != nil && x.StopId != nil {
		return *x.StopId
	}
	return ""
}

func (x *EntitySelector) GetDirectionId() uint32 {
	if x != nil && x.DirectionId != nil {
		return *x.DirectionId
	}
	return 0
}

// An internationalized message containing per-language versions of a snippet of
// text or a URL.
// One of the strings from a message will be picked up. The resolution proceeds
// as follows:
//  1. If the UI language matches the language code of a translation,
//     the first matching translation is picked.
//  2. If a default UI language (e.g., English) matches the language code of a
//     translation, the first matching translation is picked.
//  3. If some translation has an unspecified language code, that translation is
//     picked.
type TranslatedString struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// At least one translation must be provided.
	Translation     []*TranslatedString_Translation `protobuf:"bytes,1,rep,name=translation" json:"translation,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TranslatedString) Reset() {
	*x = TranslatedString{}
	mi := &file_gtfs_realtime_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranslatedString) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranslatedString) ProtoMessage() {}

func (x *TranslatedString) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranslatedString.ProtoReflect.Descriptor instead.
func (*TranslatedString) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{11}
}

func (x *TranslatedString) GetTranslation() []*TranslatedString_Translation {
	if x != nil {
		return x.Translation
	}
	return nil
}

// An internationalized image containing per-language versions of a URL linking to an image
// along with meta information
// Only one of the images from a message will be retained by consumers. The resolution proceeds
// as follows:
//  1. If the UI language matches the language code of a translation,
//     the first matching translation is picked.
//  2. If a default UI language (e.g., English) matches the language code of a
//     translation, the first matching translation is picked.
//  3. If some translation has an unspecified language code, that translation is
//     picked.
//
// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
type TranslatedImage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// At least one localized image must be provided.
	LocalizedImage  []*TranslatedImage_LocalizedImage `protobuf:"bytes,1,rep,name=localized_image,json=localizedImage" json:"localized_image,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TranslatedImage) Reset() {
	*x = TranslatedImage{}
	mi := &file_gtfs_realtime_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranslatedImage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranslatedImage) ProtoMessage() {}

func (x *TranslatedImage) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranslatedImage.ProtoReflect.Descriptor instead.
func (*TranslatedImage) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{12}
}

func (x *TranslatedImage) GetLocalizedImage() []*TranslatedImage_LocalizedImage {
	if x != nil {
		return x.LocalizedImage
	}
	return nil
}

// Describes the physical path that a vehicle takes when it's not part of the (CSV) GTFS,
// such as for a detour. Shapes belong to Trips, and consist of a sequence of shape points.
// Tracing the points in order provides the path of the vehicle.  Shapes do not need to intercept
// the location of Stops exactly, but all Stops on a trip should lie within a small distance of
// the shape for that trip, i.e. close to straight line segments connecting the shape points
// NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
type Shape struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
	// This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
	// See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	ShapeId *string `protobuf:"bytes,1,opt,name=shape_id,json=shapeId" json:"shape_id,omitempty"`
	// Encoded polyline representation of the shape. This polyline must contain at least two points.
	// For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
	// This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
	// See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	EncodedPolyline *string `protobuf:"bytes,2,opt,name=encoded_polyline,json=encodedPolyline" json:"encoded_polyline,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Shape) Reset() {
	*x = Shape{}
	mi := &file_gtfs_realtime_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Shape) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Shape) ProtoMessage() {}

func (x *Shape) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Shape.ProtoReflect.Descriptor instead.
func (*Shape) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{13}
}

func (x *Shape) GetShapeId() string {
	if x != nil && x.ShapeId != nil {
		return *x.ShapeId
	}
	return ""
}

func (x *Shape) GetEncodedPolyline() string {
	if x != nil && x.EncodedPolyline != nil {
		return *x.EncodedPolyline
	}
	return ""
}

// Describes a stop which is served by trips. All fields are as described in the GTFS-Static specification.
// NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
type Stop struct {
	state              protoimpl.MessageState   `protogen:"open.v1"`
	StopId             *string                  `protobuf:"bytes,1,opt,name=stop_id,json=stopId" json:"stop_id,omitempty"`
	StopCode           *TranslatedString        `protobuf:"bytes,2,opt,name=stop_code,json=stopCode" json:"stop_code,omitempty"`
	StopName           *TranslatedString        `protobuf:"bytes,3,opt,name=stop_name,json=stopName" json:"stop_name,omitempty"`
	TtsStopName        *TranslatedString        `protobuf:"bytes,4,opt,name=tts_stop_name,json=ttsStopName" json:"tts_stop_name,omitempty"`
	StopDesc           *TranslatedString        `protobuf:"bytes,5,opt,name=stop_desc,json=stopDesc" json:"stop_desc,omitempty"`
	StopLat            *float32                 `protobuf:"fixed32,6,opt,name=stop_lat,json=stopLat" json:"stop_lat,omitempty"`
	StopLon            *float32                 `protobuf:"fixed32,7,opt,name=stop_lon,json=stopLon" json:"stop_lon,omitempty"`
	ZoneId             *string                  `protobuf:"bytes,8,opt,name=zone_id,json=zoneId" json:"zone_id,omitempty"`
	StopUrl            *TranslatedString        `protobuf:"bytes,9,opt,name=stop_url,json=stopUrl" json:"stop_url,omitempty"`
	ParentStation      *string                  `protobuf:"bytes,11,opt,name=parent_station,json=parentStation" json:"parent_station,omitempty"`
	StopTimezone       *string                  `protobuf:"bytes,12,opt,name=stop_timezone,json=stopTimezone" json:"stop_timezone,omitempty"`
	WheelchairBoarding *Stop_WheelchairBoarding `protobuf:"varint,13,opt,name=wheelchair_boarding,json=wheelchairBoarding,enum=transit_realtime.Stop_WheelchairBoarding,def=0" json:"wheelchair_boarding,omitempty"`
	LevelId            *string                  `protobuf:"bytes,14,opt,name=level_id,json=levelId" json:"level_id,omitempty"`
	PlatformCode       *TranslatedString        `protobuf:"bytes,15,opt,name=platform_code,json=platformCode" json:"platform_code,omitempty"`
	extensionFields    protoimpl.ExtensionFields
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

// Default values for Stop fields.
const (
	Default_Stop_WheelchairBoarding = Stop_UNKNOWN
)

func (x *Stop) Reset() {
	*x = Stop{}
	mi := &file_gtfs_realtime_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Stop) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Stop) ProtoMessage() {}

func (x *Stop) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Stop.ProtoReflect.Descriptor instead.
func (*Stop) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{14}
}

func (x *Stop) GetStopId() string {
	if x != nil && x.StopId != nil {
		return *x.StopId
	}
	return ""
}

func (x *Stop) GetStopCode() *TranslatedString {
	if x != nil {
		return x.StopCode
	}
	return nil
}

func (x *Stop) GetStopName() *TranslatedString {
	if x != nil {
		return x.StopName
	}
	return nil
}

func (x *Stop) GetTtsStopName() *TranslatedString {
	if x != nil {
		return x.TtsStopName
	}
	return nil
}

func (x *Stop) GetStopDesc() *TranslatedString {
	if x != nil {
		return x.StopDesc
	}
	return nil
}

func (x *Stop) GetStopLat() float32 {
	if x != nil && x.StopLat != nil {
		return *x.StopLat
	}
	return 0
}

func (x *Stop) GetStopLon() float32 {
	if x != nil && x.StopLon != nil {
		return *x.StopLon
	}
	return 0
}

func (x *Stop) GetZoneId() string {
	if x != nil && x.ZoneId != nil {
		return *x.ZoneId
	}
	return ""
}

func (x *Stop) GetStopUrl() *TranslatedString {
	if x != nil {
		return x.StopUrl
	}
	return nil
}

func (x *Stop) GetParentStation() string {
	if x != nil && x.ParentStation != nil {
		return *x.ParentStation
	}
	return ""
}

func (x *Stop) GetStopTimezone() string {
	if x != nil && x.StopTimezone != nil {
		return *x.StopTimezone
	}
	return ""
}

func (x *Stop) GetWheelchairBoarding() Stop_WheelchairBoarding {
	if x != nil && x.WheelchairBoarding != nil {
		return *x.WheelchairBoarding
	}
	return Default_Stop_WheelchairBoarding
}

func (x *Stop) GetLevelId() string {
	if x != nil && x.LevelId != nil {
		return *x.LevelId
	}
	return ""
}

func (x *Stop) GetPlatformCode() *TranslatedString {
	if x != nil {
		return x.PlatformCode
	}
	return nil
}

// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
type TripModifications struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of selected trips affected by this TripModifications.
	SelectedTrips []*TripModifications_SelectedTrips `protobuf:"bytes,1,rep,name=selected_trips,json=selectedTrips" json:"selected_trips,omitempty"`
	// A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids.
	// Useful to target multiple departures of a trip_id in a frequency-based trip.
	StartTimes []string `protobuf:"bytes,2,rep,name=start_times,json=startTimes" json:"start_times,omitempty"`
	// Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
	// The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
	ServiceDates []string `protobuf:"bytes,3,rep,name=service_dates,json=serviceDates" json:"service_dates,omitempty"`
	// A list of modifications to apply to the affected trips.
	Modifications   []*TripModifications_Modification `protobuf:"bytes,4,rep,name=modifications" json:"modifications,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TripModifications) Reset() {
	*x = TripModifications{}
	mi := &file_gtfs_realtime_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripModifications) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripModifications) ProtoMessage() {}

func (x *TripModifications) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripModifications.ProtoReflect.Descriptor instead.
func (*TripModifications) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{15}
}

func (x *TripModifications) GetSelectedTrips() []*TripModifications_SelectedTrips {
	if x != nil {
		return x.SelectedTrips
	}
	return nil
}

func (x *TripModifications) GetStartTimes() []string {
	if x != nil {
		return x.StartTimes
	}
	return nil
}

func (x *TripModifications) GetServiceDates() []string {
	if x != nil {
		return x.ServiceDates
	}
	return nil
}

func (x *TripModifications) GetModifications() []*TripModifications_Modification {
	if x != nil {
		return x.Modifications
	}
	return nil
}

// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
// Select a stop by stop sequence or by stop_id. At least one of the two values must be provided.
type StopSelector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Must be the same as in stop_times.txt in the corresponding GTFS feed.
	StopSequence *uint32 `protobuf:"varint,1,opt,name=stop_sequence,json=stopSequence" json:"stop_sequence,omitempty"`
	// Must be the same as in stops.txt in the corresponding GTFS feed.
	StopId          *string `protobuf:"bytes,2,opt,name=stop_id,json=stopId" json:"stop_id,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *StopSelector) Reset() {
	*x = StopSelector{}
	mi := &file_gtfs_realtime_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopSelector) ProtoMessage() {}

func (x *StopSelector) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopSelector.ProtoReflect.Descriptor instead.
func (*StopSelector) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{16}
}

func (x *StopSelector) GetStopSequence() uint32 {
	if x != nil && x.StopSequence != nil {
		return *x.StopSequence
	}
	return 0
}

func (x *StopSelector) GetStopId() string {
	if x != nil && x.StopId != nil {
		return *x.StopId
	}
	return ""
}

// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
type ReplacementStop struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
	// This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
	TravelTimeToStop *int32 `protobuf:"varint,1,opt,name=travel_time_to_stop,json=travelTimeToStop" json:"travel_time_to_stop,omitempty"`
	// The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT Stop message, or to an existing stop defined in the GTFS-Static feedâ€™s stops.txt. The stop MUST have location_type=0 (routable stops).
	StopId          *string `protobuf:"bytes,2,opt,name=stop_id,json=stopId" json:"stop_id,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ReplacementStop) Reset() {
	*x = ReplacementStop{}
	mi := &file_gtfs_realtime_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplacementStop) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplacementStop) ProtoMessage() {}

func (x *ReplacementStop) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplacementStop.ProtoReflect.Descriptor instead.
func (*ReplacementStop) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{17}
}

func (x *ReplacementStop) GetTravelTimeToStop() int32 {
	if x != nil && x.TravelTimeToStop != nil {
		return *x.TravelTimeToStop
	}
	return 0
}

func (x *ReplacementStop) GetStopId() string {
	if x != nil && x.StopId != nil {
		return *x.StopId
	}
	return ""
}

// Timing information for a single predicted event (either arrival or
// departure).
// Timing consists of delay and/or estimated time, and uncertainty.
//   - delay should be used when the prediction is given relative to some
//     existing schedule in GTFS.
//   - time should be given whether there is a predicted schedule or not. If
//     both time and delay are specified, time will take precedence
//     (although normally, time, if given for a scheduled trip, should be
//     equal to scheduled time in GTFS + delay).
//
// Uncertainty applies equally to both time and delay.
// The uncertainty roughly specifies the expected error in true delay (but
// note, we don't yet define its precise statistical meaning). It's possible
// for the uncertainty to be 0, for example for trains that are driven under
// computer timing control.
type TripUpdate_StopTimeEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Delay (in seconds) can be positive (meaning that the vehicle is late) or
	// negative (meaning that the vehicle is ahead of schedule). Delay of 0
	// means that the vehicle is exactly on time.
	Delay *int32 `protobuf:"varint,1,opt,name=delay" json:"delay,omitempty"`
	// Event as absolute time.
	// In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
	// UTC).
	Time *int64 `protobuf:"varint,2,opt,name=time" json:"time,omitempty"`
	// If uncertainty is omitted, it is interpreted as unknown.
	// If the prediction is unknown or too uncertain, the delay (or time) field
	// should be empty. In such case, the uncertainty field is ignored.
	// To specify a completely certain prediction, set its uncertainty to 0.
	Uncertainty     *int32 `protobuf:"varint,3,opt,name=uncertainty" json:"uncertainty,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TripUpdate_StopTimeEvent) Reset() {
	*x = TripUpdate_StopTimeEvent{}
	mi := &file_gtfs_realtime_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripUpdate_StopTimeEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripUpdate_StopTimeEvent) ProtoMessage() {}

func (x *TripUpdate_StopTimeEvent) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripUpdate_StopTimeEvent.ProtoReflect.Descriptor instead.
func (*TripUpdate_StopTimeEvent) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{3, 0}
}

func (x *TripUpdate_StopTimeEvent) GetDelay() int32 {
	if x != nil && x.Delay != nil {
		return *x.Delay
	}
	return 0
}

func (x *TripUpdate_StopTimeEvent) GetTime() int64 {
	if x != nil && x.Time != nil {
		return *x.Time
	}
	return 0
}

func (x *TripUpdate_StopTimeEvent) GetUncertainty() int32 {
	if x != nil && x.Uncertainty != nil {
		return *x.Uncertainty
	}
	return 0
}

// Realtime update for arrival and/or departure events for a given stop on a
// trip. Updates can be supplied for both past and future events.
// The producer is allowed, although not required, to drop past events.
type TripUpdate_StopTimeUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Must be the same as in stop_times.txt in the corresponding GTFS feed.
	StopSequence *uint32 `protobuf:"varint,1,opt,name=stop_sequence,json=stopSequence" json:"stop_sequence,omitempty"`
	// Must be the same as in stops.txt in the corresponding GTFS feed.
	StopId    *string                   `protobuf:"bytes,4,opt,name=stop_id,json=stopId" json:"stop_id,omitempty"`
	Arrival   *TripUpdate_StopTimeEvent `protobuf:"bytes,2,opt,name=arrival" json:"arrival,omitempty"`
	Departure *TripUpdate_StopTimeEvent `protobuf:"bytes,3,opt,name=departure" json:"departure,omitempty"`
	// Expected occupancy after departure from the given stop.
	// Should be provided only for future stops.
	// In order to provide departure_occupancy_status without either arrival or
	// departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA.
	DepartureOccupancyStatus *VehiclePosition_OccupancyStatus                `protobuf:"varint,7,opt,name=departure_occupancy_status,json=departureOccupancyStatus,enum=transit_realtime.VehiclePosition_OccupancyStatus" json:"departure_occupancy_status,omitempty"`
	ScheduleRelationship     *TripUpdate_StopTimeUpdate_ScheduleRelationship `protobuf:"varint,5,opt,name=schedule_relationship,json=scheduleRelationship,enum=transit_realtime.TripUpdate_StopTimeUpdate_ScheduleRelationship,def=0" json:"schedule_relationship,omitempty"`
	// Realtime updates for certain properties defined within GTFS stop_times.txt
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	StopTimeProperties *TripUpdate_StopTimeUpdate_StopTimeProperties `protobuf:"bytes,6,opt,name=stop_time_properties,json=stopTimeProperties" json:"stop_time_properties,omitempty"`
	extensionFields    protoimpl.ExtensionFields
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

// Default values for TripUpdate_StopTimeUpdate fields.
const (
	Default_TripUpdate_StopTimeUpdate_ScheduleRelationship = TripUpdate_StopTimeUpdate_SCHEDULED
)

func (x *TripUpdate_StopTimeUpdate) Reset() {
	*x = TripUpdate_StopTimeUpdate{}
	mi := &file_gtfs_realtime_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripUpdate_StopTimeUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripUpdate_StopTimeUpdate) ProtoMessage() {}

func (x *TripUpdate_StopTimeUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripUpdate_StopTimeUpdate.ProtoReflect.Descriptor instead.
func (*TripUpdate_StopTimeUpdate) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{3, 1}
}

func (x *TripUpdate_StopTimeUpdate) GetStopSequence() uint32 {
	if x != nil && x.StopSequence != nil {
		return *x.StopSequence
	}
	return 0
}

func (x *TripUpdate_StopTimeUpdate) GetStopId() string {
	if x != nil && x.StopId != nil {
		return *x.StopId
	}
	return ""
}

func (x *TripUpdate_StopTimeUpdate) GetArrival() *TripUpdate_StopTimeEvent {
	if x != nil {
		return x.Arrival
	}
	return nil
}

func (x *TripUpdate_StopTimeUpdate) GetDeparture() *TripUpdate_StopTimeEvent {
	if x != nil {
		return x.Departure
	}
	return nil
}

func (x *TripUpdate_StopTimeUpdate) GetDepartureOccupancyStatus() VehiclePosition_OccupancyStatus {
	if x != nil && x.DepartureOccupancyStatus != nil {
		return *x.DepartureOccupancyStatus
	}
	return VehiclePosition_EMPTY
}

func (x *TripUpdate_StopTimeUpdate) GetScheduleRelationship() TripUpdate_StopTimeUpdate_ScheduleRelationship {
	if x != nil && x.ScheduleRelationship != nil {
		return *x.ScheduleRelationship
	}
	return Default_TripUpdate_StopTimeUpdate_ScheduleRelationship
}

func (x *TripUpdate_StopTimeUpdate) GetStopTimeProperties() *TripUpdate_StopTimeUpdate_StopTimeProperties {
	if x != nil {
		return x.StopTimeProperties
	}
	return nil
}

// Defines updated properties of the trip, such as a new shape_id when there is a detour. Or defines the
// trip_id, start_date, and start_time of a DUPLICATED trip.
// NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
type TripUpdate_TripProperties struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
	// but will start at a different service date and/or time (defined using the TripProperties.start_date and
	// TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
	// than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
	// be populated and will be ignored by consumers.
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	TripId *string `protobuf:"bytes,1,opt,name=trip_id,json=tripId" json:"trip_id,omitempty"`
	// Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
	// schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	StartDate *string `protobuf:"bytes,2,opt,name=start_date,json=startDate" json:"start_date,omitempty"`
	// Defines the departure start time of the trip when itâ€™s duplicated. See definition of stop_times.departure_time
	// in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
	// between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
	// departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
	// of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
	// delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
	// departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
	// prediction time values do not have any offset applied to them and indicate the predicted time as provided.
	// For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
	// is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
	// populated and will be ignored by consumers.
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	StartTime *string `protobuf:"bytes,3,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
	// (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
	// paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
	// nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
	// or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
	// (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
	// be marked as schedule_relationship=SKIPPED.
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	ShapeId         *string `protobuf:"bytes,4,opt,name=shape_id,json=shapeId" json:"shape_id,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TripUpdate_TripProperties) Reset() {
	*x = TripUpdate_TripProperties{}
	mi := &file_gtfs_realtime_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripUpdate_TripProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripUpdate_TripProperties) ProtoMessage() {}

func (x *TripUpdate_TripProperties) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripUpdate_TripProperties.ProtoReflect.Descriptor instead.
func (*TripUpdate_TripProperties) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{3, 2}
}

func (x *TripUpdate_TripProperties) GetTripId() string {
	if x != nil && x.TripId != nil {
		return *x.TripId
	}
	return ""
}

func (x *TripUpdate_TripProperties) GetStartDate() string {
	if x != nil && x.StartDate != nil {
		return *x.StartDate
	}
	return ""
}

func (x *TripUpdate_TripProperties) GetStartTime() string {
	if x != nil && x.StartTime != nil {
		return *x.StartTime
	}
	return ""
}

func (x *TripUpdate_TripProperties) GetShapeId() string {
	if x != nil && x.ShapeId != nil {
		return *x.ShapeId
	}
	return ""
}

// Provides the updated values for the stop time.
// NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
type TripUpdate_StopTimeUpdate_StopTimeProperties struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
	// The new assigned_stop_id should not result in a significantly different trip experience for the end user than
	// the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
	// "unusual change" if the new stop was presented within an app without any additional context.
	// For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
	// same station as the stop originally defined in GTFS stop_times.txt.
	// To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
	// StopTimeUpdate.schedule_relationship = NO_DATA.
	// If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
	// `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
	// Platform assignments should be reflected in other GTFS-realtime fields as well
	// (e.g., `VehiclePosition.stop_id`).
	// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
	AssignedStopId  *string `protobuf:"bytes,1,opt,name=assigned_stop_id,json=assignedStopId" json:"assigned_stop_id,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TripUpdate_StopTimeUpdate_StopTimeProperties) Reset() {
	*x = TripUpdate_StopTimeUpdate_StopTimeProperties{}
	mi := &file_gtfs_realtime_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripUpdate_StopTimeUpdate_StopTimeProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripUpdate_StopTimeUpdate_StopTimeProperties) ProtoMessage() {}

func (x *TripUpdate_StopTimeUpdate_StopTimeProperties) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripUpdate_StopTimeUpdate_StopTimeProperties.ProtoReflect.Descriptor instead.
func (*TripUpdate_StopTimeUpdate_StopTimeProperties) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{3, 1, 0}
}

func (x *TripUpdate_StopTimeUpdate_StopTimeProperties) GetAssignedStopId() string {
	if x != nil && x.AssignedStopId != nil {
		return *x.AssignedStopId
	}
	return ""
}

// Carriage specific details, used for vehicles composed of several carriages
// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
type VehiclePosition_CarriageDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identification of the carriage. Should be unique per vehicle.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// User visible label that may be shown to the passenger to help identify
	// the carriage. Example: "7712", "Car ABC-32", etc...
	// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
	Label *string `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	// Occupancy status for this given carriage, in this vehicle
	// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
	OccupancyStatus *VehiclePosition_OccupancyStatus `protobuf:"varint,3,opt,name=occupancy_status,json=occupancyStatus,enum=transit_realtime.VehiclePosition_OccupancyStatus,def=7" json:"occupancy_status,omitempty"`
	// Occupancy percentage for this given carriage, in this vehicle.
	// Follows the same rules as "VehiclePosition.occupancy_percentage"
	// -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
	// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
	OccupancyPercentage *int32 `protobuf:"varint,4,opt,name=occupancy_percentage,json=occupancyPercentage,def=-1" json:"occupancy_percentage,omitempty"`
	// Identifies the order of this carriage with respect to the other
	// carriages in the vehicle's list of CarriageDetails.
	// The first carriage in the direction of travel must have a value of 1.
	// The second value corresponds to the second carriage in the direction
	// of travel and must have a value of 2, and so forth.
	// For example, the first carriage in the direction of travel has a value of 1.
	// If the second carriage in the direction of travel has a value of 3,
	// consumers will discard data for all carriages (i.e., the multi_carriage_details field).
	// Carriages without data must be represented with a valid carriage_sequence number and the fields
	// without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
	// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
	CarriageSequence *uint32 `protobuf:"varint,5,opt,name=carriage_sequence,json=carriageSequence" json:"carriage_sequence,omitempty"`
	extensionFields  protoimpl.ExtensionFields
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

// Default values for VehiclePosition_CarriageDetails fields.
const (
	Default_VehiclePosition_CarriageDetails_OccupancyStatus     = VehiclePosition_NO_DATA_AVAILABLE
	Default_VehiclePosition_CarriageDetails_OccupancyPercentage = int32(-1)
)

func (x *VehiclePosition_CarriageDetails) Reset() {
	*x = VehiclePosition_CarriageDetails{}
	mi := &file_gtfs_realtime_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VehiclePosition_CarriageDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VehiclePosition_CarriageDetails) ProtoMessage() {}

func (x *VehiclePosition_CarriageDetails) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VehiclePosition_CarriageDetails.ProtoReflect.Descriptor instead.
func (*VehiclePosition_CarriageDetails) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{4, 0}
}

func (x *VehiclePosition_CarriageDetails) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *VehiclePosition_CarriageDetails) GetLabel() string {
	if x != nil && x.Label != nil {
		return *x.Label
	}
	return ""
}

func (x *VehiclePosition_CarriageDetails) GetOccupancyStatus() VehiclePosition_OccupancyStatus {
	if x != nil && x.OccupancyStatus != nil {
		return *x.OccupancyStatus
	}
	return Default_VehiclePosition_CarriageDetails_OccupancyStatus
}

func (x *VehiclePosition_CarriageDetails) GetOccupancyPercentage() int32 {
	if x != nil && x.OccupancyPercentage != nil {
		return *x.OccupancyPercentage
	}
	return Default_VehiclePosition_CarriageDetails_OccupancyPercentage
}

func (x *VehiclePosition_CarriageDetails) GetCarriageSequence() uint32 {
	if x != nil && x.CarriageSequence != nil {
		return *x.CarriageSequence
	}
	return 0
}

type TripDescriptor_ModifiedTripSelector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
	ModificationsId *string `protobuf:"bytes,1,opt,name=modifications_id,json=modificationsId" json:"modifications_id,omitempty"`
	// The trip_id from the GTFS feed that is modified by the modifications_id
	AffectedTripId *string `protobuf:"bytes,2,opt,name=affected_trip_id,json=affectedTripId" json:"affected_trip_id,omitempty"`
	// The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
	StartTime *string `protobuf:"bytes,3,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
	StartDate       *string `protobuf:"bytes,4,opt,name=start_date,json=startDate" json:"start_date,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TripDescriptor_ModifiedTripSelector) Reset() {
	*x = TripDescriptor_ModifiedTripSelector{}
	mi := &file_gtfs_realtime_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripDescriptor_ModifiedTripSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripDescriptor_ModifiedTripSelector) ProtoMessage() {}

func (x *TripDescriptor_ModifiedTripSelector) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripDescriptor_ModifiedTripSelector.ProtoReflect.Descriptor instead.
func (*TripDescriptor_ModifiedTripSelector) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{8, 0}
}

func (x *TripDescriptor_ModifiedTripSelector) GetModificationsId() string {
	if x != nil && x.ModificationsId != nil {
		return *x.ModificationsId
	}
	return ""
}

func (x *TripDescriptor_ModifiedTripSelector) GetAffectedTripId() string {
	if x != nil && x.AffectedTripId != nil {
		return *x.AffectedTripId
	}
	return ""
}

func (x *TripDescriptor_ModifiedTripSelector) GetStartTime() string {
	if x != nil && x.StartTime != nil {
		return *x.StartTime
	}
	return ""
}

func (x *TripDescriptor_ModifiedTripSelector) GetStartDate() string {
	if x != nil && x.StartDate != nil {
		return *x.StartDate
	}
	return ""
}

type TranslatedString_Translation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A UTF-8 string containing the message.
	Text *string `protobuf:"bytes,1,req,name=text" json:"text,omitempty"`
	// BCP-47 language code. Can be omitted if the language is unknown or if
	// no i18n is done at all for the feed. At most one translation is
	// allowed to have an unspecified language tag.
	Language        *string `protobuf:"bytes,2,opt,name=language" json:"language,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TranslatedString_Translation) Reset() {
	*x = TranslatedString_Translation{}
	mi := &file_gtfs_realtime_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranslatedString_Translation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranslatedString_Translation) ProtoMessage() {}

func (x *TranslatedString_Translation) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranslatedString_Translation.ProtoReflect.Descriptor instead.
func (*TranslatedString_Translation) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{11, 0}
}

func (x *TranslatedString_Translation) GetText() string {
	if x != nil && x.Text != nil {
		return *x.Text
	}
	return ""
}

func (x *TranslatedString_Translation) GetLanguage() string {
	if x != nil && x.Language != nil {
		return *x.Language
	}
	return ""
}

type TranslatedImage_LocalizedImage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// String containing an URL linking to an image
	// The image linked must be less than 2MB.
	// If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
	// The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the followingÂ http://www.w3.org/Addressing/URL/4_URI_Recommentations.htmlÂ for a description of how to create fully qualified URL values.
	Url *string `protobuf:"bytes,1,req,name=url" json:"url,omitempty"`
	// IANA media type as to specify the type of image to be displayed.
	// The type must start with "image/"
	MediaType *string `protobuf:"bytes,2,req,name=media_type,json=mediaType" json:"media_type,omitempty"`
	// BCP-47 language code. Can be omitted if the language is unknown or if
	// no i18n is done at all for the feed. At most one translation is
	// allowed to have an unspecified language tag.
	Language        *string `protobuf:"bytes,3,opt,name=language" json:"language,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TranslatedImage_LocalizedImage) Reset() {
	*x = TranslatedImage_LocalizedImage{}
	mi := &file_gtfs_realtime_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TranslatedImage_LocalizedImage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TranslatedImage_LocalizedImage) ProtoMessage() {}

func (x *TranslatedImage_LocalizedImage) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TranslatedImage_LocalizedImage.ProtoReflect.Descriptor instead.
func (*TranslatedImage_LocalizedImage) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{12, 0}
}

func (x *TranslatedImage_LocalizedImage) GetUrl() string {
	if x != nil && x.Url != nil {
		return *x.Url
	}
	return ""
}

func (x *TranslatedImage_LocalizedImage) GetMediaType() string {
	if x != nil && x.MediaType != nil {
		return *x.MediaType
	}
	return ""
}

func (x *TranslatedImage_LocalizedImage) GetLanguage() string {
	if x != nil && x.Language != nil {
		return *x.Language
	}
	return ""
}

// A `Modification` message replaces a span of n stop times from each affected trip starting at `start_stop_selector`.
type TripModifications_Modification struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The stop selector of the first stop_time of the original trip that is to be affected by this modification.
	// Used in conjuction with `end_stop_selector`.
	// `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
	StartStopSelector *StopSelector `protobuf:"bytes,1,opt,name=start_stop_selector,json=startStopSelector" json:"start_stop_selector,omitempty"`
	// The stop selector of the last stop of the original trip that is to be affected by this modification.
	// The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
	// If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
	EndStopSelector *StopSelector `protobuf:"bytes,2,opt,name=end_stop_selector,json=endStopSelector" json:"end_stop_selector,omitempty"`
	// The number of seconds of delay to add to all departure and arrival times following the end of this modification.
	// If multiple modifications apply to the same trip, the delays accumulate as the trip advances.
	PropagatedModificationDelay *int32 `protobuf:"varint,3,opt,name=propagated_modification_delay,json=propagatedModificationDelay,def=0" json:"propagated_modification_delay,omitempty"`
	// A list of replacement stops, replacing those of the original trip.
	// The length of the new stop times may be less, the same, or greater than the number of replaced stop times.
	ReplacementStops []*ReplacementStop `protobuf:"bytes,4,rep,name=replacement_stops,json=replacementStops" json:"replacement_stops,omitempty"`
	// An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
	ServiceAlertId *string `protobuf:"bytes,5,opt,name=service_alert_id,json=serviceAlertId" json:"service_alert_id,omitempty"`
	// This timestamp identifies the moment when the modification has last been changed.
	// In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
	LastModifiedTime *uint64 `protobuf:"varint,6,opt,name=last_modified_time,json=lastModifiedTime" json:"last_modified_time,omitempty"`
	extensionFields  protoimpl.ExtensionFields
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

// Default values for TripModifications_Modification fields.
const (
	Default_TripModifications_Modification_PropagatedModificationDelay = int32(0)
)

func (x *TripModifications_Modification) Reset() {
	*x = TripModifications_Modification{}
	mi := &file_gtfs_realtime_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripModifications_Modification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripModifications_Modification) ProtoMessage() {}

func (x *TripModifications_Modification) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripModifications_Modification.ProtoReflect.Descriptor instead.
func (*TripModifications_Modification) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{15, 0}
}

func (x *TripModifications_Modification) GetStartStopSelector() *StopSelector {
	if x != nil {
		return x.StartStopSelector
	}
	return nil
}

func (x *TripModifications_Modification) GetEndStopSelector() *StopSelector {
	if x != nil {
		return x.EndStopSelector
	}
	return nil
}

func (x *TripModifications_Modification) GetPropagatedModificationDelay() int32 {
	if x != nil && x.PropagatedModificationDelay != nil {
		return *x.PropagatedModificationDelay
	}
	return Default_TripModifications_Modification_PropagatedModificationDelay
}

func (x *TripModifications_Modification) GetReplacementStops() []*ReplacementStop {
	if x != nil {
		return x.ReplacementStops
	}
	return nil
}

func (x *TripModifications_Modification) GetServiceAlertId() string {
	if x != nil && x.ServiceAlertId != nil {
		return *x.ServiceAlertId
	}
	return ""
}

func (x *TripModifications_Modification) GetLastModifiedTime() uint64 {
	if x != nil && x.LastModifiedTime != nil {
		return *x.LastModifiedTime
	}
	return 0
}

type TripModifications_SelectedTrips struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of trips affected with this replacement that all have the same new `shape_id`.
	TripIds []string `protobuf:"bytes,1,rep,name=trip_ids,json=tripIds" json:"trip_ids,omitempty"`
	// The ID of the new shape for the modified trips in this SelectedTrips.
	// May refer to a new shape added using a GTFS-RT Shape message, or to an existing shape defined in the GTFS-Static feedâ€™s shapes.txt.
	ShapeId         *string `protobuf:"bytes,2,opt,name=shape_id,json=shapeId" json:"shape_id,omitempty"`
	extensionFields protoimpl.ExtensionFields
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *TripModifications_SelectedTrips) Reset() {
	*x = TripModifications_SelectedTrips{}
	mi := &file_gtfs_realtime_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TripModifications_SelectedTrips) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TripModifications_SelectedTrips) ProtoMessage() {}

func (x *TripModifications_SelectedTrips) ProtoReflect() protoreflect.Message {
	mi := &file_gtfs_realtime_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TripModifications_SelectedTrips.ProtoReflect.Descriptor instead.
func (*TripModifications_SelectedTrips) Descriptor() ([]byte, []int) {
	return file_gtfs_realtime_proto_rawDescGZIP(), []int{15, 1}
}

func (x *TripModifications_SelectedTrips) GetTripIds() []string {
	if x != nil {
		return x.TripIds
	}
	return nil
}

func (x *TripModifications_SelectedTrips) GetShapeId() string {
	if x != nil && x.ShapeId != nil {
		return *x.ShapeId
	}
	return ""
}

var File_gtfs_realtime_proto protoreflect.FileDescriptor

const file_gtfs_realtime_proto_rawDesc = "" +
	"\n" +
	"\x13gtfs-realtime.proto\x12\x10transit_realtime\"\x89\x01\n" +
	"\vFeedMessage\x124\n" +
	"\x06header\x18\x01 \x02(\v2\x1c.transit_realtime.FeedHeaderR\x06header\x124\n" +
	"\x06entity\x18\x02 \x03(\v2\x1c.transit_realtime.FeedEntityR\x06entity*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\xaa\x02\n" +
	"\n" +
	"FeedHeader\x122\n" +
	"\x15gtfs_realtime_version\x18\x01 \x02(\tR\x13gtfsRealtimeVersion\x12a\n" +
	"\x0eincrementality\x18\x02 \x01(\x0e2+.transit_realtime.FeedHeader.Incrementality:\fFULL_DATASETR\x0eincrementality\x12\x1c\n" +
	"\ttimestamp\x18\x03 \x01(\x04R\ttimestamp\x12!\n" +
	"\ffeed_version\x18\x04 \x01(\tR\vfeedVersion\"4\n" +
	"\x0eIncrementality\x12\x10\n" +
	"\fFULL_DATASET\x10\x00\x12\x10\n" +
	"\fDIFFERENTIAL\x10\x01*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\xac\x03\n" +
	"\n" +
	"FeedEntity\x12\x0e\n" +
	"\x02id\x18\x01 \x02(\tR\x02id\x12$\n" +
	"\n" +
	"is_deleted\x18\x02 \x01(\b:\x05falseR\tisDeleted\x12=\n" +
	"\vtrip_update\x18\x03 \x01(\v2\x1c.transit_realtime.TripUpdateR\n" +
	"tripUpdate\x12;\n" +
	"\avehicle\x18\x04 \x01(\v2!.transit_realtime.VehiclePositionR\avehicle\x12-\n" +
	"\x05alert\x18\x05 \x01(\v2\x17.transit_realtime.AlertR\x05alert\x12-\n" +
	"\x05shape\x18\x06 \x01(\v2\x17.transit_realtime.ShapeR\x05shape\x12*\n" +
	"\x04stop\x18\a \x01(\v2\x16.transit_realtime.StopR\x04stop\x12R\n" +
	"\x12trip_modifications\x18\b \x01(\v2#.transit_realtime.TripModificationsR\x11tripModifications*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\xed\n" +
	"\n" +
	"\n" +
	"TripUpdate\x124\n" +
	"\x04trip\x18\x01 \x02(\v2 .transit_realtime.TripDescriptorR\x04trip\x12=\n" +
	"\avehicle\x18\x03 \x01(\v2#.transit_realtime.VehicleDescriptorR\avehicle\x12U\n" +
	"\x10stop_time_update\x18\x02 \x03(\v2+.transit_realtime.TripUpdate.StopTimeUpdateR\x0estopTimeUpdate\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\x04R\ttimestamp\x12\x14\n" +
	"\x05delay\x18\x05 \x01(\x05R\x05delay\x12T\n" +
	"\x0ftrip_properties\x18\x06 \x01(\v2+.transit_realtime.TripUpdate.TripPropertiesR\x0etripProperties\x1ak\n" +
	"\rStopTimeEvent\x12\x14\n" +
	"\x05delay\x18\x01 \x01(\x05R\x05delay\x12\x12\n" +
	"\x04time\x18\x02 \x01(\x03R\x04time\x12 \n" +
	"\vuncertainty\x18\x03 \x01(\x05R\vuncertainty*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\x1a\xf6\x05\n" +
	"\x0eStopTimeUpdate\x12#\n" +
	"\rstop_sequence\x18\x01 \x01(\rR\fstopSequence\x12\x17\n" +
	"\astop_id\x18\x04 \x01(\tR\x06stopId\x12D\n" +
	"\aarrival\x18\x02 \x01(\v2*.transit_realtime.TripUpdate.StopTimeEventR\aarrival\x12H\n" +
	"\tdeparture\x18\x03 \x01(\v2*.transit_realtime.TripUpdate.StopTimeEventR\tdeparture\x12o\n" +
	"\x1adeparture_occupancy_status\x18\a \x01(\x0e21.transit_realtime.VehiclePosition.OccupancyStatusR\x18departureOccupancyStatus\x12\x80\x01\n" +
	"\x15schedule_relationship\x18\x05 \x01(\x0e2@.transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship:\tSCHEDULEDR\x14scheduleRelationship\x12p\n" +
	"\x14stop_time_properties\x18\x06 \x01(\v2>.transit_realtime.TripUpdate.StopTimeUpdate.StopTimePropertiesR\x12stopTimeProperties\x1aN\n" +
	"\x12StopTimeProperties\x12(\n" +
	"\x10assigned_stop_id\x18\x01 \x01(\tR\x0eassignedStopId*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"P\n" +
	"\x14ScheduleRelationship\x12\r\n" +
	"\tSCHEDULED\x10\x00\x12\v\n" +
	"\aSKIPPED\x10\x01\x12\v\n" +
	"\aNO_DATA\x10\x02\x12\x0f\n" +
	"\vUNSCHEDULED\x10\x03*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\x1a\x92\x01\n" +
	"\x0eTripProperties\x12\x17\n" +
	"\atrip_id\x18\x01 \x01(\tR\x06tripId\x12\x1d\n" +
	"\n" +
	"start_date\x18\x02 \x01(\tR\tstartDate\x12\x1d\n" +
	"\n" +
	"start_time\x18\x03 \x01(\tR\tstartTime\x12\x19\n" +
	"\bshape_id\x18\x04 \x01(\tR\ashapeId*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\xbf\v\n" +
	"\x0fVehiclePosition\x124\n" +
	"\x04trip\x18\x01 \x01(\v2 .transit_realtime.TripDescriptorR\x04trip\x12=\n" +
	"\avehicle\x18\b \x01(\v2#.transit_realtime.VehicleDescriptorR\avehicle\x126\n" +
	"\bposition\x18\x02 \x01(\v2\x1a.transit_realtime.PositionR\bposition\x122\n" +
	"\x15current_stop_sequence\x18\x03 \x01(\rR\x13currentStopSequence\x12\x17\n" +
	"\astop_id\x18\a \x01(\tR\x06stopId\x12i\n" +
	"\x0ecurrent_status\x18\x04 \x01(\x0e23.transit_realtime.VehiclePosition.VehicleStopStatus:\rIN_TRANSIT_TOR\rcurrentStatus\x12\x1c\n" +
	"\ttimestamp\x18\x05 \x01(\x04R\ttimestamp\x12\\\n" +
	"\x10congestion_level\x18\x06 \x01(\x0e21.transit_realtime.VehiclePosition.CongestionLevelR\x0fcongestionLevel\x12\\\n" +
	"\x10occupancy_status\x18\t \x01(\x0e21.transit_realtime.VehiclePosition.OccupancyStatusR\x0foccupancyStatus\x121\n" +
	"\x14occupancy_percentage\x18\n" +
	" \x01(\rR\x13occupancyPercentage\x12g\n" +
	"\x16multi_carriage_details\x18\v \x03(\v21.transit_realtime.VehiclePosition.CarriageDetailsR\x14multiCarriageDetails\x1a\x9c\x02\n" +
	"\x0fCarriageDetails\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12o\n" +
	"\x10occupancy_status\x18\x03 \x01(\x0e21.transit_realtime.VehiclePosition.OccupancyStatus:\x11NO_DATA_AVAILABLER\x0foccupancyStatus\x125\n" +
	"\x14occupancy_percentage\x18\x04 \x01(\x05:\x02-1R\x13occupancyPercentage\x12+\n" +
	"\x11carriage_sequence\x18\x05 \x01(\rR\x10carriageSequence*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"G\n" +
	"\x11VehicleStopStatus\x12\x0f\n" +
	"\vINCOMING_AT\x10\x00\x12\x0e\n" +
	"\n" +
	"STOPPED_AT\x10\x01\x12\x11\n" +
	"\rIN_TRANSIT_TO\x10\x02\"}\n" +
	"\x0fCongestionLevel\x12\x1c\n" +
	"\x18UNKNOWN_CONGESTION_LEVEL\x10\x00\x12\x14\n" +
	"\x10RUNNING_SMOOTHLY\x10\x01\x12\x0f\n" +
	"\vSTOP_AND_GO\x10\x02\x12\x0e\n" +
	"\n" +
	"CONGESTION\x10\x03\x12\x15\n" +
	"\x11SEVERE_CONGESTION\x10\x04\"\xd9\x01\n" +
	"\x0fOccupancyStatus\x12\t\n" +
	"\x05EMPTY\x10\x00\x12\x18\n" +
	"\x14MANY_SEATS_AVAILABLE\x10\x01\x12\x17\n" +
	"\x13FEW_SEATS_AVAILABLE\x10\x02\x12\x16\n" +
	"\x12STANDING_ROOM_ONLY\x10\x03\x12\x1e\n" +
	"\x1aCRUSHED_STANDING_ROOM_ONLY\x10\x04\x12\b\n" +
	"\x04FULL\x10\x05\x12\x1c\n" +
	"\x18NOT_ACCEPTING_PASSENGERS\x10\x06\x12\x15\n" +
	"\x11NO_DATA_AVAILABLE\x10\a\x12\x11\n" +
	"\rNOT_BOARDABLE\x10\b*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\xa4\f\n" +
	"\x05Alert\x12@\n" +
	"\ractive_period\x18\x01 \x03(\v2\x1b.transit_realtime.TimeRangeR\factivePeriod\x12I\n" +
	"\x0finformed_entity\x18\x05 \x03(\v2 .transit_realtime.EntitySelectorR\x0einformedEntity\x12B\n" +
	"\x05cause\x18\x06 \x01(\x0e2\x1d.transit_realtime.Alert.Cause:\rUNKNOWN_CAUSER\x05cause\x12F\n" +
	"\x06effect\x18\a \x01(\x0e2\x1e.transit_realtime.Alert.Effect:\x0eUNKNOWN_EFFECTR\x06effect\x124\n" +
	"\x03url\x18\b \x01(\v2\".transit_realtime.TranslatedStringR\x03url\x12C\n" +
	"\vheader_text\x18\n" +
	" \x01(\v2\".transit_realtime.TranslatedStringR\n" +
	"headerText\x12M\n" +
	"\x10description_text\x18\v \x01(\v2\".transit_realtime.TranslatedStringR\x0fdescriptionText\x12J\n" +
	"\x0ftts_header_text\x18\f \x01(\v2\".transit_realtime.TranslatedStringR\rttsHeaderText\x12T\n" +
	"\x14tts_description_text\x18\r \x01(\v2\".transit_realtime.TranslatedStringR\x12ttsDescriptionText\x12^\n" +
	"\x0eseverity_level\x18\x0e \x01(\x0e2%.transit_realtime.Alert.SeverityLevel:\x10UNKNOWN_SEVERITYR\rseverityLevel\x127\n" +
	"\x05image\x18\x0f \x01(\v2!.transit_realtime.TranslatedImageR\x05image\x12X\n" +
	"\x16image_alternative_text\x18\x10 \x01(\v2\".transit_realtime.TranslatedStringR\x14imageAlternativeText\x12E\n" +
	"\fcause_detail\x18\x11 \x01(\v2\".transit_realtime.TranslatedStringR\vcauseDetail\x12G\n" +
	"\reffect_detail\x18\x12 \x01(\v2\".transit_realtime.TranslatedStringR\feffectDetail\"\xd8\x01\n" +
	"\x05Cause\x12\x11\n" +
	"\rUNKNOWN_CAUSE\x10\x01\x12\x0f\n" +
	"\vOTHER_CAUSE\x10\x02\x12\x15\n" +
	"\x11TECHNICAL_PROBLEM\x10\x03\x12\n" +
	"\n" +
	"\x06STRIKE\x10\x04\x12\x11\n" +
	"\rDEMONSTRATION\x10\x05\x12\f\n" +
	"\bACCIDENT\x10\x06\x12\v\n" +
	"\aHOLIDAY\x10\a\x12\v\n" +
	"\aWEATHER\x10\b\x12\x0f\n" +
	"\vMAINTENANCE\x10\t\x12\x10\n" +
	"\fCONSTRUCTION\x10\n" +
	"\x12\x13\n" +
	"\x0fPOLICE_ACTIVITY\x10\v\x12\x15\n" +
	"\x11MEDICAL_EMERGENCY\x10\f\"\xdd\x01\n" +
	"\x06Effect\x12\x0e\n" +
	"\n" +
	"NO_SERVICE\x10\x01\x12\x13\n" +
	"\x0fREDUCED_SERVICE\x10\x02\x12\x16\n" +
	"\x12SIGNIFICANT_DELAYS\x10\x03\x12\n" +
	"\n" +
	"\x06DETOUR\x10\x04\x12\x16\n" +
	"\x12ADDITIONAL_SERVICE\x10\x05\x12\x14\n" +
	"\x10MODIFIED_SERVICE\x10\x06\x12\x10\n" +
	"\fOTHER_EFFECT\x10\a\x12\x12\n" +
	"\x0eUNKNOWN_EFFECT\x10\b\x12\x0e\n" +
	"\n" +
	"STOP_MOVED\x10\t\x12\r\n" +
	"\tNO_EFFECT\x10\n" +
	"\x12\x17\n" +
	"\x13ACCESSIBILITY_ISSUE\x10\v\"H\n" +
	"\rSeverityLevel\x12\x14\n" +
	"\x10UNKNOWN_SEVERITY\x10\x01\x12\b\n" +
	"\x04INFO\x10\x02\x12\v\n" +
	"\aWARNING\x10\x03\x12\n" +
	"\n" +
	"\x06SEVERE\x10\x04*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"C\n" +
	"\tTimeRange\x12\x14\n" +
	"\x05start\x18\x01 \x01(\x04R\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\x04R\x03end*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\xa0\x01\n" +
	"\bPosition\x12\x1a\n" +
	"\blatitude\x18\x01 \x02(\x02R\blatitude\x12\x1c\n" +
	"\tlongitude\x18\x02 \x02(\x02R\tlongitude\x12\x18\n" +
	"\abearing\x18\x03 \x01(\x02R\abearing\x12\x1a\n" +
	"\bodometer\x18\x04 \x01(\x01R\bodometer\x12\x14\n" +
	"\x05speed\x18\x05 \x01(\x02R\x05speed*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\xbd\x05\n" +
	"\x0eTripDescriptor\x12\x17\n" +
	"\atrip_id\x18\x01 \x01(\tR\x06tripId\x12\x19\n" +
	"\broute_id\x18\x05 \x01(\tR\arouteId\x12!\n" +
	"\fdirection_id\x18\x06 \x01(\rR\vdirectionId\x12\x1d\n" +
	"\n" +
	"start_time\x18\x02 \x01(\tR\tstartTime\x12\x1d\n" +
	"\n" +
	"start_date\x18\x03 \x01(\tR\tstartDate\x12j\n" +
	"\x15schedule_relationship\x18\x04 \x01(\x0e25.transit_realtime.TripDescriptor.ScheduleRelationshipR\x14scheduleRelationship\x12Z\n" +
	"\rmodified_trip\x18\a \x01(\v25.transit_realtime.TripDescriptor.ModifiedTripSelectorR\fmodifiedTrip\x1a\xb9\x01\n" +
	"\x14ModifiedTripSelector\x12)\n" +
	"\x10modifications_id\x18\x01 \x01(\tR\x0fmodificationsId\x12(\n" +
	"\x10affected_trip_id\x18\x02 \x01(\tR\x0eaffectedTripId\x12\x1d\n" +
	"\n" +
	"start_time\x18\x03 \x01(\tR\tstartTime\x12\x1d\n" +
	"\n" +
	"start_date\x18\x04 \x01(\tR\tstartDate*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\x81\x01\n" +
	"\x14ScheduleRelationship\x12\r\n" +
	"\tSCHEDULED\x10\x00\x12\t\n" +
	"\x05ADDED\x10\x01\x12\x0f\n" +
	"\vUNSCHEDULED\x10\x02\x12\f\n" +
	"\bCANCELED\x10\x03\x12\x13\n" +
	"\vREPLACEMENT\x10\x05\x1a\x02\b\x01\x12\x0e\n" +
	"\n" +
	"DUPLICATED\x10\x06\x12\v\n" +
	"\aDELETED\x10\a*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\xd2\x02\n" +
	"\x11VehicleDescriptor\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x14\n" +
	"\x05label\x18\x02 \x01(\tR\x05label\x12#\n" +
	"\rlicense_plate\x18\x03 \x01(\tR\flicensePlate\x12w\n" +
	"\x15wheelchair_accessible\x18\x04 \x01(\x0e28.transit_realtime.VehicleDescriptor.WheelchairAccessible:\bNO_VALUER\x14wheelchairAccessible\"i\n" +
	"\x14WheelchairAccessible\x12\f\n" +
	"\bNO_VALUE\x10\x00\x12\v\n" +
	"\aUNKNOWN\x10\x01\x12\x19\n" +
	"\x15WHEELCHAIR_ACCESSIBLE\x10\x02\x12\x1b\n" +
	"\x17WHEELCHAIR_INACCESSIBLE\x10\x03*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\xe9\x01\n" +
	"\x0eEntitySelector\x12\x1b\n" +
	"\tagency_id\x18\x01 \x01(\tR\bagencyId\x12\x19\n" +
	"\broute_id\x18\x02 \x01(\tR\arouteId\x12\x1d\n" +
	"\n" +
	"route_type\x18\x03 \x01(\x05R\trouteType\x124\n" +
	"\x04trip\x18\x04 \x01(\v2 .transit_realtime.TripDescriptorR\x04trip\x12\x17\n" +
	"\astop_id\x18\x05 \x01(\tR\x06stopId\x12!\n" +
	"\fdirection_id\x18\x06 \x01(\rR\vdirectionId*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\xc3\x01\n" +
	"\x10TranslatedString\x12P\n" +
	"\vtranslation\x18\x01 \x03(\v2..transit_realtime.TranslatedString.TranslationR\vtranslation\x1aM\n" +
	"\vTranslation\x12\x12\n" +
	"\x04text\x18\x01 \x02(\tR\x04text\x12\x1a\n" +
	"\blanguage\x18\x02 \x01(\tR\blanguage*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\xeb\x01\n" +
	"\x0fTranslatedImage\x12Y\n" +
	"\x0flocalized_image\x18\x01 \x03(\v20.transit_realtime.TranslatedImage.LocalizedImageR\x0elocalizedImage\x1am\n" +
	"\x0eLocalizedImage\x12\x10\n" +
	"\x03url\x18\x01 \x02(\tR\x03url\x12\x1d\n" +
	"\n" +
	"media_type\x18\x02 \x02(\tR\tmediaType\x12\x1a\n" +
	"\blanguage\x18\x03 \x01(\tR\blanguage*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"]\n" +
	"\x05Shape\x12\x19\n" +
	"\bshape_id\x18\x01 \x01(\tR\ashapeId\x12)\n" +
	"\x10encoded_polyline\x18\x02 \x01(\tR\x0fencodedPolyline*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\xa2\x06\n" +
	"\x04Stop\x12\x17\n" +
	"\astop_id\x18\x01 \x01(\tR\x06stopId\x12?\n" +
	"\tstop_code\x18\x02 \x01(\v2\".transit_realtime.TranslatedStringR\bstopCode\x12?\n" +
	"\tstop_name\x18\x03 \x01(\v2\".transit_realtime.TranslatedStringR\bstopName\x12F\n" +
	"\rtts_stop_name\x18\x04 \x01(\v2\".transit_realtime.TranslatedStringR\vttsStopName\x12?\n" +
	"\tstop_desc\x18\x05 \x01(\v2\".transit_realtime.TranslatedStringR\bstopDesc\x12\x19\n" +
	"\bstop_lat\x18\x06 \x01(\x02R\astopLat\x12\x19\n" +
	"\bstop_lon\x18\a \x01(\x02R\astopLon\x12\x17\n" +
	"\azone_id\x18\b \x01(\tR\x06zoneId\x12=\n" +
	"\bstop_url\x18\t \x01(\v2\".transit_realtime.TranslatedStringR\astopUrl\x12%\n" +
	"\x0eparent_station\x18\v \x01(\tR\rparentStation\x12#\n" +
	"\rstop_timezone\x18\f \x01(\tR\fstopTimezone\x12c\n" +
	"\x13wheelchair_boarding\x18\r \x01(\x0e2).transit_realtime.Stop.WheelchairBoarding:\aUNKNOWNR\x12wheelchairBoarding\x12\x19\n" +
	"\blevel_id\x18\x0e \x01(\tR\alevelId\x12G\n" +
	"\rplatform_code\x18\x0f \x01(\v2\".transit_realtime.TranslatedStringR\fplatformCode\"C\n" +
	"\x12WheelchairBoarding\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\r\n" +
	"\tAVAILABLE\x10\x01\x12\x11\n" +
	"\rNOT_AVAILABLE\x10\x02*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\x9e\x06\n" +
	"\x11TripModifications\x12X\n" +
	"\x0eselected_trips\x18\x01 \x03(\v21.transit_realtime.TripModifications.SelectedTripsR\rselectedTrips\x12\x1f\n" +
	"\vstart_times\x18\x02 \x03(\tR\n" +
	"startTimes\x12#\n" +
	"\rservice_dates\x18\x03 \x03(\tR\fserviceDates\x12V\n" +
	"\rmodifications\x18\x04 \x03(\v20.transit_realtime.TripModifications.ModificationR\rmodifications\x1a\xa9\x03\n" +
	"\fModification\x12N\n" +
	"\x13start_stop_selector\x18\x01 \x01(\v2\x1e.transit_realtime.StopSelectorR\x11startStopSelector\x12J\n" +
	"\x11end_stop_selector\x18\x02 \x01(\v2\x1e.transit_realtime.StopSelectorR\x0fendStopSelector\x12E\n" +
	"\x1dpropagated_modification_delay\x18\x03 \x01(\x05:\x010R\x1bpropagatedModificationDelay\x12N\n" +
	"\x11replacement_stops\x18\x04 \x03(\v2!.transit_realtime.ReplacementStopR\x10replacementStops\x12(\n" +
	"\x10service_alert_id\x18\x05 \x01(\tR\x0eserviceAlertId\x12,\n" +
	"\x12last_modified_time\x18\x06 \x01(\x04R\x10lastModifiedTime*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\x1aU\n" +
	"\rSelectedTrips\x12\x19\n" +
	"\btrip_ids\x18\x01 \x03(\tR\atripIds\x12\x19\n" +
	"\bshape_id\x18\x02 \x01(\tR\ashapeId*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"\\\n" +
	"\fStopSelector\x12#\n" +
	"\rstop_sequence\x18\x01 \x01(\rR\fstopSequence\x12\x17\n" +
	"\astop_id\x18\x02 \x01(\tR\x06stopId*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90N\"i\n" +
	"\x0fReplacementStop\x12-\n" +
	"\x13travel_time_to_stop\x18\x01 \x01(\x05R\x10travelTimeToStop\x12\x17\n" +
	"\astop_id\x18\x02 \x01(\tR\x06stopId*\x06\b\xe8\a\x10\xd0\x0f*\x06\b\xa8F\x10\x90NB\x1d\n" +
	"\x1bcom.google.transit.realtime"

var (
	file_gtfs_realtime_proto_rawDescOnce sync.Once
	file_gtfs_realtime_proto_rawDescData []byte
)

func file_gtfs_realtime_proto_rawDescGZIP() []byte {
	file_gtfs_realtime_proto_rawDescOnce.Do(func() {
		file_gtfs_realtime_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_gtfs_realtime_proto_rawDesc), len(file_gtfs_realtime_proto_rawDesc)))
	})
	return file_gtfs_realtime_proto_rawDescData
}

var file_gtfs_realtime_proto_enumTypes = make([]protoimpl.EnumInfo, 11)
var file_gtfs_realtime_proto_msgTypes = make([]protoimpl.MessageInfo, 28)
var file_gtfs_realtime_proto_goTypes = []any{
	(FeedHeader_Incrementality)(0),                       // 0: transit_realtime.FeedHeader.Incrementality
	(TripUpdate_StopTimeUpdate_ScheduleRelationship)(0),  // 1: transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship
	(VehiclePosition_VehicleStopStatus)(0),               // 2: transit_realtime.VehiclePosition.VehicleStopStatus
	(VehiclePosition_CongestionLevel)(0),                 // 3: transit_realtime.VehiclePosition.CongestionLevel
	(VehiclePosition_OccupancyStatus)(0),                 // 4: transit_realtime.VehiclePosition.OccupancyStatus
	(Alert_Cause)(0),                                     // 5: transit_realtime.Alert.Cause
	(Alert_Effect)(0),                                    // 6: transit_realtime.Alert.Effect
	(Alert_SeverityLevel)(0),                             // 7: transit_realtime.Alert.SeverityLevel
	(TripDescriptor_ScheduleRelationship)(0),             // 8: transit_realtime.TripDescriptor.ScheduleRelationship
	(VehicleDescriptor_WheelchairAccessible)(0),          // 9: transit_realtime.VehicleDescriptor.WheelchairAccessible
	(Stop_WheelchairBoarding)(0),                         // 10: transit_realtime.Stop.WheelchairBoarding
	(*FeedMessage)(nil),                                  // 11: transit_realtime.FeedMessage
	(*FeedHeader)(nil),                                   // 12: transit_realtime.FeedHeader
	(*FeedEntity)(nil),                                   // 13: transit_realtime.FeedEntity
	(*TripUpdate)(nil),                                   // 14: transit_realtime.TripUpdate
	(*VehiclePosition)(nil),                              // 15: transit_realtime.VehiclePosition
	(*Alert)(nil),                                        // 16: transit_realtime.Alert
	(*TimeRange)(nil),                                    // 17: transit_realtime.TimeRange
	(*Position)(nil),                                     // 18: transit_realtime.Position
	(*TripDescriptor)(nil),                               // 19: transit_realtime.TripDescriptor
	(*VehicleDescriptor)(nil),                            // 20: transit_realtime.VehicleDescriptor
	(*EntitySelector)(nil),                               // 21: transit_realtime.EntitySelector
	(*TranslatedString)(nil),                             // 22: transit_realtime.TranslatedString
	(*TranslatedImage)(nil),                              // 23: transit_realtime.TranslatedImage
	(*Shape)(nil),                                        // 24: transit_realtime.Shape
	(*Stop)(nil),                                         // 25: transit_realtime.Stop
	(*TripModifications)(nil),                            // 26: transit_realtime.TripModifications
	(*StopSelector)(nil),                                 // 27: transit_realtime.StopSelector
	(*ReplacementStop)(nil),                              // 28: transit_realtime.ReplacementStop
	(*TripUpdate_StopTimeEvent)(nil),                     // 29: transit_realtime.TripUpdate.StopTimeEvent
	(*TripUpdate_StopTimeUpdate)(nil),                    // 30: transit_realtime.TripUpdate.StopTimeUpdate
	(*TripUpdate_TripProperties)(nil),                    // 31: transit_realtime.TripUpdate.TripProperties
	(*TripUpdate_StopTimeUpdate_StopTimeProperties)(nil), // 32: transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties
	(*VehiclePosition_CarriageDetails)(nil),              // 33: transit_realtime.VehiclePosition.CarriageDetails
	(*TripDescriptor_ModifiedTripSelector)(nil),          // 34: transit_realtime.TripDescriptor.ModifiedTripSelector
	(*TranslatedString_Translation)(nil),                 // 35: transit_realtime.TranslatedString.Translation
	(*TranslatedImage_LocalizedImage)(nil),               // 36: transit_realtime.TranslatedImage.LocalizedImage
	(*TripModifications_Modification)(nil),               // 37: transit_realtime.TripModifications.Modification
	(*TripModifications_SelectedTrips)(nil),              // 38: transit_realtime.TripModifications.SelectedTrips
}
var file_gtfs_realtime_proto_depIdxs = []int32{
	12, // 0: transit_realtime.FeedMessage.header:type_name -> transit_realtime.FeedHeader
	13, // 1: transit_realtime.FeedMessage.entity:type_name -> transit_realtime.FeedEntity
	0,  // 2: transit_realtime.FeedHeader.incrementality:type_name -> transit_realtime.FeedHeader.Incrementality
	14, // 3: transit_realtime.FeedEntity.trip_update:type_name -> transit_realtime.TripUpdate
	15, // 4: transit_realtime.FeedEntity.vehicle:type_name -> transit_realtime.VehiclePosition
	16, // 5: transit_realtime.FeedEntity.alert:type_name -> transit_realtime.Alert
	24, // 6: transit_realtime.FeedEntity.shape:type_name -> transit_realtime.Shape
	25, // 7: transit_realtime.FeedEntity.stop:type_name -> transit_realtime.Stop
	26, // 8: transit_realtime.FeedEntity.trip_modifications:type_name -> transit_realtime.TripModifications
	19, // 9: transit_realtime.TripUpdate.trip:type_name -> transit_realtime.TripDescriptor
	20, // 10: transit_realtime.TripUpdate.vehicle:type_name -> transit_realtime.VehicleDescriptor
	30, // 11: transit_realtime.TripUpdate.stop_time_update:type_name -> transit_realtime.TripUpdate.StopTimeUpdate
	31, // 12: transit_realtime.TripUpdate.trip_properties:type_name -> transit_realtime.TripUpdate.TripProperties
	19, // 13: transit_realtime.VehiclePosition.trip:type_name -> transit_realtime.TripDescriptor
	20, // 14: transit_realtime.VehiclePosition.vehicle:type_name -> transit_realtime.VehicleDescriptor
	18, // 15: transit_realtime.VehiclePosition.position:type_name -> transit_realtime.Position
	2,  // 16: transit_realtime.VehiclePosition.current_status:type_name -> transit_realtime.VehiclePosition.VehicleStopStatus
	3,  // 17: transit_realtime.VehiclePosition.congestion_level:type_name -> transit_realtime.VehiclePosition.CongestionLevel
	4,  // 18: transit_realtime.VehiclePosition.occupancy_status:type_name -> transit_realtime.VehiclePosition.OccupancyStatus
	33, // 19: transit_realtime.VehiclePosition.multi_carriage_details:type_name -> transit_realtime.VehiclePosition.CarriageDetails
	17, // 20: transit_realtime.Alert.active_period:type_name -> transit_realtime.TimeRange
	21, // 21: transit_realtime.Alert.informed_entity:type_name -> transit_realtime.EntitySelector
	5,  // 22: transit_realtime.Alert.cause:type_name -> transit_realtime.Alert.Cause
	6,  // 23: transit_realtime.Alert.effect:type_name -> transit_realtime.Alert.Effect
	22, // 24: transit_realtime.Alert.url:type_name -> transit_realtime.TranslatedString
	22, // 25: transit_realtime.Alert.header_text:type_name -> transit_realtime.TranslatedString
	22, // 26: transit_realtime.Alert.description_text:type_name -> transit_realtime.TranslatedString
	22, // 27: transit_realtime.Alert.tts_header_text:type_name -> transit_realtime.TranslatedString
	22, // 28: transit_realtime.Alert.tts_description_text:type_name -> transit_realtime.TranslatedString
	7,  // 29: transit_realtime.Alert.severity_level:type_name -> transit_realtime.Alert.SeverityLevel
	23, // 30: transit_realtime.Alert.image:type_name -> transit_realtime.TranslatedImage
	22, // 31: transit_realtime.Alert.image_alternative_text:type_name -> transit_realtime.TranslatedString
	22, // 32: transit_realtime.Alert.cause_detail:type_name -> transit_realtime.TranslatedString
	22, // 33: transit_realtime.Alert.effect_detail:type_name -> transit_realtime.TranslatedString
	8,  // 34: transit_realtime.TripDescriptor.schedule_relationship:type_name -> transit_realtime.TripDescriptor.ScheduleRelationship
	34, // 35: transit_realtime.TripDescriptor.modified_trip:type_name -> transit_realtime.TripDescriptor.ModifiedTripSelector
	9,  // 36: transit_realtime.VehicleDescriptor.wheelchair_accessible:type_name -> transit_realtime.VehicleDescriptor.WheelchairAccessible
	19, // 37: transit_realtime.EntitySelector.trip:type_name -> transit_realtime.TripDescriptor
	35, // 38: transit_realtime.TranslatedString.translation:type_name -> transit_realtime.TranslatedString.Translation
	36, // 39: transit_realtime.TranslatedImage.localized_image:type_name -> transit_realtime.TranslatedImage.LocalizedImage
	22, // 40: transit_realtime.Stop.stop_code:type_name -> transit_realtime.TranslatedString
	22, // 41: transit_realtime.Stop.stop_name:type_name -> transit_realtime.TranslatedString
	22, // 42: transit_realtime.Stop.tts_stop_name:type_name -> transit_realtime.TranslatedString
	22, // 43: transit_realtime.Stop.stop_desc:type_name -> transit_realtime.TranslatedString
	22, // 44: transit_realtime.Stop.stop_url:type_name -> transit_realtime.TranslatedString
	10, // 45: transit_realtime.Stop.wheelchair_boarding:type_name -> transit_realtime.Stop.WheelchairBoarding
	22, // 46: transit_realtime.Stop.platform_code:type_name -> transit_realtime.TranslatedString
	38, // 47: transit_realtime.TripModifications.selected_trips:type_name -> transit_realtime.TripModifications.SelectedTrips
	37, // 48: transit_realtime.TripModifications.modifications:type_name -> transit_realtime.TripModifications.Modification
	29, // 49: transit_realtime.TripUpdate.StopTimeUpdate.arrival:type_name -> transit_realtime.TripUpdate.StopTimeEvent
	29, // 50: transit_realtime.TripUpdate.StopTimeUpdate.departure:type_name -> transit_realtime.TripUpdate.StopTimeEvent
	4,  // 51: transit_realtime.TripUpdate.StopTimeUpdate.departure_occupancy_status:type_name -> transit_realtime.VehiclePosition.OccupancyStatus
	1,  // 52: transit_realtime.TripUpdate.StopTimeUpdate.schedule_relationship:type_name -> transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship
	32, // 53: transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties:type_name -> transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties
	4,  // 54: transit_realtime.VehiclePosition.CarriageDetails.occupancy_status:type_name -> transit_realtime.VehiclePosition.OccupancyStatus
	27, // 55: transit_realtime.TripModifications.Modification.start_stop_selector:type_name -> transit_realtime.StopSelector
	27, // 56: transit_realtime.TripModifications.Modification.end_stop_selector:type_name -> transit_realtime.StopSelector
	28, // 57: transit_realtime.TripModifications.Modification.replacement_stops:type_name -> transit_realtime.ReplacementStop
	58, // [58:58] is the sub-list for method output_type
	58, // [58:58] is the sub-list for method input_type
	58, // [58:58] is the sub-list for extension type_name
	58, // [58:58] is the sub-list for extension extendee
	0,  // [0:58] is the sub-list for field type_name
}

func init() { file_gtfs_realtime_proto_init() }
func file_gtfs_realtime_proto_init() {
	if File_gtfs_realtime_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_gtfs_realtime_proto_rawDesc), len(file_gtfs_realtime_proto_rawDesc)),
			NumEnums:      11,
			NumMessages:   28,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_gtfs_realtime_proto_goTypes,
		DependencyIndexes: file_gtfs_realtime_proto_depIdxs,
		EnumInfos:         file_gtfs_realtime_proto_enumTypes,
		MessageInfos:      file_gtfs_realtime_proto_msgTypes,
	}.Build()
	File_gtfs_realtime_proto = out.File
	file_gtfs_realtime_proto_goTypes = nil
	file_gtfs_realtime_proto_depIdxs = nil
}
