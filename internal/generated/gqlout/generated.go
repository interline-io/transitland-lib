// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlout

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/interline-io/transitland-lib/server/model"
	"github.com/interline-io/transitland-lib/tt"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Agency() AgencyResolver
	BookingRule() BookingRuleResolver
	Calendar() CalendarResolver
	CensusDataset() CensusDatasetResolver
	CensusGeography() CensusGeographyResolver
	CensusLayer() CensusLayerResolver
	CensusSource() CensusSourceResolver
	CensusTable() CensusTableResolver
	CensusValue() CensusValueResolver
	Feed() FeedResolver
	FeedState() FeedStateResolver
	FeedVersion() FeedVersionResolver
	FeedVersionGtfsImport() FeedVersionGtfsImportResolver
	FlexStopTime() FlexStopTimeResolver
	Level() LevelResolver
	Location() LocationResolver
	LocationGroup() LocationGroupResolver
	LocationGroupStop() LocationGroupStopResolver
	Mutation() MutationResolver
	Operator() OperatorResolver
	Pathway() PathwayResolver
	Place() PlaceResolver
	Query() QueryResolver
	Route() RouteResolver
	RouteHeadway() RouteHeadwayResolver
	RouteStop() RouteStopResolver
	RouteStopPattern() RouteStopPatternResolver
	Segment() SegmentResolver
	SegmentPattern() SegmentPatternResolver
	Stop() StopResolver
	StopExternalReference() StopExternalReferenceResolver
	StopTime() StopTimeResolver
	Trip() TripResolver
	ValidationReport() ValidationReportResolver
	ValidationReportErrorGroup() ValidationReportErrorGroupResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Agency struct {
		AgencyEmail       func(childComplexity int) int
		AgencyFareURL     func(childComplexity int) int
		AgencyID          func(childComplexity int) int
		AgencyLang        func(childComplexity int) int
		AgencyName        func(childComplexity int) int
		AgencyPhone       func(childComplexity int) int
		AgencyTimezone    func(childComplexity int) int
		AgencyURL         func(childComplexity int) int
		Alerts            func(childComplexity int, active *bool, limit *int) int
		CensusGeographies func(childComplexity int, limit *int, where *model.CensusGeographyFilter) int
		FeedOnestopID     func(childComplexity int) int
		FeedVersion       func(childComplexity int) int
		FeedVersionSHA1   func(childComplexity int) int
		Geometry          func(childComplexity int) int
		ID                func(childComplexity int) int
		OnestopID         func(childComplexity int) int
		Operator          func(childComplexity int) int
		Places            func(childComplexity int, limit *int, where *model.AgencyPlaceFilter) int
		Routes            func(childComplexity int, limit *int, where *model.RouteFilter) int
		SearchRank        func(childComplexity int) int
	}

	AgencyPlace struct {
		Adm0Iso  func(childComplexity int) int
		Adm0Name func(childComplexity int) int
		Adm1Iso  func(childComplexity int) int
		Adm1Name func(childComplexity int) int
		CityName func(childComplexity int) int
		Rank     func(childComplexity int) int
	}

	Alert struct {
		ActivePeriod       func(childComplexity int) int
		Cause              func(childComplexity int) int
		DescriptionText    func(childComplexity int) int
		Effect             func(childComplexity int) int
		HeaderText         func(childComplexity int) int
		SeverityLevel      func(childComplexity int) int
		TtsDescriptionText func(childComplexity int) int
		TtsHeaderText      func(childComplexity int) int
		URL                func(childComplexity int) int
	}

	BookingRule struct {
		BookingRuleID          func(childComplexity int) int
		BookingType            func(childComplexity int) int
		BookingURL             func(childComplexity int) int
		DropOffMessage         func(childComplexity int) int
		FeedOnestopID          func(childComplexity int) int
		FeedVersion            func(childComplexity int) int
		FeedVersionSHA1        func(childComplexity int) int
		ID                     func(childComplexity int) int
		InfoURL                func(childComplexity int) int
		Message                func(childComplexity int) int
		PhoneNumber            func(childComplexity int) int
		PickupMessage          func(childComplexity int) int
		PriorNoticeDurationMax func(childComplexity int) int
		PriorNoticeDurationMin func(childComplexity int) int
		PriorNoticeLastDay     func(childComplexity int) int
		PriorNoticeLastTime    func(childComplexity int) int
		PriorNoticeService     func(childComplexity int) int
		PriorNoticeStartDay    func(childComplexity int) int
		PriorNoticeStartTime   func(childComplexity int) int
	}

	Calendar struct {
		AddedDates   func(childComplexity int, limit *int) int
		EndDate      func(childComplexity int) int
		Friday       func(childComplexity int) int
		ID           func(childComplexity int) int
		Monday       func(childComplexity int) int
		RemovedDates func(childComplexity int, limit *int) int
		Saturday     func(childComplexity int) int
		ServiceID    func(childComplexity int) int
		StartDate    func(childComplexity int) int
		Sunday       func(childComplexity int) int
		Thursday     func(childComplexity int) int
		Tuesday      func(childComplexity int) int
		Wednesday    func(childComplexity int) int
	}

	CensusDataset struct {
		Description func(childComplexity int) int
		Geographies func(childComplexity int, limit *int, where *model.CensusDatasetGeographyFilter) int
		ID          func(childComplexity int) int
		Layers      func(childComplexity int) int
		Name        func(childComplexity int) int
		Sources     func(childComplexity int, limit *int, where *model.CensusSourceFilter) int
		Tables      func(childComplexity int, limit *int, where *model.CensusTableFilter) int
		URL         func(childComplexity int) int
		YearMax     func(childComplexity int) int
		YearMin     func(childComplexity int) int
	}

	CensusField struct {
		ColumnOrder func(childComplexity int) int
		FieldName   func(childComplexity int) int
		FieldTitle  func(childComplexity int) int
		ID          func(childComplexity int) int
	}

	CensusGeography struct {
		Adm0Iso              func(childComplexity int) int
		Adm0Name             func(childComplexity int) int
		Adm1Iso              func(childComplexity int) int
		Adm1Name             func(childComplexity int) int
		Aland                func(childComplexity int) int
		Awater               func(childComplexity int) int
		DatasetName          func(childComplexity int) int
		Geoid                func(childComplexity int) int
		Geometry             func(childComplexity int) int
		GeometryArea         func(childComplexity int) int
		ID                   func(childComplexity int) int
		IntersectionArea     func(childComplexity int) int
		IntersectionGeometry func(childComplexity int) int
		Layer                func(childComplexity int) int
		LayerName            func(childComplexity int) int
		Name                 func(childComplexity int) int
		Source               func(childComplexity int) int
		SourceName           func(childComplexity int) int
		Values               func(childComplexity int, tableNames []string, dataset *string, limit *int) int
	}

	CensusLayer struct {
		Description func(childComplexity int) int
		Geographies func(childComplexity int, limit *int, where *model.CensusSourceGeographyFilter) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	CensusSource struct {
		Description func(childComplexity int) int
		Geographies func(childComplexity int, limit *int, where *model.CensusSourceGeographyFilter) int
		ID          func(childComplexity int) int
		Layers      func(childComplexity int) int
		Name        func(childComplexity int) int
		Sha1        func(childComplexity int) int
		Tables      func(childComplexity int, limit *int) int
		URL         func(childComplexity int) int
	}

	CensusTable struct {
		Fields       func(childComplexity int) int
		ID           func(childComplexity int) int
		TableDetails func(childComplexity int) int
		TableGroup   func(childComplexity int) int
		TableName    func(childComplexity int) int
		TableTitle   func(childComplexity int) int
	}

	CensusValue struct {
		DatasetName func(childComplexity int) int
		Geoid       func(childComplexity int) int
		SourceName  func(childComplexity int) int
		Table       func(childComplexity int) int
		Values      func(childComplexity int) int
	}

	Directions struct {
		DataSource  func(childComplexity int) int
		Destination func(childComplexity int) int
		Distance    func(childComplexity int) int
		Duration    func(childComplexity int) int
		EndTime     func(childComplexity int) int
		Exception   func(childComplexity int) int
		Itineraries func(childComplexity int) int
		Origin      func(childComplexity int) int
		StartTime   func(childComplexity int) int
		Success     func(childComplexity int) int
	}

	Distance struct {
		Distance func(childComplexity int) int
		Units    func(childComplexity int) int
	}

	Duration struct {
		Duration func(childComplexity int) int
		Units    func(childComplexity int) int
	}

	EntityDeleteResult struct {
		ID func(childComplexity int) int
	}

	Feed struct {
		AssociatedOperators func(childComplexity int) int
		Authorization       func(childComplexity int) int
		FeedFetches         func(childComplexity int, limit *int, where *model.FeedFetchFilter) int
		FeedID              func(childComplexity int) int
		FeedState           func(childComplexity int) int
		FeedVersions        func(childComplexity int, limit *int, where *model.FeedVersionFilter) int
		File                func(childComplexity int) int
		ID                  func(childComplexity int) int
		Languages           func(childComplexity int) int
		License             func(childComplexity int) int
		Name                func(childComplexity int) int
		SearchRank          func(childComplexity int) int
		Spec                func(childComplexity int) int
		Tags                func(childComplexity int) int
		Urls                func(childComplexity int) int
	}

	FeedAuthorization struct {
		InfoURL   func(childComplexity int) int
		ParamName func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	FeedFetch struct {
		FetchError   func(childComplexity int) int
		FetchedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		ResponseCode func(childComplexity int) int
		ResponseSha1 func(childComplexity int) int
		ResponseSize func(childComplexity int) int
		Success      func(childComplexity int) int
		URL          func(childComplexity int) int
		URLType      func(childComplexity int) int
	}

	FeedInfo struct {
		DefaultLang       func(childComplexity int) int
		FeedContactEmail  func(childComplexity int) int
		FeedContactURL    func(childComplexity int) int
		FeedEndDate       func(childComplexity int) int
		FeedLang          func(childComplexity int) int
		FeedPublisherName func(childComplexity int) int
		FeedPublisherURL  func(childComplexity int) int
		FeedStartDate     func(childComplexity int) int
		FeedVersion       func(childComplexity int) int
		ID                func(childComplexity int) int
	}

	FeedLicense struct {
		AttributionInstructions func(childComplexity int) int
		AttributionText         func(childComplexity int) int
		CommercialUseAllowed    func(childComplexity int) int
		CreateDerivedProduct    func(childComplexity int) int
		RedistributionAllowed   func(childComplexity int) int
		ShareAlikeOptional      func(childComplexity int) int
		SpdxIdentifier          func(childComplexity int) int
		URL                     func(childComplexity int) int
		UseWithoutAttribution   func(childComplexity int) int
	}

	FeedState struct {
		FeedVersion func(childComplexity int) int
		ID          func(childComplexity int) int
	}

	FeedUrls struct {
		GbfsAutoDiscovery        func(childComplexity int) int
		MdsProvider              func(childComplexity int) int
		RealtimeAlerts           func(childComplexity int) int
		RealtimeTripUpdates      func(childComplexity int) int
		RealtimeVehiclePositions func(childComplexity int) int
		StaticCurrent            func(childComplexity int) int
		StaticHistoric           func(childComplexity int) int
		StaticPlanned            func(childComplexity int) int
	}

	FeedVersion struct {
		Agencies              func(childComplexity int, limit *int, where *model.AgencyFilter) int
		BookingRules          func(childComplexity int, limit *int, where *model.BookingRuleFilter) int
		CreatedBy             func(childComplexity int) int
		Description           func(childComplexity int) int
		EarliestCalendarDate  func(childComplexity int) int
		Feed                  func(childComplexity int) int
		FeedInfos             func(childComplexity int, limit *int) int
		FeedVersionGtfsImport func(childComplexity int) int
		FetchedAt             func(childComplexity int) int
		File                  func(childComplexity int) int
		Files                 func(childComplexity int, limit *int) int
		Geometry              func(childComplexity int) int
		ID                    func(childComplexity int) int
		LatestCalendarDate    func(childComplexity int) int
		LocationGroups        func(childComplexity int, limit *int, where *model.LocationGroupFilter) int
		Locations             func(childComplexity int, limit *int, where *model.LocationFilter) int
		Name                  func(childComplexity int) int
		Routes                func(childComplexity int, limit *int, where *model.RouteFilter) int
		SHA1                  func(childComplexity int) int
		Segments              func(childComplexity int, limit *int) int
		ServiceLevels         func(childComplexity int, limit *int, where *model.FeedVersionServiceLevelFilter) int
		ServiceWindow         func(childComplexity int) int
		Stops                 func(childComplexity int, limit *int, where *model.StopFilter) int
		Trips                 func(childComplexity int, limit *int, where *model.TripFilter) int
		URL                   func(childComplexity int) int
		UpdatedBy             func(childComplexity int) int
		ValidationReports     func(childComplexity int, limit *int, where *model.ValidationReportFilter) int
	}

	FeedVersionDeleteResult struct {
		Success func(childComplexity int) int
	}

	FeedVersionFetchResult struct {
		FeedVersion  func(childComplexity int) int
		FetchError   func(childComplexity int) int
		FoundDirSha1 func(childComplexity int) int
		FoundSha1    func(childComplexity int) int
	}

	FeedVersionFileInfo struct {
		CSVLike      func(childComplexity int) int
		Header       func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Rows         func(childComplexity int) int
		SHA1         func(childComplexity int) int
		Size         func(childComplexity int) int
		ValuesCount  func(childComplexity int) int
		ValuesUnique func(childComplexity int) int
	}

	FeedVersionGtfsImport struct {
		CreatedAt                 func(childComplexity int) int
		EntityCount               func(childComplexity int) int
		ExceptionLog              func(childComplexity int) int
		ID                        func(childComplexity int) int
		InProgress                func(childComplexity int) int
		InterpolatedStopTimeCount func(childComplexity int) int
		ScheduleRemoved           func(childComplexity int) int
		SkipEntityErrorCount      func(childComplexity int) int
		SkipEntityFilterCount     func(childComplexity int) int
		SkipEntityMarkedCount     func(childComplexity int) int
		SkipEntityReferenceCount  func(childComplexity int) int
		Success                   func(childComplexity int) int
		UpdatedAt                 func(childComplexity int) int
		WarningCount              func(childComplexity int) int
	}

	FeedVersionImportResult struct {
		Success func(childComplexity int) int
	}

	FeedVersionServiceLevel struct {
		EndDate   func(childComplexity int) int
		Friday    func(childComplexity int) int
		ID        func(childComplexity int) int
		Monday    func(childComplexity int) int
		Saturday  func(childComplexity int) int
		StartDate func(childComplexity int) int
		Sunday    func(childComplexity int) int
		Thursday  func(childComplexity int) int
		Tuesday   func(childComplexity int) int
		Wednesday func(childComplexity int) int
	}

	FeedVersionServiceWindow struct {
		DefaultTimezone      func(childComplexity int) int
		EarliestCalendarDate func(childComplexity int) int
		FallbackWeek         func(childComplexity int) int
		FeedEndDate          func(childComplexity int) int
		FeedStartDate        func(childComplexity int) int
		ID                   func(childComplexity int) int
		LatestCalendarDate   func(childComplexity int) int
	}

	FeedVersionUnimportResult struct {
		Success func(childComplexity int) int
	}

	FlexStopTime struct {
		Arrival                  func(childComplexity int) int
		ArrivalTime              func(childComplexity int) int
		ContinuousDropOff        func(childComplexity int) int
		ContinuousPickup         func(childComplexity int) int
		Date                     func(childComplexity int) int
		Departure                func(childComplexity int) int
		DepartureTime            func(childComplexity int) int
		DropOffBookingRule       func(childComplexity int) int
		DropOffType              func(childComplexity int) int
		EndPickupDropOffWindow   func(childComplexity int) int
		Interpolated             func(childComplexity int) int
		Location                 func(childComplexity int) int
		LocationGroup            func(childComplexity int) int
		PickupBookingRule        func(childComplexity int) int
		PickupType               func(childComplexity int) int
		ScheduleRelationship     func(childComplexity int) int
		ServiceDate              func(childComplexity int) int
		ShapeDistTraveled        func(childComplexity int) int
		StartPickupDropOffWindow func(childComplexity int) int
		StopHeadsign             func(childComplexity int) int
		StopSequence             func(childComplexity int) int
		Timepoint                func(childComplexity int) int
		Trip                     func(childComplexity int) int
	}

	Frequency struct {
		EndTime     func(childComplexity int) int
		ExactTimes  func(childComplexity int) int
		HeadwaySecs func(childComplexity int) int
		ID          func(childComplexity int) int
		StartTime   func(childComplexity int) int
	}

	GbfsAlertTime struct {
		End   func(childComplexity int) int
		Start func(childComplexity int) int
	}

	GbfsBrandAsset struct {
		BrandImageURL     func(childComplexity int) int
		BrandImageURLDark func(childComplexity int) int
		BrandLastModified func(childComplexity int) int
		BrandTermsURL     func(childComplexity int) int
		Color             func(childComplexity int) int
	}

	GbfsFeed struct {
		Alerts             func(childComplexity int) int
		Calendars          func(childComplexity int) int
		RentalHours        func(childComplexity int) int
		StationInformation func(childComplexity int) int
		SystemInformation  func(childComplexity int) int
	}

	GbfsFreeBikeStatus struct {
		AvailableUntil     func(childComplexity int) int
		BikeID             func(childComplexity int) int
		CurrentFuelPercent func(childComplexity int) int
		CurrentRangeMeters func(childComplexity int) int
		Feed               func(childComplexity int) int
		HomeStation        func(childComplexity int) int
		IsDisabled         func(childComplexity int) int
		IsReserved         func(childComplexity int) int
		LastReported       func(childComplexity int) int
		Lat                func(childComplexity int) int
		Lon                func(childComplexity int) int
		PricingPlan        func(childComplexity int) int
		RentalUris         func(childComplexity int) int
		Station            func(childComplexity int) int
		VehicleEquipment   func(childComplexity int) int
		VehicleType        func(childComplexity int) int
	}

	GbfsGeofenceFeature struct {
		Geometry func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	GbfsGeofenceProperty struct {
		End   func(childComplexity int) int
		Name  func(childComplexity int) int
		Rules func(childComplexity int) int
		Start func(childComplexity int) int
	}

	GbfsGeofenceRule struct {
		MaximumSpeedKph    func(childComplexity int) int
		RideAllowed        func(childComplexity int) int
		RideThroughAllowed func(childComplexity int) int
		StationParking     func(childComplexity int) int
		VehicleType        func(childComplexity int) int
	}

	GbfsGeofenceZone struct {
		Features func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	GbfsPlanPrice struct {
		End      func(childComplexity int) int
		Interval func(childComplexity int) int
		Rate     func(childComplexity int) int
		Start    func(childComplexity int) int
	}

	GbfsRentalApp struct {
		DiscoveryURI func(childComplexity int) int
		StoreURI     func(childComplexity int) int
	}

	GbfsRentalApps struct {
		Android func(childComplexity int) int
		Ios     func(childComplexity int) int
	}

	GbfsRentalUris struct {
		Android func(childComplexity int) int
		IOS     func(childComplexity int) int
		Web     func(childComplexity int) int
	}

	GbfsStationInformation struct {
		Address           func(childComplexity int) int
		Capacity          func(childComplexity int) int
		ContactPhone      func(childComplexity int) int
		CrossStreet       func(childComplexity int) int
		Feed              func(childComplexity int) int
		IsChargingStation func(childComplexity int) int
		IsValetStation    func(childComplexity int) int
		IsVirtualStation  func(childComplexity int) int
		Lat               func(childComplexity int) int
		Lon               func(childComplexity int) int
		Name              func(childComplexity int) int
		ParkingHoop       func(childComplexity int) int
		ParkingType       func(childComplexity int) int
		PostCode          func(childComplexity int) int
		Region            func(childComplexity int) int
		RentalMethods     func(childComplexity int) int
		ShortName         func(childComplexity int) int
		StationArea       func(childComplexity int) int
		StationID         func(childComplexity int) int
		Status            func(childComplexity int) int
	}

	GbfsStationStatus struct {
		IsInstalled           func(childComplexity int) int
		IsRenting             func(childComplexity int) int
		IsReturning           func(childComplexity int) int
		LastReported          func(childComplexity int) int
		NumBikesAvailable     func(childComplexity int) int
		NumBikesDisabled      func(childComplexity int) int
		NumDocksAvailable     func(childComplexity int) int
		NumDocksDisabled      func(childComplexity int) int
		StationID             func(childComplexity int) int
		VehicleDocksAvailable func(childComplexity int) int
		VehicleTypesAvailable func(childComplexity int) int
	}

	GbfsSystemAlert struct {
		AlertID     func(childComplexity int) int
		Description func(childComplexity int) int
		LastUpdated func(childComplexity int) int
		Summary     func(childComplexity int) int
		Times       func(childComplexity int) int
		Type        func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	GbfsSystemCalendar struct {
		EndDay     func(childComplexity int) int
		EndMonth   func(childComplexity int) int
		EndYear    func(childComplexity int) int
		StartDay   func(childComplexity int) int
		StartMonth func(childComplexity int) int
		StartYear  func(childComplexity int) int
	}

	GbfsSystemHour struct {
		Days      func(childComplexity int) int
		EndTime   func(childComplexity int) int
		StartTime func(childComplexity int) int
		UserTypes func(childComplexity int) int
	}

	GbfsSystemInformation struct {
		BrandAssets        func(childComplexity int) int
		Email              func(childComplexity int) int
		FeedContactEmail   func(childComplexity int) int
		Language           func(childComplexity int) int
		LicenseURL         func(childComplexity int) int
		Name               func(childComplexity int) int
		Operator           func(childComplexity int) int
		PhoneNumber        func(childComplexity int) int
		PrivacyLastUpdated func(childComplexity int) int
		PrivacyURL         func(childComplexity int) int
		PurchaseURL        func(childComplexity int) int
		RentalApps         func(childComplexity int) int
		ShortName          func(childComplexity int) int
		StartDate          func(childComplexity int) int
		SystemID           func(childComplexity int) int
		TermsLastUpdated   func(childComplexity int) int
		TermsURL           func(childComplexity int) int
		Timezone           func(childComplexity int) int
		URL                func(childComplexity int) int
	}

	GbfsSystemPricingPlan struct {
		Currency      func(childComplexity int) int
		Description   func(childComplexity int) int
		IsTaxable     func(childComplexity int) int
		Name          func(childComplexity int) int
		PerKmPricing  func(childComplexity int) int
		PerMinPricing func(childComplexity int) int
		PlanID        func(childComplexity int) int
		Price         func(childComplexity int) int
		SurgePricing  func(childComplexity int) int
		URL           func(childComplexity int) int
	}

	GbfsSystemRegion struct {
		Name     func(childComplexity int) int
		RegionID func(childComplexity int) int
	}

	GbfsSystemVersion struct {
		URL     func(childComplexity int) int
		Version func(childComplexity int) int
	}

	GbfsVehicleAssets struct {
		IconLastModified func(childComplexity int) int
		IconURL          func(childComplexity int) int
		IconURLDark      func(childComplexity int) int
	}

	GbfsVehicleDockAvailable struct {
		Count        func(childComplexity int) int
		VehicleTypes func(childComplexity int) int
	}

	GbfsVehicleType struct {
		CargoLoadCapacity   func(childComplexity int) int
		CargoVolumeCapacity func(childComplexity int) int
		Color               func(childComplexity int) int
		CountryCode         func(childComplexity int) int
		DefaultPricingPlan  func(childComplexity int) int
		DefaultReserveTime  func(childComplexity int) int
		EcoLabel            func(childComplexity int) int
		EcoSticker          func(childComplexity int) int
		FormFactor          func(childComplexity int) int
		GCO2Km              func(childComplexity int) int
		Make                func(childComplexity int) int
		MaxPermittedSpeed   func(childComplexity int) int
		MaxRangeMeters      func(childComplexity int) int
		Model               func(childComplexity int) int
		Name                func(childComplexity int) int
		PricingPlans        func(childComplexity int) int
		PropulsionType      func(childComplexity int) int
		RatedPower          func(childComplexity int) int
		RentalUris          func(childComplexity int) int
		ReturnConstraint    func(childComplexity int) int
		RiderCapacity       func(childComplexity int) int
		VehicleAccessories  func(childComplexity int) int
		VehicleAssets       func(childComplexity int) int
		VehicleImage        func(childComplexity int) int
		VehicleTypeID       func(childComplexity int) int
		WheelCount          func(childComplexity int) int
	}

	GbfsVehicleTypeAvailable struct {
		Count             func(childComplexity int) int
		NumBikesDisabled  func(childComplexity int) int
		NumDocksAvailable func(childComplexity int) int
		VehicleType       func(childComplexity int) int
	}

	Itinerary struct {
		Distance  func(childComplexity int) int
		Duration  func(childComplexity int) int
		EndTime   func(childComplexity int) int
		From      func(childComplexity int) int
		Legs      func(childComplexity int) int
		StartTime func(childComplexity int) int
		To        func(childComplexity int) int
	}

	Leg struct {
		Distance  func(childComplexity int) int
		Duration  func(childComplexity int) int
		EndTime   func(childComplexity int) int
		From      func(childComplexity int) int
		Geometry  func(childComplexity int) int
		Mode      func(childComplexity int) int
		StartTime func(childComplexity int) int
		Steps     func(childComplexity int) int
		Stops     func(childComplexity int) int
		To        func(childComplexity int) int
		Trip      func(childComplexity int) int
	}

	LegRoute struct {
		Agency         func(childComplexity int) int
		RouteColor     func(childComplexity int) int
		RouteID        func(childComplexity int) int
		RouteLongName  func(childComplexity int) int
		RouteOnestopID func(childComplexity int) int
		RouteShortName func(childComplexity int) int
		RouteTextColor func(childComplexity int) int
		RouteType      func(childComplexity int) int
	}

	LegRouteAgency struct {
		AgencyID        func(childComplexity int) int
		AgencyName      func(childComplexity int) int
		AgencyOnestopID func(childComplexity int) int
	}

	LegTrip struct {
		FeedID          func(childComplexity int) int
		FeedVersionSha1 func(childComplexity int) int
		Headsign        func(childComplexity int) int
		Route           func(childComplexity int) int
		TripID          func(childComplexity int) int
		TripShortName   func(childComplexity int) int
	}

	Level struct {
		Geometry   func(childComplexity int) int
		ID         func(childComplexity int) int
		LevelID    func(childComplexity int) int
		LevelIndex func(childComplexity int) int
		LevelName  func(childComplexity int) int
		Stops      func(childComplexity int) int
	}

	Location struct {
		FeedOnestopID   func(childComplexity int) int
		FeedVersion     func(childComplexity int) int
		FeedVersionSHA1 func(childComplexity int) int
		Geometry        func(childComplexity int) int
		ID              func(childComplexity int) int
		LocationID      func(childComplexity int) int
		StopDesc        func(childComplexity int) int
		StopName        func(childComplexity int) int
		StopTimes       func(childComplexity int, limit *int, where *model.StopTimeFilter) int
		StopURL         func(childComplexity int) int
		ZoneID          func(childComplexity int) int
	}

	LocationGroup struct {
		FeedOnestopID     func(childComplexity int) int
		FeedVersion       func(childComplexity int) int
		FeedVersionSHA1   func(childComplexity int) int
		ID                func(childComplexity int) int
		LocationGroupID   func(childComplexity int) int
		LocationGroupName func(childComplexity int) int
		StopTimes         func(childComplexity int, limit *int, where *model.StopTimeFilter) int
		Stops             func(childComplexity int, limit *int) int
	}

	LocationGroupStop struct {
		ID            func(childComplexity int) int
		LocationGroup func(childComplexity int) int
		Stop          func(childComplexity int) int
	}

	Me struct {
		Email        func(childComplexity int) int
		ExternalData func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Roles        func(childComplexity int) int
	}

	Mutation struct {
		FeedVersionDelete   func(childComplexity int, id int) int
		FeedVersionFetch    func(childComplexity int, file *graphql.Upload, url *string, feedOnestopID string) int
		FeedVersionImport   func(childComplexity int, id int) int
		FeedVersionUnimport func(childComplexity int, id int) int
		FeedVersionUpdate   func(childComplexity int, set model.FeedVersionSetInput) int
		LevelCreate         func(childComplexity int, set model.LevelSetInput) int
		LevelDelete         func(childComplexity int, id int) int
		LevelUpdate         func(childComplexity int, set model.LevelSetInput) int
		PathwayCreate       func(childComplexity int, set model.PathwaySetInput) int
		PathwayDelete       func(childComplexity int, id int) int
		PathwayUpdate       func(childComplexity int, set model.PathwaySetInput) int
		StopCreate          func(childComplexity int, set model.StopSetInput) int
		StopDelete          func(childComplexity int, id int) int
		StopUpdate          func(childComplexity int, set model.StopSetInput) int
		ValidateGtfs        func(childComplexity int, file *graphql.Upload, url *string, realtimeUrls []string) int
	}

	Operator struct {
		Agencies   func(childComplexity int) int
		Feeds      func(childComplexity int, limit *int, where *model.FeedFilter) int
		File       func(childComplexity int) int
		Generated  func(childComplexity int) int
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		OnestopID  func(childComplexity int) int
		SearchRank func(childComplexity int) int
		ShortName  func(childComplexity int) int
		Tags       func(childComplexity int) int
		Website    func(childComplexity int) int
	}

	Pathway struct {
		FromStop            func(childComplexity int) int
		ID                  func(childComplexity int) int
		IsBidirectional     func(childComplexity int) int
		Length              func(childComplexity int) int
		MaxSlope            func(childComplexity int) int
		MinWidth            func(childComplexity int) int
		PathwayID           func(childComplexity int) int
		PathwayMode         func(childComplexity int) int
		ReverseSignpostedAs func(childComplexity int) int
		SignpostedAs        func(childComplexity int) int
		StairCount          func(childComplexity int) int
		ToStop              func(childComplexity int) int
		TraversalTime       func(childComplexity int) int
	}

	Place struct {
		Adm0Name  func(childComplexity int) int
		Adm1Name  func(childComplexity int) int
		CityName  func(childComplexity int) int
		Count     func(childComplexity int) int
		Operators func(childComplexity int) int
	}

	Query struct {
		Agencies       func(childComplexity int, limit *int, after *int, ids []int, where *model.AgencyFilter) int
		Bikes          func(childComplexity int, limit *int, where *model.GbfsBikeRequest) int
		CensusDatasets func(childComplexity int, limit *int, after *int, ids []int, where *model.CensusDatasetFilter) int
		CensusValues   func(childComplexity int, limit *int, where *model.CensusValueFilter) int
		Directions     func(childComplexity int, where model.DirectionRequest) int
		Docks          func(childComplexity int, limit *int, where *model.GbfsDockRequest) int
		FeedVersions   func(childComplexity int, limit *int, after *int, ids []int, where *model.FeedVersionFilter) int
		Feeds          func(childComplexity int, limit *int, after *int, ids []int, where *model.FeedFilter) int
		Me             func(childComplexity int) int
		Operators      func(childComplexity int, limit *int, after *int, ids []int, where *model.OperatorFilter) int
		Places         func(childComplexity int, limit *int, after *int, level *model.PlaceAggregationLevel, where *model.PlaceFilter) int
		Routes         func(childComplexity int, limit *int, after *int, ids []int, where *model.RouteFilter) int
		Stops          func(childComplexity int, limit *int, after *int, ids []int, where *model.StopFilter) int
		Trips          func(childComplexity int, limit *int, after *int, ids []int, where *model.TripFilter) int
	}

	RTTimeRange struct {
		End   func(childComplexity int) int
		Start func(childComplexity int) int
	}

	RTTranslation struct {
		Language func(childComplexity int) int
		Text     func(childComplexity int) int
	}

	RTTripDescriptor struct {
		DirectionID          func(childComplexity int) int
		RouteID              func(childComplexity int) int
		ScheduleRelationship func(childComplexity int) int
		StartDate            func(childComplexity int) int
		StartTime            func(childComplexity int) int
		TripID               func(childComplexity int) int
	}

	RTVehicleDescriptor struct {
		ID           func(childComplexity int) int
		Label        func(childComplexity int) int
		LicensePlate func(childComplexity int) int
	}

	Route struct {
		Agency            func(childComplexity int) int
		Alerts            func(childComplexity int, active *bool, limit *int) int
		CensusGeographies func(childComplexity int, limit *int, where *model.CensusGeographyFilter) int
		ContinuousDropOff func(childComplexity int) int
		ContinuousPickup  func(childComplexity int) int
		FeedOnestopID     func(childComplexity int) int
		FeedVersion       func(childComplexity int) int
		FeedVersionSHA1   func(childComplexity int) int
		Geometries        func(childComplexity int, limit *int) int
		Geometry          func(childComplexity int) int
		Headways          func(childComplexity int, limit *int) int
		ID                func(childComplexity int) int
		OnestopID         func(childComplexity int) int
		Patterns          func(childComplexity int) int
		RouteAttribute    func(childComplexity int) int
		RouteColor        func(childComplexity int) int
		RouteDesc         func(childComplexity int) int
		RouteID           func(childComplexity int) int
		RouteLongName     func(childComplexity int) int
		RouteShortName    func(childComplexity int) int
		RouteSortOrder    func(childComplexity int) int
		RouteStopBuffer   func(childComplexity int, radius *float64) int
		RouteStops        func(childComplexity int, limit *int) int
		RouteTextColor    func(childComplexity int) int
		RouteType         func(childComplexity int) int
		RouteURL          func(childComplexity int) int
		SearchRank        func(childComplexity int) int
		SegmentPatterns   func(childComplexity int, limit *int, where *model.SegmentPatternFilter) int
		Segments          func(childComplexity int, limit *int, where *model.SegmentFilter) int
		Stops             func(childComplexity int, limit *int, where *model.StopFilter) int
		Trips             func(childComplexity int, limit *int, where *model.TripFilter) int
	}

	RouteAttribute struct {
		Category    func(childComplexity int) int
		RunningWay  func(childComplexity int) int
		Subcategory func(childComplexity int) int
	}

	RouteGeometry struct {
		CombinedGeometry      func(childComplexity int) int
		FirstPointMaxDistance func(childComplexity int) int
		Generated             func(childComplexity int) int
		Geometry              func(childComplexity int) int
		Length                func(childComplexity int) int
		MaxSegmentLength      func(childComplexity int) int
	}

	RouteHeadway struct {
		Departures    func(childComplexity int) int
		DirectionID   func(childComplexity int) int
		DowCategory   func(childComplexity int) int
		HeadwaySecs   func(childComplexity int) int
		ServiceDate   func(childComplexity int) int
		Stop          func(childComplexity int) int
		StopTripCount func(childComplexity int) int
	}

	RouteStop struct {
		Agency   func(childComplexity int) int
		AgencyID func(childComplexity int) int
		ID       func(childComplexity int) int
		Route    func(childComplexity int) int
		RouteID  func(childComplexity int) int
		Stop     func(childComplexity int) int
		StopID   func(childComplexity int) int
	}

	RouteStopBuffer struct {
		StopBuffer     func(childComplexity int) int
		StopConvexhull func(childComplexity int) int
		StopPoints     func(childComplexity int) int
	}

	RouteStopPattern struct {
		Count         func(childComplexity int) int
		DirectionID   func(childComplexity int) int
		StopPatternID func(childComplexity int) int
		Trips         func(childComplexity int, limit *int) int
	}

	Segment struct {
		Geometry        func(childComplexity int) int
		ID              func(childComplexity int) int
		SegmentPatterns func(childComplexity int) int
		WayID           func(childComplexity int) int
	}

	SegmentPattern struct {
		ID            func(childComplexity int) int
		Route         func(childComplexity int) int
		Segment       func(childComplexity int) int
		StopPatternID func(childComplexity int) int
	}

	Shape struct {
		Generated func(childComplexity int) int
		Geometry  func(childComplexity int) int
		ID        func(childComplexity int) int
		ShapeID   func(childComplexity int) int
	}

	Step struct {
		Distance       func(childComplexity int) int
		Duration       func(childComplexity int) int
		EndTime        func(childComplexity int) int
		GeometryOffset func(childComplexity int) int
		Instruction    func(childComplexity int) int
		Mode           func(childComplexity int) int
		StartTime      func(childComplexity int) int
		To             func(childComplexity int) int
	}

	Stop struct {
		Alerts             func(childComplexity int, active *bool, limit *int) int
		Arrivals           func(childComplexity int, limit *int, where *model.StopTimeFilter) int
		CensusGeographies  func(childComplexity int, limit *int, where *model.CensusGeographyFilter) int
		ChildLevels        func(childComplexity int, limit *int) int
		Children           func(childComplexity int, limit *int) int
		Departures         func(childComplexity int, limit *int, where *model.StopTimeFilter) int
		Directions         func(childComplexity int, to *model.WaypointInput, from *model.WaypointInput, mode *model.StepMode, departAt *time.Time) int
		ExternalReference  func(childComplexity int) int
		FeedOnestopID      func(childComplexity int) int
		FeedVersion        func(childComplexity int) int
		FeedVersionSHA1    func(childComplexity int) int
		Geometry           func(childComplexity int) int
		ID                 func(childComplexity int) int
		Level              func(childComplexity int) int
		LocationGroups     func(childComplexity int, limit *int) int
		LocationType       func(childComplexity int) int
		NearbyStops        func(childComplexity int, limit *int, radius *float64) int
		Observations       func(childComplexity int, limit *int, where *model.StopObservationFilter) int
		OnestopID          func(childComplexity int) int
		Parent             func(childComplexity int) int
		PathwaysFromStop   func(childComplexity int, limit *int) int
		PathwaysToStop     func(childComplexity int, limit *int) int
		Place              func(childComplexity int) int
		PlatformCode       func(childComplexity int) int
		RouteStops         func(childComplexity int, limit *int) int
		SearchRank         func(childComplexity int) int
		StopCode           func(childComplexity int) int
		StopDesc           func(childComplexity int) int
		StopID             func(childComplexity int) int
		StopName           func(childComplexity int) int
		StopTimes          func(childComplexity int, limit *int, where *model.StopTimeFilter) int
		StopTimezone       func(childComplexity int) int
		StopURL            func(childComplexity int) int
		TtsStopName        func(childComplexity int) int
		WheelchairBoarding func(childComplexity int) int
		WithinFeatures     func(childComplexity int) int
		ZoneID             func(childComplexity int) int
	}

	StopExternalReference struct {
		ID                  func(childComplexity int) int
		Inactive            func(childComplexity int) int
		TargetActiveStop    func(childComplexity int) int
		TargetFeedOnestopID func(childComplexity int) int
		TargetStopID        func(childComplexity int) int
	}

	StopObservation struct {
		AgencyID               func(childComplexity int) int
		FromStopID             func(childComplexity int) int
		ObservedArrivalTime    func(childComplexity int) int
		ObservedDepartureTime  func(childComplexity int) int
		RouteID                func(childComplexity int) int
		ScheduleRelationship   func(childComplexity int) int
		ScheduledArrivalTime   func(childComplexity int) int
		ScheduledDepartureTime func(childComplexity int) int
		Source                 func(childComplexity int) int
		StopSequence           func(childComplexity int) int
		ToStopID               func(childComplexity int) int
		TripID                 func(childComplexity int) int
		TripStartDate          func(childComplexity int) int
		TripStartTime          func(childComplexity int) int
	}

	StopPlace struct {
		Adm0Iso  func(childComplexity int) int
		Adm0Name func(childComplexity int) int
		Adm1Iso  func(childComplexity int) int
		Adm1Name func(childComplexity int) int
	}

	StopTime struct {
		Arrival                  func(childComplexity int) int
		ArrivalTime              func(childComplexity int) int
		ContinuousDropOff        func(childComplexity int) int
		ContinuousPickup         func(childComplexity int) int
		Date                     func(childComplexity int) int
		Departure                func(childComplexity int) int
		DepartureTime            func(childComplexity int) int
		DropOffBookingRule       func(childComplexity int) int
		DropOffType              func(childComplexity int) int
		EndPickupDropOffWindow   func(childComplexity int) int
		Interpolated             func(childComplexity int) int
		PickupBookingRule        func(childComplexity int) int
		PickupType               func(childComplexity int) int
		ScheduleRelationship     func(childComplexity int) int
		ServiceDate              func(childComplexity int) int
		ShapeDistTraveled        func(childComplexity int) int
		StartPickupDropOffWindow func(childComplexity int) int
		Stop                     func(childComplexity int) int
		StopHeadsign             func(childComplexity int) int
		StopSequence             func(childComplexity int) int
		Timepoint                func(childComplexity int) int
		Trip                     func(childComplexity int) int
	}

	StopTimeEvent struct {
		Delay          func(childComplexity int) int
		Estimated      func(childComplexity int) int
		EstimatedDelay func(childComplexity int) int
		EstimatedLocal func(childComplexity int) int
		EstimatedUnix  func(childComplexity int) int
		EstimatedUtc   func(childComplexity int) int
		Scheduled      func(childComplexity int) int
		ScheduledLocal func(childComplexity int) int
		ScheduledUnix  func(childComplexity int) int
		ScheduledUtc   func(childComplexity int) int
		StopTimezone   func(childComplexity int) int
		TimeUnix       func(childComplexity int) int
		TimeUtc        func(childComplexity int) int
		Uncertainty    func(childComplexity int) int
	}

	Trip struct {
		Alerts               func(childComplexity int, active *bool, limit *int) int
		BikesAllowed         func(childComplexity int) int
		BlockID              func(childComplexity int) int
		Calendar             func(childComplexity int) int
		DirectionID          func(childComplexity int) int
		FeedVersion          func(childComplexity int) int
		FlexStopTimes        func(childComplexity int, limit *int, where *model.TripStopTimeFilter) int
		Frequencies          func(childComplexity int, limit *int) int
		ID                   func(childComplexity int) int
		Route                func(childComplexity int) int
		ScheduleRelationship func(childComplexity int) int
		Shape                func(childComplexity int) int
		StopPatternID        func(childComplexity int) int
		StopTimes            func(childComplexity int, limit *int, where *model.TripStopTimeFilter) int
		Timestamp            func(childComplexity int) int
		TripHeadsign         func(childComplexity int) int
		TripID               func(childComplexity int) int
		TripShortName        func(childComplexity int) int
		WheelchairAccessible func(childComplexity int) int
	}

	ValidationRealtimeResult struct {
		JSON func(childComplexity int) int
		URL  func(childComplexity int) int
	}

	ValidationReport struct {
		Details                 func(childComplexity int) int
		Errors                  func(childComplexity int, limit *int) int
		FailureReason           func(childComplexity int) int
		ID                      func(childComplexity int) int
		IncludesRt              func(childComplexity int) int
		IncludesStatic          func(childComplexity int) int
		ReportedAt              func(childComplexity int) int
		ReportedAtLocal         func(childComplexity int) int
		ReportedAtLocalTimezone func(childComplexity int) int
		Success                 func(childComplexity int) int
		Validator               func(childComplexity int) int
		ValidatorVersion        func(childComplexity int) int
		Warnings                func(childComplexity int, limit *int) int
	}

	ValidationReportDetails struct {
		Agencies             func(childComplexity int, limit *int) int
		EarliestCalendarDate func(childComplexity int) int
		FeedInfos            func(childComplexity int, limit *int) int
		Files                func(childComplexity int) int
		LatestCalendarDate   func(childComplexity int) int
		Realtime             func(childComplexity int) int
		Routes               func(childComplexity int, limit *int) int
		ServiceLevels        func(childComplexity int, limit *int, routeID *string) int
		Sha1                 func(childComplexity int) int
		Stops                func(childComplexity int, limit *int) int
	}

	ValidationReportError struct {
		EntityID   func(childComplexity int) int
		EntityJSON func(childComplexity int) int
		ErrorCode  func(childComplexity int) int
		ErrorType  func(childComplexity int) int
		Field      func(childComplexity int) int
		Filename   func(childComplexity int) int
		Geometry   func(childComplexity int) int
		GroupKey   func(childComplexity int) int
		Line       func(childComplexity int) int
		Message    func(childComplexity int) int
		Value      func(childComplexity int) int
	}

	ValidationReportErrorGroup struct {
		Count     func(childComplexity int) int
		ErrorCode func(childComplexity int) int
		ErrorType func(childComplexity int) int
		Errors    func(childComplexity int, limit *int) int
		Field     func(childComplexity int) int
		Filename  func(childComplexity int) int
		GroupKey  func(childComplexity int) int
	}

	VehiclePosition struct {
		CongestionLevel     func(childComplexity int) int
		CurrentStatus       func(childComplexity int) int
		CurrentStopSequence func(childComplexity int) int
		Position            func(childComplexity int) int
		StopID              func(childComplexity int) int
		Timestamp           func(childComplexity int) int
		Vehicle             func(childComplexity int) int
	}

	Waypoint struct {
		Lat  func(childComplexity int) int
		Lon  func(childComplexity int) int
		Name func(childComplexity int) int
		Stop func(childComplexity int) int
	}

	WaypointDeparture struct {
		Departure     func(childComplexity int) int
		Lat           func(childComplexity int) int
		Lon           func(childComplexity int) int
		StopCode      func(childComplexity int) int
		StopID        func(childComplexity int) int
		StopIndex     func(childComplexity int) int
		StopName      func(childComplexity int) int
		StopOnestopID func(childComplexity int) int
		StopSequence  func(childComplexity int) int
	}

	WaypointStop struct {
		Departure     func(childComplexity int) int
		Lat           func(childComplexity int) int
		Lon           func(childComplexity int) int
		StopCode      func(childComplexity int) int
		StopID        func(childComplexity int) int
		StopName      func(childComplexity int) int
		StopOnestopID func(childComplexity int) int
	}
}

type AgencyResolver interface {
	FeedVersion(ctx context.Context, obj *model.Agency) (*model.FeedVersion, error)

	Operator(ctx context.Context, obj *model.Agency) (*model.Operator, error)
	Places(ctx context.Context, obj *model.Agency, limit *int, where *model.AgencyPlaceFilter) ([]*model.AgencyPlace, error)
	Routes(ctx context.Context, obj *model.Agency, limit *int, where *model.RouteFilter) ([]*model.Route, error)
	CensusGeographies(ctx context.Context, obj *model.Agency, limit *int, where *model.CensusGeographyFilter) ([]*model.CensusGeography, error)
	Alerts(ctx context.Context, obj *model.Agency, active *bool, limit *int) ([]*model.Alert, error)
}
type BookingRuleResolver interface {
	PriorNoticeService(ctx context.Context, obj *model.BookingRule) (*model.Calendar, error)

	FeedVersion(ctx context.Context, obj *model.BookingRule) (*model.FeedVersion, error)
}
type CalendarResolver interface {
	AddedDates(ctx context.Context, obj *model.Calendar, limit *int) ([]*tt.Date, error)
	RemovedDates(ctx context.Context, obj *model.Calendar, limit *int) ([]*tt.Date, error)
}
type CensusDatasetResolver interface {
	Sources(ctx context.Context, obj *model.CensusDataset, limit *int, where *model.CensusSourceFilter) ([]*model.CensusSource, error)
	Geographies(ctx context.Context, obj *model.CensusDataset, limit *int, where *model.CensusDatasetGeographyFilter) ([]*model.CensusGeography, error)
	Tables(ctx context.Context, obj *model.CensusDataset, limit *int, where *model.CensusTableFilter) ([]*model.CensusTable, error)
	Layers(ctx context.Context, obj *model.CensusDataset) ([]*model.CensusLayer, error)
}
type CensusGeographyResolver interface {
	Values(ctx context.Context, obj *model.CensusGeography, tableNames []string, dataset *string, limit *int) ([]*model.CensusValue, error)
	Layer(ctx context.Context, obj *model.CensusGeography) (*model.CensusLayer, error)
	Source(ctx context.Context, obj *model.CensusGeography) (*model.CensusSource, error)
}
type CensusLayerResolver interface {
	Geographies(ctx context.Context, obj *model.CensusLayer, limit *int, where *model.CensusSourceGeographyFilter) ([]*model.CensusGeography, error)
}
type CensusSourceResolver interface {
	Geographies(ctx context.Context, obj *model.CensusSource, limit *int, where *model.CensusSourceGeographyFilter) ([]*model.CensusGeography, error)

	Layers(ctx context.Context, obj *model.CensusSource) ([]*model.CensusLayer, error)
}
type CensusTableResolver interface {
	Fields(ctx context.Context, obj *model.CensusTable) ([]*model.CensusField, error)
}
type CensusValueResolver interface {
	Table(ctx context.Context, obj *model.CensusValue) (*model.CensusTable, error)
}
type FeedResolver interface {
	Spec(ctx context.Context, obj *model.Feed) (*model.FeedSpecTypes, error)
	Languages(ctx context.Context, obj *model.Feed) ([]string, error)

	Authorization(ctx context.Context, obj *model.Feed) (*model.FeedAuthorization, error)
	Urls(ctx context.Context, obj *model.Feed) (*model.FeedUrls, error)
	License(ctx context.Context, obj *model.Feed) (*model.FeedLicense, error)

	AssociatedOperators(ctx context.Context, obj *model.Feed) ([]*model.Operator, error)
	FeedState(ctx context.Context, obj *model.Feed) (*model.FeedState, error)
	FeedFetches(ctx context.Context, obj *model.Feed, limit *int, where *model.FeedFetchFilter) ([]*model.FeedFetch, error)
	FeedVersions(ctx context.Context, obj *model.Feed, limit *int, where *model.FeedVersionFilter) ([]*model.FeedVersion, error)
}
type FeedStateResolver interface {
	FeedVersion(ctx context.Context, obj *model.FeedState) (*model.FeedVersion, error)
}
type FeedVersionResolver interface {
	Geometry(ctx context.Context, obj *model.FeedVersion) (*tt.Polygon, error)
	Feed(ctx context.Context, obj *model.FeedVersion) (*model.Feed, error)
	FeedVersionGtfsImport(ctx context.Context, obj *model.FeedVersion) (*model.FeedVersionGtfsImport, error)
	Files(ctx context.Context, obj *model.FeedVersion, limit *int) ([]*model.FeedVersionFileInfo, error)
	ServiceLevels(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.FeedVersionServiceLevelFilter) ([]*model.FeedVersionServiceLevel, error)
	ServiceWindow(ctx context.Context, obj *model.FeedVersion) (*model.FeedVersionServiceWindow, error)
	Agencies(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.AgencyFilter) ([]*model.Agency, error)
	Routes(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.RouteFilter) ([]*model.Route, error)
	Stops(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.StopFilter) ([]*model.Stop, error)
	Trips(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.TripFilter) ([]*model.Trip, error)
	Locations(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.LocationFilter) ([]*model.Location, error)
	BookingRules(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.BookingRuleFilter) ([]*model.BookingRule, error)
	LocationGroups(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.LocationGroupFilter) ([]*model.LocationGroup, error)
	FeedInfos(ctx context.Context, obj *model.FeedVersion, limit *int) ([]*model.FeedInfo, error)
	ValidationReports(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.ValidationReportFilter) ([]*model.ValidationReport, error)
	Segments(ctx context.Context, obj *model.FeedVersion, limit *int) ([]*model.Segment, error)
}
type FeedVersionGtfsImportResolver interface {
	SkipEntityErrorCount(ctx context.Context, obj *model.FeedVersionGtfsImport) (any, error)
	EntityCount(ctx context.Context, obj *model.FeedVersionGtfsImport) (any, error)
	WarningCount(ctx context.Context, obj *model.FeedVersionGtfsImport) (any, error)
	SkipEntityReferenceCount(ctx context.Context, obj *model.FeedVersionGtfsImport) (any, error)
	SkipEntityFilterCount(ctx context.Context, obj *model.FeedVersionGtfsImport) (any, error)
	SkipEntityMarkedCount(ctx context.Context, obj *model.FeedVersionGtfsImport) (any, error)
}
type FlexStopTimeResolver interface {
	PickupBookingRule(ctx context.Context, obj *model.StopTime) (*model.BookingRule, error)
	DropOffBookingRule(ctx context.Context, obj *model.StopTime) (*model.BookingRule, error)
	Location(ctx context.Context, obj *model.StopTime) (*model.Location, error)
	LocationGroup(ctx context.Context, obj *model.StopTime) (*model.LocationGroup, error)
	Trip(ctx context.Context, obj *model.StopTime) (*model.Trip, error)
	Arrival(ctx context.Context, obj *model.StopTime) (*model.StopTimeEvent, error)
	Departure(ctx context.Context, obj *model.StopTime) (*model.StopTimeEvent, error)

	ScheduleRelationship(ctx context.Context, obj *model.StopTime) (*model.ScheduleRelationship, error)
}
type LevelResolver interface {
	Stops(ctx context.Context, obj *model.Level) ([]*model.Stop, error)
}
type LocationResolver interface {
	FeedVersion(ctx context.Context, obj *model.Location) (*model.FeedVersion, error)
	StopTimes(ctx context.Context, obj *model.Location, limit *int, where *model.StopTimeFilter) ([]*model.StopTime, error)
}
type LocationGroupResolver interface {
	FeedVersion(ctx context.Context, obj *model.LocationGroup) (*model.FeedVersion, error)
	Stops(ctx context.Context, obj *model.LocationGroup, limit *int) ([]*model.Stop, error)
	StopTimes(ctx context.Context, obj *model.LocationGroup, limit *int, where *model.StopTimeFilter) ([]*model.StopTime, error)
}
type LocationGroupStopResolver interface {
	LocationGroup(ctx context.Context, obj *model.LocationGroupStop) (*model.LocationGroup, error)
	Stop(ctx context.Context, obj *model.LocationGroupStop) (*model.Stop, error)
}
type MutationResolver interface {
	ValidateGtfs(ctx context.Context, file *graphql.Upload, url *string, realtimeUrls []string) (*model.ValidationReport, error)
	FeedVersionUpdate(ctx context.Context, set model.FeedVersionSetInput) (*model.FeedVersion, error)
	FeedVersionFetch(ctx context.Context, file *graphql.Upload, url *string, feedOnestopID string) (*model.FeedVersionFetchResult, error)
	FeedVersionImport(ctx context.Context, id int) (*model.FeedVersionImportResult, error)
	FeedVersionUnimport(ctx context.Context, id int) (*model.FeedVersionUnimportResult, error)
	FeedVersionDelete(ctx context.Context, id int) (*model.FeedVersionDeleteResult, error)
	StopCreate(ctx context.Context, set model.StopSetInput) (*model.Stop, error)
	StopUpdate(ctx context.Context, set model.StopSetInput) (*model.Stop, error)
	StopDelete(ctx context.Context, id int) (*model.EntityDeleteResult, error)
	LevelCreate(ctx context.Context, set model.LevelSetInput) (*model.Level, error)
	LevelUpdate(ctx context.Context, set model.LevelSetInput) (*model.Level, error)
	LevelDelete(ctx context.Context, id int) (*model.EntityDeleteResult, error)
	PathwayCreate(ctx context.Context, set model.PathwaySetInput) (*model.Pathway, error)
	PathwayUpdate(ctx context.Context, set model.PathwaySetInput) (*model.Pathway, error)
	PathwayDelete(ctx context.Context, id int) (*model.EntityDeleteResult, error)
}
type OperatorResolver interface {
	Agencies(ctx context.Context, obj *model.Operator) ([]*model.Agency, error)
	Feeds(ctx context.Context, obj *model.Operator, limit *int, where *model.FeedFilter) ([]*model.Feed, error)
}
type PathwayResolver interface {
	FromStop(ctx context.Context, obj *model.Pathway) (*model.Stop, error)
	ToStop(ctx context.Context, obj *model.Pathway) (*model.Stop, error)
}
type PlaceResolver interface {
	Count(ctx context.Context, obj *model.Place) (int, error)
	Operators(ctx context.Context, obj *model.Place) ([]*model.Operator, error)
}
type QueryResolver interface {
	Feeds(ctx context.Context, limit *int, after *int, ids []int, where *model.FeedFilter) ([]*model.Feed, error)
	Operators(ctx context.Context, limit *int, after *int, ids []int, where *model.OperatorFilter) ([]*model.Operator, error)
	FeedVersions(ctx context.Context, limit *int, after *int, ids []int, where *model.FeedVersionFilter) ([]*model.FeedVersion, error)
	Agencies(ctx context.Context, limit *int, after *int, ids []int, where *model.AgencyFilter) ([]*model.Agency, error)
	Routes(ctx context.Context, limit *int, after *int, ids []int, where *model.RouteFilter) ([]*model.Route, error)
	Stops(ctx context.Context, limit *int, after *int, ids []int, where *model.StopFilter) ([]*model.Stop, error)
	Trips(ctx context.Context, limit *int, after *int, ids []int, where *model.TripFilter) ([]*model.Trip, error)
	Places(ctx context.Context, limit *int, after *int, level *model.PlaceAggregationLevel, where *model.PlaceFilter) ([]*model.Place, error)
	Directions(ctx context.Context, where model.DirectionRequest) (*model.Directions, error)
	Bikes(ctx context.Context, limit *int, where *model.GbfsBikeRequest) ([]*model.GbfsFreeBikeStatus, error)
	Docks(ctx context.Context, limit *int, where *model.GbfsDockRequest) ([]*model.GbfsStationInformation, error)
	Me(ctx context.Context) (*model.Me, error)
	CensusDatasets(ctx context.Context, limit *int, after *int, ids []int, where *model.CensusDatasetFilter) ([]*model.CensusDataset, error)
	CensusValues(ctx context.Context, limit *int, where *model.CensusValueFilter) ([]*model.CensusValue, error)
}
type RouteResolver interface {
	Geometry(ctx context.Context, obj *model.Route) (*tt.Geometry, error)
	Agency(ctx context.Context, obj *model.Route) (*model.Agency, error)

	FeedVersion(ctx context.Context, obj *model.Route) (*model.FeedVersion, error)

	RouteAttribute(ctx context.Context, obj *model.Route) (*model.RouteAttribute, error)
	Trips(ctx context.Context, obj *model.Route, limit *int, where *model.TripFilter) ([]*model.Trip, error)
	Stops(ctx context.Context, obj *model.Route, limit *int, where *model.StopFilter) ([]*model.Stop, error)
	RouteStops(ctx context.Context, obj *model.Route, limit *int) ([]*model.RouteStop, error)
	Headways(ctx context.Context, obj *model.Route, limit *int) ([]*model.RouteHeadway, error)
	Geometries(ctx context.Context, obj *model.Route, limit *int) ([]*model.RouteGeometry, error)
	CensusGeographies(ctx context.Context, obj *model.Route, limit *int, where *model.CensusGeographyFilter) ([]*model.CensusGeography, error)
	RouteStopBuffer(ctx context.Context, obj *model.Route, radius *float64) (*model.RouteStopBuffer, error)
	Patterns(ctx context.Context, obj *model.Route) ([]*model.RouteStopPattern, error)
	Alerts(ctx context.Context, obj *model.Route, active *bool, limit *int) ([]*model.Alert, error)
	Segments(ctx context.Context, obj *model.Route, limit *int, where *model.SegmentFilter) ([]*model.Segment, error)
	SegmentPatterns(ctx context.Context, obj *model.Route, limit *int, where *model.SegmentPatternFilter) ([]*model.SegmentPattern, error)
}
type RouteHeadwayResolver interface {
	Stop(ctx context.Context, obj *model.RouteHeadway) (*model.Stop, error)

	Departures(ctx context.Context, obj *model.RouteHeadway) ([]*tt.Seconds, error)
}
type RouteStopResolver interface {
	Route(ctx context.Context, obj *model.RouteStop) (*model.Route, error)
	Stop(ctx context.Context, obj *model.RouteStop) (*model.Stop, error)
	Agency(ctx context.Context, obj *model.RouteStop) (*model.Agency, error)
}
type RouteStopPatternResolver interface {
	Trips(ctx context.Context, obj *model.RouteStopPattern, limit *int) ([]*model.Trip, error)
}
type SegmentResolver interface {
	SegmentPatterns(ctx context.Context, obj *model.Segment) ([]*model.SegmentPattern, error)
}
type SegmentPatternResolver interface {
	Route(ctx context.Context, obj *model.SegmentPattern) (*model.Route, error)

	Segment(ctx context.Context, obj *model.SegmentPattern) (*model.Segment, error)
}
type StopResolver interface {
	FeedVersion(ctx context.Context, obj *model.Stop) (*model.FeedVersion, error)
	LocationGroups(ctx context.Context, obj *model.Stop, limit *int) ([]*model.LocationGroup, error)
	Level(ctx context.Context, obj *model.Stop) (*model.Level, error)
	Parent(ctx context.Context, obj *model.Stop) (*model.Stop, error)
	ExternalReference(ctx context.Context, obj *model.Stop) (*model.StopExternalReference, error)
	Observations(ctx context.Context, obj *model.Stop, limit *int, where *model.StopObservationFilter) ([]*model.StopObservation, error)
	Children(ctx context.Context, obj *model.Stop, limit *int) ([]*model.Stop, error)
	RouteStops(ctx context.Context, obj *model.Stop, limit *int) ([]*model.RouteStop, error)
	ChildLevels(ctx context.Context, obj *model.Stop, limit *int) ([]*model.Level, error)
	PathwaysFromStop(ctx context.Context, obj *model.Stop, limit *int) ([]*model.Pathway, error)
	PathwaysToStop(ctx context.Context, obj *model.Stop, limit *int) ([]*model.Pathway, error)
	StopTimes(ctx context.Context, obj *model.Stop, limit *int, where *model.StopTimeFilter) ([]*model.StopTime, error)
	Departures(ctx context.Context, obj *model.Stop, limit *int, where *model.StopTimeFilter) ([]*model.StopTime, error)
	Arrivals(ctx context.Context, obj *model.Stop, limit *int, where *model.StopTimeFilter) ([]*model.StopTime, error)

	Place(ctx context.Context, obj *model.Stop) (*model.StopPlace, error)
	CensusGeographies(ctx context.Context, obj *model.Stop, limit *int, where *model.CensusGeographyFilter) ([]*model.CensusGeography, error)
	Directions(ctx context.Context, obj *model.Stop, to *model.WaypointInput, from *model.WaypointInput, mode *model.StepMode, departAt *time.Time) (*model.Directions, error)
	NearbyStops(ctx context.Context, obj *model.Stop, limit *int, radius *float64) ([]*model.Stop, error)
	Alerts(ctx context.Context, obj *model.Stop, active *bool, limit *int) ([]*model.Alert, error)
}
type StopExternalReferenceResolver interface {
	TargetActiveStop(ctx context.Context, obj *model.StopExternalReference) (*model.Stop, error)
}
type StopTimeResolver interface {
	PickupBookingRule(ctx context.Context, obj *model.StopTime) (*model.BookingRule, error)
	DropOffBookingRule(ctx context.Context, obj *model.StopTime) (*model.BookingRule, error)
	Stop(ctx context.Context, obj *model.StopTime) (*model.Stop, error)
	Trip(ctx context.Context, obj *model.StopTime) (*model.Trip, error)
	Arrival(ctx context.Context, obj *model.StopTime) (*model.StopTimeEvent, error)
	Departure(ctx context.Context, obj *model.StopTime) (*model.StopTimeEvent, error)

	ScheduleRelationship(ctx context.Context, obj *model.StopTime) (*model.ScheduleRelationship, error)
}
type TripResolver interface {
	Calendar(ctx context.Context, obj *model.Trip) (*model.Calendar, error)
	Route(ctx context.Context, obj *model.Trip) (*model.Route, error)
	Shape(ctx context.Context, obj *model.Trip) (*model.Shape, error)
	FeedVersion(ctx context.Context, obj *model.Trip) (*model.FeedVersion, error)
	StopTimes(ctx context.Context, obj *model.Trip, limit *int, where *model.TripStopTimeFilter) ([]*model.StopTime, error)
	FlexStopTimes(ctx context.Context, obj *model.Trip, limit *int, where *model.TripStopTimeFilter) ([]*model.StopTime, error)
	Frequencies(ctx context.Context, obj *model.Trip, limit *int) ([]*model.Frequency, error)
	Alerts(ctx context.Context, obj *model.Trip, active *bool, limit *int) ([]*model.Alert, error)
	ScheduleRelationship(ctx context.Context, obj *model.Trip) (*model.ScheduleRelationship, error)
	Timestamp(ctx context.Context, obj *model.Trip) (*time.Time, error)
}
type ValidationReportResolver interface {
	Errors(ctx context.Context, obj *model.ValidationReport, limit *int) ([]*model.ValidationReportErrorGroup, error)
	Warnings(ctx context.Context, obj *model.ValidationReport, limit *int) ([]*model.ValidationReportErrorGroup, error)
	Details(ctx context.Context, obj *model.ValidationReport) (*model.ValidationReportDetails, error)
}
type ValidationReportErrorGroupResolver interface {
	Errors(ctx context.Context, obj *model.ValidationReportErrorGroup, limit *int) ([]*model.ValidationReportError, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Agency.agency_email":
		if e.complexity.Agency.AgencyEmail == nil {
			break
		}

		return e.complexity.Agency.AgencyEmail(childComplexity), true

	case "Agency.agency_fare_url":
		if e.complexity.Agency.AgencyFareURL == nil {
			break
		}

		return e.complexity.Agency.AgencyFareURL(childComplexity), true

	case "Agency.agency_id":
		if e.complexity.Agency.AgencyID == nil {
			break
		}

		return e.complexity.Agency.AgencyID(childComplexity), true

	case "Agency.agency_lang":
		if e.complexity.Agency.AgencyLang == nil {
			break
		}

		return e.complexity.Agency.AgencyLang(childComplexity), true

	case "Agency.agency_name":
		if e.complexity.Agency.AgencyName == nil {
			break
		}

		return e.complexity.Agency.AgencyName(childComplexity), true

	case "Agency.agency_phone":
		if e.complexity.Agency.AgencyPhone == nil {
			break
		}

		return e.complexity.Agency.AgencyPhone(childComplexity), true

	case "Agency.agency_timezone":
		if e.complexity.Agency.AgencyTimezone == nil {
			break
		}

		return e.complexity.Agency.AgencyTimezone(childComplexity), true

	case "Agency.agency_url":
		if e.complexity.Agency.AgencyURL == nil {
			break
		}

		return e.complexity.Agency.AgencyURL(childComplexity), true

	case "Agency.alerts":
		if e.complexity.Agency.Alerts == nil {
			break
		}

		args, err := ec.field_Agency_alerts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Agency.Alerts(childComplexity, args["active"].(*bool), args["limit"].(*int)), true

	case "Agency.census_geographies":
		if e.complexity.Agency.CensusGeographies == nil {
			break
		}

		args, err := ec.field_Agency_census_geographies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Agency.CensusGeographies(childComplexity, args["limit"].(*int), args["where"].(*model.CensusGeographyFilter)), true

	case "Agency.feed_onestop_id":
		if e.complexity.Agency.FeedOnestopID == nil {
			break
		}

		return e.complexity.Agency.FeedOnestopID(childComplexity), true

	case "Agency.feed_version":
		if e.complexity.Agency.FeedVersion == nil {
			break
		}

		return e.complexity.Agency.FeedVersion(childComplexity), true

	case "Agency.feed_version_sha1":
		if e.complexity.Agency.FeedVersionSHA1 == nil {
			break
		}

		return e.complexity.Agency.FeedVersionSHA1(childComplexity), true

	case "Agency.geometry":
		if e.complexity.Agency.Geometry == nil {
			break
		}

		return e.complexity.Agency.Geometry(childComplexity), true

	case "Agency.id":
		if e.complexity.Agency.ID == nil {
			break
		}

		return e.complexity.Agency.ID(childComplexity), true

	case "Agency.onestop_id":
		if e.complexity.Agency.OnestopID == nil {
			break
		}

		return e.complexity.Agency.OnestopID(childComplexity), true

	case "Agency.operator":
		if e.complexity.Agency.Operator == nil {
			break
		}

		return e.complexity.Agency.Operator(childComplexity), true

	case "Agency.places":
		if e.complexity.Agency.Places == nil {
			break
		}

		args, err := ec.field_Agency_places_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Agency.Places(childComplexity, args["limit"].(*int), args["where"].(*model.AgencyPlaceFilter)), true

	case "Agency.routes":
		if e.complexity.Agency.Routes == nil {
			break
		}

		args, err := ec.field_Agency_routes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Agency.Routes(childComplexity, args["limit"].(*int), args["where"].(*model.RouteFilter)), true

	case "Agency.search_rank":
		if e.complexity.Agency.SearchRank == nil {
			break
		}

		return e.complexity.Agency.SearchRank(childComplexity), true

	case "AgencyPlace.adm0_iso":
		if e.complexity.AgencyPlace.Adm0Iso == nil {
			break
		}

		return e.complexity.AgencyPlace.Adm0Iso(childComplexity), true

	case "AgencyPlace.adm0_name":
		if e.complexity.AgencyPlace.Adm0Name == nil {
			break
		}

		return e.complexity.AgencyPlace.Adm0Name(childComplexity), true

	case "AgencyPlace.adm1_iso":
		if e.complexity.AgencyPlace.Adm1Iso == nil {
			break
		}

		return e.complexity.AgencyPlace.Adm1Iso(childComplexity), true

	case "AgencyPlace.adm1_name":
		if e.complexity.AgencyPlace.Adm1Name == nil {
			break
		}

		return e.complexity.AgencyPlace.Adm1Name(childComplexity), true

	case "AgencyPlace.city_name":
		if e.complexity.AgencyPlace.CityName == nil {
			break
		}

		return e.complexity.AgencyPlace.CityName(childComplexity), true

	case "AgencyPlace.rank":
		if e.complexity.AgencyPlace.Rank == nil {
			break
		}

		return e.complexity.AgencyPlace.Rank(childComplexity), true

	case "Alert.active_period":
		if e.complexity.Alert.ActivePeriod == nil {
			break
		}

		return e.complexity.Alert.ActivePeriod(childComplexity), true

	case "Alert.cause":
		if e.complexity.Alert.Cause == nil {
			break
		}

		return e.complexity.Alert.Cause(childComplexity), true

	case "Alert.description_text":
		if e.complexity.Alert.DescriptionText == nil {
			break
		}

		return e.complexity.Alert.DescriptionText(childComplexity), true

	case "Alert.effect":
		if e.complexity.Alert.Effect == nil {
			break
		}

		return e.complexity.Alert.Effect(childComplexity), true

	case "Alert.header_text":
		if e.complexity.Alert.HeaderText == nil {
			break
		}

		return e.complexity.Alert.HeaderText(childComplexity), true

	case "Alert.severity_level":
		if e.complexity.Alert.SeverityLevel == nil {
			break
		}

		return e.complexity.Alert.SeverityLevel(childComplexity), true

	case "Alert.tts_description_text":
		if e.complexity.Alert.TtsDescriptionText == nil {
			break
		}

		return e.complexity.Alert.TtsDescriptionText(childComplexity), true

	case "Alert.tts_header_text":
		if e.complexity.Alert.TtsHeaderText == nil {
			break
		}

		return e.complexity.Alert.TtsHeaderText(childComplexity), true

	case "Alert.url":
		if e.complexity.Alert.URL == nil {
			break
		}

		return e.complexity.Alert.URL(childComplexity), true

	case "BookingRule.booking_rule_id":
		if e.complexity.BookingRule.BookingRuleID == nil {
			break
		}

		return e.complexity.BookingRule.BookingRuleID(childComplexity), true

	case "BookingRule.booking_type":
		if e.complexity.BookingRule.BookingType == nil {
			break
		}

		return e.complexity.BookingRule.BookingType(childComplexity), true

	case "BookingRule.booking_url":
		if e.complexity.BookingRule.BookingURL == nil {
			break
		}

		return e.complexity.BookingRule.BookingURL(childComplexity), true

	case "BookingRule.drop_off_message":
		if e.complexity.BookingRule.DropOffMessage == nil {
			break
		}

		return e.complexity.BookingRule.DropOffMessage(childComplexity), true

	case "BookingRule.feed_onestop_id":
		if e.complexity.BookingRule.FeedOnestopID == nil {
			break
		}

		return e.complexity.BookingRule.FeedOnestopID(childComplexity), true

	case "BookingRule.feed_version":
		if e.complexity.BookingRule.FeedVersion == nil {
			break
		}

		return e.complexity.BookingRule.FeedVersion(childComplexity), true

	case "BookingRule.feed_version_sha1":
		if e.complexity.BookingRule.FeedVersionSHA1 == nil {
			break
		}

		return e.complexity.BookingRule.FeedVersionSHA1(childComplexity), true

	case "BookingRule.id":
		if e.complexity.BookingRule.ID == nil {
			break
		}

		return e.complexity.BookingRule.ID(childComplexity), true

	case "BookingRule.info_url":
		if e.complexity.BookingRule.InfoURL == nil {
			break
		}

		return e.complexity.BookingRule.InfoURL(childComplexity), true

	case "BookingRule.message":
		if e.complexity.BookingRule.Message == nil {
			break
		}

		return e.complexity.BookingRule.Message(childComplexity), true

	case "BookingRule.phone_number":
		if e.complexity.BookingRule.PhoneNumber == nil {
			break
		}

		return e.complexity.BookingRule.PhoneNumber(childComplexity), true

	case "BookingRule.pickup_message":
		if e.complexity.BookingRule.PickupMessage == nil {
			break
		}

		return e.complexity.BookingRule.PickupMessage(childComplexity), true

	case "BookingRule.prior_notice_duration_max":
		if e.complexity.BookingRule.PriorNoticeDurationMax == nil {
			break
		}

		return e.complexity.BookingRule.PriorNoticeDurationMax(childComplexity), true

	case "BookingRule.prior_notice_duration_min":
		if e.complexity.BookingRule.PriorNoticeDurationMin == nil {
			break
		}

		return e.complexity.BookingRule.PriorNoticeDurationMin(childComplexity), true

	case "BookingRule.prior_notice_last_day":
		if e.complexity.BookingRule.PriorNoticeLastDay == nil {
			break
		}

		return e.complexity.BookingRule.PriorNoticeLastDay(childComplexity), true

	case "BookingRule.prior_notice_last_time":
		if e.complexity.BookingRule.PriorNoticeLastTime == nil {
			break
		}

		return e.complexity.BookingRule.PriorNoticeLastTime(childComplexity), true

	case "BookingRule.prior_notice_service":
		if e.complexity.BookingRule.PriorNoticeService == nil {
			break
		}

		return e.complexity.BookingRule.PriorNoticeService(childComplexity), true

	case "BookingRule.prior_notice_start_day":
		if e.complexity.BookingRule.PriorNoticeStartDay == nil {
			break
		}

		return e.complexity.BookingRule.PriorNoticeStartDay(childComplexity), true

	case "BookingRule.prior_notice_start_time":
		if e.complexity.BookingRule.PriorNoticeStartTime == nil {
			break
		}

		return e.complexity.BookingRule.PriorNoticeStartTime(childComplexity), true

	case "Calendar.added_dates":
		if e.complexity.Calendar.AddedDates == nil {
			break
		}

		args, err := ec.field_Calendar_added_dates_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Calendar.AddedDates(childComplexity, args["limit"].(*int)), true

	case "Calendar.end_date":
		if e.complexity.Calendar.EndDate == nil {
			break
		}

		return e.complexity.Calendar.EndDate(childComplexity), true

	case "Calendar.friday":
		if e.complexity.Calendar.Friday == nil {
			break
		}

		return e.complexity.Calendar.Friday(childComplexity), true

	case "Calendar.id":
		if e.complexity.Calendar.ID == nil {
			break
		}

		return e.complexity.Calendar.ID(childComplexity), true

	case "Calendar.monday":
		if e.complexity.Calendar.Monday == nil {
			break
		}

		return e.complexity.Calendar.Monday(childComplexity), true

	case "Calendar.removed_dates":
		if e.complexity.Calendar.RemovedDates == nil {
			break
		}

		args, err := ec.field_Calendar_removed_dates_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Calendar.RemovedDates(childComplexity, args["limit"].(*int)), true

	case "Calendar.saturday":
		if e.complexity.Calendar.Saturday == nil {
			break
		}

		return e.complexity.Calendar.Saturday(childComplexity), true

	case "Calendar.service_id":
		if e.complexity.Calendar.ServiceID == nil {
			break
		}

		return e.complexity.Calendar.ServiceID(childComplexity), true

	case "Calendar.start_date":
		if e.complexity.Calendar.StartDate == nil {
			break
		}

		return e.complexity.Calendar.StartDate(childComplexity), true

	case "Calendar.sunday":
		if e.complexity.Calendar.Sunday == nil {
			break
		}

		return e.complexity.Calendar.Sunday(childComplexity), true

	case "Calendar.thursday":
		if e.complexity.Calendar.Thursday == nil {
			break
		}

		return e.complexity.Calendar.Thursday(childComplexity), true

	case "Calendar.tuesday":
		if e.complexity.Calendar.Tuesday == nil {
			break
		}

		return e.complexity.Calendar.Tuesday(childComplexity), true

	case "Calendar.wednesday":
		if e.complexity.Calendar.Wednesday == nil {
			break
		}

		return e.complexity.Calendar.Wednesday(childComplexity), true

	case "CensusDataset.description":
		if e.complexity.CensusDataset.Description == nil {
			break
		}

		return e.complexity.CensusDataset.Description(childComplexity), true

	case "CensusDataset.geographies":
		if e.complexity.CensusDataset.Geographies == nil {
			break
		}

		args, err := ec.field_CensusDataset_geographies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CensusDataset.Geographies(childComplexity, args["limit"].(*int), args["where"].(*model.CensusDatasetGeographyFilter)), true

	case "CensusDataset.id":
		if e.complexity.CensusDataset.ID == nil {
			break
		}

		return e.complexity.CensusDataset.ID(childComplexity), true

	case "CensusDataset.layers":
		if e.complexity.CensusDataset.Layers == nil {
			break
		}

		return e.complexity.CensusDataset.Layers(childComplexity), true

	case "CensusDataset.name":
		if e.complexity.CensusDataset.Name == nil {
			break
		}

		return e.complexity.CensusDataset.Name(childComplexity), true

	case "CensusDataset.sources":
		if e.complexity.CensusDataset.Sources == nil {
			break
		}

		args, err := ec.field_CensusDataset_sources_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CensusDataset.Sources(childComplexity, args["limit"].(*int), args["where"].(*model.CensusSourceFilter)), true

	case "CensusDataset.tables":
		if e.complexity.CensusDataset.Tables == nil {
			break
		}

		args, err := ec.field_CensusDataset_tables_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CensusDataset.Tables(childComplexity, args["limit"].(*int), args["where"].(*model.CensusTableFilter)), true

	case "CensusDataset.url":
		if e.complexity.CensusDataset.URL == nil {
			break
		}

		return e.complexity.CensusDataset.URL(childComplexity), true

	case "CensusDataset.year_max":
		if e.complexity.CensusDataset.YearMax == nil {
			break
		}

		return e.complexity.CensusDataset.YearMax(childComplexity), true

	case "CensusDataset.year_min":
		if e.complexity.CensusDataset.YearMin == nil {
			break
		}

		return e.complexity.CensusDataset.YearMin(childComplexity), true

	case "CensusField.column_order":
		if e.complexity.CensusField.ColumnOrder == nil {
			break
		}

		return e.complexity.CensusField.ColumnOrder(childComplexity), true

	case "CensusField.field_name":
		if e.complexity.CensusField.FieldName == nil {
			break
		}

		return e.complexity.CensusField.FieldName(childComplexity), true

	case "CensusField.field_title":
		if e.complexity.CensusField.FieldTitle == nil {
			break
		}

		return e.complexity.CensusField.FieldTitle(childComplexity), true

	case "CensusField.id":
		if e.complexity.CensusField.ID == nil {
			break
		}

		return e.complexity.CensusField.ID(childComplexity), true

	case "CensusGeography.adm0_iso":
		if e.complexity.CensusGeography.Adm0Iso == nil {
			break
		}

		return e.complexity.CensusGeography.Adm0Iso(childComplexity), true

	case "CensusGeography.adm0_name":
		if e.complexity.CensusGeography.Adm0Name == nil {
			break
		}

		return e.complexity.CensusGeography.Adm0Name(childComplexity), true

	case "CensusGeography.adm1_iso":
		if e.complexity.CensusGeography.Adm1Iso == nil {
			break
		}

		return e.complexity.CensusGeography.Adm1Iso(childComplexity), true

	case "CensusGeography.adm1_name":
		if e.complexity.CensusGeography.Adm1Name == nil {
			break
		}

		return e.complexity.CensusGeography.Adm1Name(childComplexity), true

	case "CensusGeography.aland":
		if e.complexity.CensusGeography.Aland == nil {
			break
		}

		return e.complexity.CensusGeography.Aland(childComplexity), true

	case "CensusGeography.awater":
		if e.complexity.CensusGeography.Awater == nil {
			break
		}

		return e.complexity.CensusGeography.Awater(childComplexity), true

	case "CensusGeography.dataset_name":
		if e.complexity.CensusGeography.DatasetName == nil {
			break
		}

		return e.complexity.CensusGeography.DatasetName(childComplexity), true

	case "CensusGeography.geoid":
		if e.complexity.CensusGeography.Geoid == nil {
			break
		}

		return e.complexity.CensusGeography.Geoid(childComplexity), true

	case "CensusGeography.geometry":
		if e.complexity.CensusGeography.Geometry == nil {
			break
		}

		return e.complexity.CensusGeography.Geometry(childComplexity), true

	case "CensusGeography.geometry_area":
		if e.complexity.CensusGeography.GeometryArea == nil {
			break
		}

		return e.complexity.CensusGeography.GeometryArea(childComplexity), true

	case "CensusGeography.id":
		if e.complexity.CensusGeography.ID == nil {
			break
		}

		return e.complexity.CensusGeography.ID(childComplexity), true

	case "CensusGeography.intersection_area":
		if e.complexity.CensusGeography.IntersectionArea == nil {
			break
		}

		return e.complexity.CensusGeography.IntersectionArea(childComplexity), true

	case "CensusGeography.intersection_geometry":
		if e.complexity.CensusGeography.IntersectionGeometry == nil {
			break
		}

		return e.complexity.CensusGeography.IntersectionGeometry(childComplexity), true

	case "CensusGeography.layer":
		if e.complexity.CensusGeography.Layer == nil {
			break
		}

		return e.complexity.CensusGeography.Layer(childComplexity), true

	case "CensusGeography.layer_name":
		if e.complexity.CensusGeography.LayerName == nil {
			break
		}

		return e.complexity.CensusGeography.LayerName(childComplexity), true

	case "CensusGeography.name":
		if e.complexity.CensusGeography.Name == nil {
			break
		}

		return e.complexity.CensusGeography.Name(childComplexity), true

	case "CensusGeography.source":
		if e.complexity.CensusGeography.Source == nil {
			break
		}

		return e.complexity.CensusGeography.Source(childComplexity), true

	case "CensusGeography.source_name":
		if e.complexity.CensusGeography.SourceName == nil {
			break
		}

		return e.complexity.CensusGeography.SourceName(childComplexity), true

	case "CensusGeography.values":
		if e.complexity.CensusGeography.Values == nil {
			break
		}

		args, err := ec.field_CensusGeography_values_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CensusGeography.Values(childComplexity, args["table_names"].([]string), args["dataset"].(*string), args["limit"].(*int)), true

	case "CensusLayer.description":
		if e.complexity.CensusLayer.Description == nil {
			break
		}

		return e.complexity.CensusLayer.Description(childComplexity), true

	case "CensusLayer.geographies":
		if e.complexity.CensusLayer.Geographies == nil {
			break
		}

		args, err := ec.field_CensusLayer_geographies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CensusLayer.Geographies(childComplexity, args["limit"].(*int), args["where"].(*model.CensusSourceGeographyFilter)), true

	case "CensusLayer.id":
		if e.complexity.CensusLayer.ID == nil {
			break
		}

		return e.complexity.CensusLayer.ID(childComplexity), true

	case "CensusLayer.name":
		if e.complexity.CensusLayer.Name == nil {
			break
		}

		return e.complexity.CensusLayer.Name(childComplexity), true

	case "CensusSource.description":
		if e.complexity.CensusSource.Description == nil {
			break
		}

		return e.complexity.CensusSource.Description(childComplexity), true

	case "CensusSource.geographies":
		if e.complexity.CensusSource.Geographies == nil {
			break
		}

		args, err := ec.field_CensusSource_geographies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CensusSource.Geographies(childComplexity, args["limit"].(*int), args["where"].(*model.CensusSourceGeographyFilter)), true

	case "CensusSource.id":
		if e.complexity.CensusSource.ID == nil {
			break
		}

		return e.complexity.CensusSource.ID(childComplexity), true

	case "CensusSource.layers":
		if e.complexity.CensusSource.Layers == nil {
			break
		}

		return e.complexity.CensusSource.Layers(childComplexity), true

	case "CensusSource.name":
		if e.complexity.CensusSource.Name == nil {
			break
		}

		return e.complexity.CensusSource.Name(childComplexity), true

	case "CensusSource.sha1":
		if e.complexity.CensusSource.Sha1 == nil {
			break
		}

		return e.complexity.CensusSource.Sha1(childComplexity), true

	case "CensusSource.tables":
		if e.complexity.CensusSource.Tables == nil {
			break
		}

		args, err := ec.field_CensusSource_tables_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CensusSource.Tables(childComplexity, args["limit"].(*int)), true

	case "CensusSource.url":
		if e.complexity.CensusSource.URL == nil {
			break
		}

		return e.complexity.CensusSource.URL(childComplexity), true

	case "CensusTable.fields":
		if e.complexity.CensusTable.Fields == nil {
			break
		}

		return e.complexity.CensusTable.Fields(childComplexity), true

	case "CensusTable.id":
		if e.complexity.CensusTable.ID == nil {
			break
		}

		return e.complexity.CensusTable.ID(childComplexity), true

	case "CensusTable.table_details":
		if e.complexity.CensusTable.TableDetails == nil {
			break
		}

		return e.complexity.CensusTable.TableDetails(childComplexity), true

	case "CensusTable.table_group":
		if e.complexity.CensusTable.TableGroup == nil {
			break
		}

		return e.complexity.CensusTable.TableGroup(childComplexity), true

	case "CensusTable.table_name":
		if e.complexity.CensusTable.TableName == nil {
			break
		}

		return e.complexity.CensusTable.TableName(childComplexity), true

	case "CensusTable.table_title":
		if e.complexity.CensusTable.TableTitle == nil {
			break
		}

		return e.complexity.CensusTable.TableTitle(childComplexity), true

	case "CensusValue.dataset_name":
		if e.complexity.CensusValue.DatasetName == nil {
			break
		}

		return e.complexity.CensusValue.DatasetName(childComplexity), true

	case "CensusValue.geoid":
		if e.complexity.CensusValue.Geoid == nil {
			break
		}

		return e.complexity.CensusValue.Geoid(childComplexity), true

	case "CensusValue.source_name":
		if e.complexity.CensusValue.SourceName == nil {
			break
		}

		return e.complexity.CensusValue.SourceName(childComplexity), true

	case "CensusValue.table":
		if e.complexity.CensusValue.Table == nil {
			break
		}

		return e.complexity.CensusValue.Table(childComplexity), true

	case "CensusValue.values":
		if e.complexity.CensusValue.Values == nil {
			break
		}

		return e.complexity.CensusValue.Values(childComplexity), true

	case "Directions.data_source":
		if e.complexity.Directions.DataSource == nil {
			break
		}

		return e.complexity.Directions.DataSource(childComplexity), true

	case "Directions.destination":
		if e.complexity.Directions.Destination == nil {
			break
		}

		return e.complexity.Directions.Destination(childComplexity), true

	case "Directions.distance":
		if e.complexity.Directions.Distance == nil {
			break
		}

		return e.complexity.Directions.Distance(childComplexity), true

	case "Directions.duration":
		if e.complexity.Directions.Duration == nil {
			break
		}

		return e.complexity.Directions.Duration(childComplexity), true

	case "Directions.end_time":
		if e.complexity.Directions.EndTime == nil {
			break
		}

		return e.complexity.Directions.EndTime(childComplexity), true

	case "Directions.exception":
		if e.complexity.Directions.Exception == nil {
			break
		}

		return e.complexity.Directions.Exception(childComplexity), true

	case "Directions.itineraries":
		if e.complexity.Directions.Itineraries == nil {
			break
		}

		return e.complexity.Directions.Itineraries(childComplexity), true

	case "Directions.origin":
		if e.complexity.Directions.Origin == nil {
			break
		}

		return e.complexity.Directions.Origin(childComplexity), true

	case "Directions.start_time":
		if e.complexity.Directions.StartTime == nil {
			break
		}

		return e.complexity.Directions.StartTime(childComplexity), true

	case "Directions.success":
		if e.complexity.Directions.Success == nil {
			break
		}

		return e.complexity.Directions.Success(childComplexity), true

	case "Distance.distance":
		if e.complexity.Distance.Distance == nil {
			break
		}

		return e.complexity.Distance.Distance(childComplexity), true

	case "Distance.units":
		if e.complexity.Distance.Units == nil {
			break
		}

		return e.complexity.Distance.Units(childComplexity), true

	case "Duration.duration":
		if e.complexity.Duration.Duration == nil {
			break
		}

		return e.complexity.Duration.Duration(childComplexity), true

	case "Duration.units":
		if e.complexity.Duration.Units == nil {
			break
		}

		return e.complexity.Duration.Units(childComplexity), true

	case "EntityDeleteResult.id":
		if e.complexity.EntityDeleteResult.ID == nil {
			break
		}

		return e.complexity.EntityDeleteResult.ID(childComplexity), true

	case "Feed.associated_operators":
		if e.complexity.Feed.AssociatedOperators == nil {
			break
		}

		return e.complexity.Feed.AssociatedOperators(childComplexity), true

	case "Feed.authorization":
		if e.complexity.Feed.Authorization == nil {
			break
		}

		return e.complexity.Feed.Authorization(childComplexity), true

	case "Feed.feed_fetches":
		if e.complexity.Feed.FeedFetches == nil {
			break
		}

		args, err := ec.field_Feed_feed_fetches_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Feed.FeedFetches(childComplexity, args["limit"].(*int), args["where"].(*model.FeedFetchFilter)), true

	case "Feed.onestop_id":
		if e.complexity.Feed.FeedID == nil {
			break
		}

		return e.complexity.Feed.FeedID(childComplexity), true

	case "Feed.feed_state":
		if e.complexity.Feed.FeedState == nil {
			break
		}

		return e.complexity.Feed.FeedState(childComplexity), true

	case "Feed.feed_versions":
		if e.complexity.Feed.FeedVersions == nil {
			break
		}

		args, err := ec.field_Feed_feed_versions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Feed.FeedVersions(childComplexity, args["limit"].(*int), args["where"].(*model.FeedVersionFilter)), true

	case "Feed.file":
		if e.complexity.Feed.File == nil {
			break
		}

		return e.complexity.Feed.File(childComplexity), true

	case "Feed.id":
		if e.complexity.Feed.ID == nil {
			break
		}

		return e.complexity.Feed.ID(childComplexity), true

	case "Feed.languages":
		if e.complexity.Feed.Languages == nil {
			break
		}

		return e.complexity.Feed.Languages(childComplexity), true

	case "Feed.license":
		if e.complexity.Feed.License == nil {
			break
		}

		return e.complexity.Feed.License(childComplexity), true

	case "Feed.name":
		if e.complexity.Feed.Name == nil {
			break
		}

		return e.complexity.Feed.Name(childComplexity), true

	case "Feed.search_rank":
		if e.complexity.Feed.SearchRank == nil {
			break
		}

		return e.complexity.Feed.SearchRank(childComplexity), true

	case "Feed.spec":
		if e.complexity.Feed.Spec == nil {
			break
		}

		return e.complexity.Feed.Spec(childComplexity), true

	case "Feed.tags":
		if e.complexity.Feed.Tags == nil {
			break
		}

		return e.complexity.Feed.Tags(childComplexity), true

	case "Feed.urls":
		if e.complexity.Feed.Urls == nil {
			break
		}

		return e.complexity.Feed.Urls(childComplexity), true

	case "FeedAuthorization.info_url":
		if e.complexity.FeedAuthorization.InfoURL == nil {
			break
		}

		return e.complexity.FeedAuthorization.InfoURL(childComplexity), true

	case "FeedAuthorization.param_name":
		if e.complexity.FeedAuthorization.ParamName == nil {
			break
		}

		return e.complexity.FeedAuthorization.ParamName(childComplexity), true

	case "FeedAuthorization.type":
		if e.complexity.FeedAuthorization.Type == nil {
			break
		}

		return e.complexity.FeedAuthorization.Type(childComplexity), true

	case "FeedFetch.fetch_error":
		if e.complexity.FeedFetch.FetchError == nil {
			break
		}

		return e.complexity.FeedFetch.FetchError(childComplexity), true

	case "FeedFetch.fetched_at":
		if e.complexity.FeedFetch.FetchedAt == nil {
			break
		}

		return e.complexity.FeedFetch.FetchedAt(childComplexity), true

	case "FeedFetch.id":
		if e.complexity.FeedFetch.ID == nil {
			break
		}

		return e.complexity.FeedFetch.ID(childComplexity), true

	case "FeedFetch.response_code":
		if e.complexity.FeedFetch.ResponseCode == nil {
			break
		}

		return e.complexity.FeedFetch.ResponseCode(childComplexity), true

	case "FeedFetch.response_sha1":
		if e.complexity.FeedFetch.ResponseSha1 == nil {
			break
		}

		return e.complexity.FeedFetch.ResponseSha1(childComplexity), true

	case "FeedFetch.response_size":
		if e.complexity.FeedFetch.ResponseSize == nil {
			break
		}

		return e.complexity.FeedFetch.ResponseSize(childComplexity), true

	case "FeedFetch.success":
		if e.complexity.FeedFetch.Success == nil {
			break
		}

		return e.complexity.FeedFetch.Success(childComplexity), true

	case "FeedFetch.url":
		if e.complexity.FeedFetch.URL == nil {
			break
		}

		return e.complexity.FeedFetch.URL(childComplexity), true

	case "FeedFetch.url_type":
		if e.complexity.FeedFetch.URLType == nil {
			break
		}

		return e.complexity.FeedFetch.URLType(childComplexity), true

	case "FeedInfo.default_lang":
		if e.complexity.FeedInfo.DefaultLang == nil {
			break
		}

		return e.complexity.FeedInfo.DefaultLang(childComplexity), true

	case "FeedInfo.feed_contact_email":
		if e.complexity.FeedInfo.FeedContactEmail == nil {
			break
		}

		return e.complexity.FeedInfo.FeedContactEmail(childComplexity), true

	case "FeedInfo.feed_contact_url":
		if e.complexity.FeedInfo.FeedContactURL == nil {
			break
		}

		return e.complexity.FeedInfo.FeedContactURL(childComplexity), true

	case "FeedInfo.feed_end_date":
		if e.complexity.FeedInfo.FeedEndDate == nil {
			break
		}

		return e.complexity.FeedInfo.FeedEndDate(childComplexity), true

	case "FeedInfo.feed_lang":
		if e.complexity.FeedInfo.FeedLang == nil {
			break
		}

		return e.complexity.FeedInfo.FeedLang(childComplexity), true

	case "FeedInfo.feed_publisher_name":
		if e.complexity.FeedInfo.FeedPublisherName == nil {
			break
		}

		return e.complexity.FeedInfo.FeedPublisherName(childComplexity), true

	case "FeedInfo.feed_publisher_url":
		if e.complexity.FeedInfo.FeedPublisherURL == nil {
			break
		}

		return e.complexity.FeedInfo.FeedPublisherURL(childComplexity), true

	case "FeedInfo.feed_start_date":
		if e.complexity.FeedInfo.FeedStartDate == nil {
			break
		}

		return e.complexity.FeedInfo.FeedStartDate(childComplexity), true

	case "FeedInfo.feed_version":
		if e.complexity.FeedInfo.FeedVersion == nil {
			break
		}

		return e.complexity.FeedInfo.FeedVersion(childComplexity), true

	case "FeedInfo.id":
		if e.complexity.FeedInfo.ID == nil {
			break
		}

		return e.complexity.FeedInfo.ID(childComplexity), true

	case "FeedLicense.attribution_instructions":
		if e.complexity.FeedLicense.AttributionInstructions == nil {
			break
		}

		return e.complexity.FeedLicense.AttributionInstructions(childComplexity), true

	case "FeedLicense.attribution_text":
		if e.complexity.FeedLicense.AttributionText == nil {
			break
		}

		return e.complexity.FeedLicense.AttributionText(childComplexity), true

	case "FeedLicense.commercial_use_allowed":
		if e.complexity.FeedLicense.CommercialUseAllowed == nil {
			break
		}

		return e.complexity.FeedLicense.CommercialUseAllowed(childComplexity), true

	case "FeedLicense.create_derived_product":
		if e.complexity.FeedLicense.CreateDerivedProduct == nil {
			break
		}

		return e.complexity.FeedLicense.CreateDerivedProduct(childComplexity), true

	case "FeedLicense.redistribution_allowed":
		if e.complexity.FeedLicense.RedistributionAllowed == nil {
			break
		}

		return e.complexity.FeedLicense.RedistributionAllowed(childComplexity), true

	case "FeedLicense.share_alike_optional":
		if e.complexity.FeedLicense.ShareAlikeOptional == nil {
			break
		}

		return e.complexity.FeedLicense.ShareAlikeOptional(childComplexity), true

	case "FeedLicense.spdx_identifier":
		if e.complexity.FeedLicense.SpdxIdentifier == nil {
			break
		}

		return e.complexity.FeedLicense.SpdxIdentifier(childComplexity), true

	case "FeedLicense.url":
		if e.complexity.FeedLicense.URL == nil {
			break
		}

		return e.complexity.FeedLicense.URL(childComplexity), true

	case "FeedLicense.use_without_attribution":
		if e.complexity.FeedLicense.UseWithoutAttribution == nil {
			break
		}

		return e.complexity.FeedLicense.UseWithoutAttribution(childComplexity), true

	case "FeedState.feed_version":
		if e.complexity.FeedState.FeedVersion == nil {
			break
		}

		return e.complexity.FeedState.FeedVersion(childComplexity), true

	case "FeedState.id":
		if e.complexity.FeedState.ID == nil {
			break
		}

		return e.complexity.FeedState.ID(childComplexity), true

	case "FeedUrls.gbfs_auto_discovery":
		if e.complexity.FeedUrls.GbfsAutoDiscovery == nil {
			break
		}

		return e.complexity.FeedUrls.GbfsAutoDiscovery(childComplexity), true

	case "FeedUrls.mds_provider":
		if e.complexity.FeedUrls.MdsProvider == nil {
			break
		}

		return e.complexity.FeedUrls.MdsProvider(childComplexity), true

	case "FeedUrls.realtime_alerts":
		if e.complexity.FeedUrls.RealtimeAlerts == nil {
			break
		}

		return e.complexity.FeedUrls.RealtimeAlerts(childComplexity), true

	case "FeedUrls.realtime_trip_updates":
		if e.complexity.FeedUrls.RealtimeTripUpdates == nil {
			break
		}

		return e.complexity.FeedUrls.RealtimeTripUpdates(childComplexity), true

	case "FeedUrls.realtime_vehicle_positions":
		if e.complexity.FeedUrls.RealtimeVehiclePositions == nil {
			break
		}

		return e.complexity.FeedUrls.RealtimeVehiclePositions(childComplexity), true

	case "FeedUrls.static_current":
		if e.complexity.FeedUrls.StaticCurrent == nil {
			break
		}

		return e.complexity.FeedUrls.StaticCurrent(childComplexity), true

	case "FeedUrls.static_historic":
		if e.complexity.FeedUrls.StaticHistoric == nil {
			break
		}

		return e.complexity.FeedUrls.StaticHistoric(childComplexity), true

	case "FeedUrls.static_planned":
		if e.complexity.FeedUrls.StaticPlanned == nil {
			break
		}

		return e.complexity.FeedUrls.StaticPlanned(childComplexity), true

	case "FeedVersion.agencies":
		if e.complexity.FeedVersion.Agencies == nil {
			break
		}

		args, err := ec.field_FeedVersion_agencies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.Agencies(childComplexity, args["limit"].(*int), args["where"].(*model.AgencyFilter)), true

	case "FeedVersion.booking_rules":
		if e.complexity.FeedVersion.BookingRules == nil {
			break
		}

		args, err := ec.field_FeedVersion_booking_rules_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.BookingRules(childComplexity, args["limit"].(*int), args["where"].(*model.BookingRuleFilter)), true

	case "FeedVersion.created_by":
		if e.complexity.FeedVersion.CreatedBy == nil {
			break
		}

		return e.complexity.FeedVersion.CreatedBy(childComplexity), true

	case "FeedVersion.description":
		if e.complexity.FeedVersion.Description == nil {
			break
		}

		return e.complexity.FeedVersion.Description(childComplexity), true

	case "FeedVersion.earliest_calendar_date":
		if e.complexity.FeedVersion.EarliestCalendarDate == nil {
			break
		}

		return e.complexity.FeedVersion.EarliestCalendarDate(childComplexity), true

	case "FeedVersion.feed":
		if e.complexity.FeedVersion.Feed == nil {
			break
		}

		return e.complexity.FeedVersion.Feed(childComplexity), true

	case "FeedVersion.feed_infos":
		if e.complexity.FeedVersion.FeedInfos == nil {
			break
		}

		args, err := ec.field_FeedVersion_feed_infos_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.FeedInfos(childComplexity, args["limit"].(*int)), true

	case "FeedVersion.feed_version_gtfs_import":
		if e.complexity.FeedVersion.FeedVersionGtfsImport == nil {
			break
		}

		return e.complexity.FeedVersion.FeedVersionGtfsImport(childComplexity), true

	case "FeedVersion.fetched_at":
		if e.complexity.FeedVersion.FetchedAt == nil {
			break
		}

		return e.complexity.FeedVersion.FetchedAt(childComplexity), true

	case "FeedVersion.file":
		if e.complexity.FeedVersion.File == nil {
			break
		}

		return e.complexity.FeedVersion.File(childComplexity), true

	case "FeedVersion.files":
		if e.complexity.FeedVersion.Files == nil {
			break
		}

		args, err := ec.field_FeedVersion_files_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.Files(childComplexity, args["limit"].(*int)), true

	case "FeedVersion.geometry":
		if e.complexity.FeedVersion.Geometry == nil {
			break
		}

		return e.complexity.FeedVersion.Geometry(childComplexity), true

	case "FeedVersion.id":
		if e.complexity.FeedVersion.ID == nil {
			break
		}

		return e.complexity.FeedVersion.ID(childComplexity), true

	case "FeedVersion.latest_calendar_date":
		if e.complexity.FeedVersion.LatestCalendarDate == nil {
			break
		}

		return e.complexity.FeedVersion.LatestCalendarDate(childComplexity), true

	case "FeedVersion.location_groups":
		if e.complexity.FeedVersion.LocationGroups == nil {
			break
		}

		args, err := ec.field_FeedVersion_location_groups_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.LocationGroups(childComplexity, args["limit"].(*int), args["where"].(*model.LocationGroupFilter)), true

	case "FeedVersion.locations":
		if e.complexity.FeedVersion.Locations == nil {
			break
		}

		args, err := ec.field_FeedVersion_locations_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.Locations(childComplexity, args["limit"].(*int), args["where"].(*model.LocationFilter)), true

	case "FeedVersion.name":
		if e.complexity.FeedVersion.Name == nil {
			break
		}

		return e.complexity.FeedVersion.Name(childComplexity), true

	case "FeedVersion.routes":
		if e.complexity.FeedVersion.Routes == nil {
			break
		}

		args, err := ec.field_FeedVersion_routes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.Routes(childComplexity, args["limit"].(*int), args["where"].(*model.RouteFilter)), true

	case "FeedVersion.sha1":
		if e.complexity.FeedVersion.SHA1 == nil {
			break
		}

		return e.complexity.FeedVersion.SHA1(childComplexity), true

	case "FeedVersion.segments":
		if e.complexity.FeedVersion.Segments == nil {
			break
		}

		args, err := ec.field_FeedVersion_segments_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.Segments(childComplexity, args["limit"].(*int)), true

	case "FeedVersion.service_levels":
		if e.complexity.FeedVersion.ServiceLevels == nil {
			break
		}

		args, err := ec.field_FeedVersion_service_levels_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.ServiceLevels(childComplexity, args["limit"].(*int), args["where"].(*model.FeedVersionServiceLevelFilter)), true

	case "FeedVersion.service_window":
		if e.complexity.FeedVersion.ServiceWindow == nil {
			break
		}

		return e.complexity.FeedVersion.ServiceWindow(childComplexity), true

	case "FeedVersion.stops":
		if e.complexity.FeedVersion.Stops == nil {
			break
		}

		args, err := ec.field_FeedVersion_stops_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.Stops(childComplexity, args["limit"].(*int), args["where"].(*model.StopFilter)), true

	case "FeedVersion.trips":
		if e.complexity.FeedVersion.Trips == nil {
			break
		}

		args, err := ec.field_FeedVersion_trips_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.Trips(childComplexity, args["limit"].(*int), args["where"].(*model.TripFilter)), true

	case "FeedVersion.url":
		if e.complexity.FeedVersion.URL == nil {
			break
		}

		return e.complexity.FeedVersion.URL(childComplexity), true

	case "FeedVersion.updated_by":
		if e.complexity.FeedVersion.UpdatedBy == nil {
			break
		}

		return e.complexity.FeedVersion.UpdatedBy(childComplexity), true

	case "FeedVersion.validation_reports":
		if e.complexity.FeedVersion.ValidationReports == nil {
			break
		}

		args, err := ec.field_FeedVersion_validation_reports_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.ValidationReports(childComplexity, args["limit"].(*int), args["where"].(*model.ValidationReportFilter)), true

	case "FeedVersionDeleteResult.success":
		if e.complexity.FeedVersionDeleteResult.Success == nil {
			break
		}

		return e.complexity.FeedVersionDeleteResult.Success(childComplexity), true

	case "FeedVersionFetchResult.feed_version":
		if e.complexity.FeedVersionFetchResult.FeedVersion == nil {
			break
		}

		return e.complexity.FeedVersionFetchResult.FeedVersion(childComplexity), true

	case "FeedVersionFetchResult.fetch_error":
		if e.complexity.FeedVersionFetchResult.FetchError == nil {
			break
		}

		return e.complexity.FeedVersionFetchResult.FetchError(childComplexity), true

	case "FeedVersionFetchResult.found_dir_sha1":
		if e.complexity.FeedVersionFetchResult.FoundDirSha1 == nil {
			break
		}

		return e.complexity.FeedVersionFetchResult.FoundDirSha1(childComplexity), true

	case "FeedVersionFetchResult.found_sha1":
		if e.complexity.FeedVersionFetchResult.FoundSha1 == nil {
			break
		}

		return e.complexity.FeedVersionFetchResult.FoundSha1(childComplexity), true

	case "FeedVersionFileInfo.csv_like":
		if e.complexity.FeedVersionFileInfo.CSVLike == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.CSVLike(childComplexity), true

	case "FeedVersionFileInfo.header":
		if e.complexity.FeedVersionFileInfo.Header == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.Header(childComplexity), true

	case "FeedVersionFileInfo.id":
		if e.complexity.FeedVersionFileInfo.ID == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.ID(childComplexity), true

	case "FeedVersionFileInfo.name":
		if e.complexity.FeedVersionFileInfo.Name == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.Name(childComplexity), true

	case "FeedVersionFileInfo.rows":
		if e.complexity.FeedVersionFileInfo.Rows == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.Rows(childComplexity), true

	case "FeedVersionFileInfo.sha1":
		if e.complexity.FeedVersionFileInfo.SHA1 == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.SHA1(childComplexity), true

	case "FeedVersionFileInfo.size":
		if e.complexity.FeedVersionFileInfo.Size == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.Size(childComplexity), true

	case "FeedVersionFileInfo.values_count":
		if e.complexity.FeedVersionFileInfo.ValuesCount == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.ValuesCount(childComplexity), true

	case "FeedVersionFileInfo.values_unique":
		if e.complexity.FeedVersionFileInfo.ValuesUnique == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.ValuesUnique(childComplexity), true

	case "FeedVersionGtfsImport.created_at":
		if e.complexity.FeedVersionGtfsImport.CreatedAt == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.CreatedAt(childComplexity), true

	case "FeedVersionGtfsImport.entity_count":
		if e.complexity.FeedVersionGtfsImport.EntityCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.EntityCount(childComplexity), true

	case "FeedVersionGtfsImport.exception_log":
		if e.complexity.FeedVersionGtfsImport.ExceptionLog == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.ExceptionLog(childComplexity), true

	case "FeedVersionGtfsImport.id":
		if e.complexity.FeedVersionGtfsImport.ID == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.ID(childComplexity), true

	case "FeedVersionGtfsImport.in_progress":
		if e.complexity.FeedVersionGtfsImport.InProgress == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.InProgress(childComplexity), true

	case "FeedVersionGtfsImport.interpolated_stop_time_count":
		if e.complexity.FeedVersionGtfsImport.InterpolatedStopTimeCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.InterpolatedStopTimeCount(childComplexity), true

	case "FeedVersionGtfsImport.schedule_removed":
		if e.complexity.FeedVersionGtfsImport.ScheduleRemoved == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.ScheduleRemoved(childComplexity), true

	case "FeedVersionGtfsImport.skip_entity_error_count":
		if e.complexity.FeedVersionGtfsImport.SkipEntityErrorCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.SkipEntityErrorCount(childComplexity), true

	case "FeedVersionGtfsImport.skip_entity_filter_count":
		if e.complexity.FeedVersionGtfsImport.SkipEntityFilterCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.SkipEntityFilterCount(childComplexity), true

	case "FeedVersionGtfsImport.skip_entity_marked_count":
		if e.complexity.FeedVersionGtfsImport.SkipEntityMarkedCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.SkipEntityMarkedCount(childComplexity), true

	case "FeedVersionGtfsImport.skip_entity_reference_count":
		if e.complexity.FeedVersionGtfsImport.SkipEntityReferenceCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.SkipEntityReferenceCount(childComplexity), true

	case "FeedVersionGtfsImport.success":
		if e.complexity.FeedVersionGtfsImport.Success == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.Success(childComplexity), true

	case "FeedVersionGtfsImport.updated_at":
		if e.complexity.FeedVersionGtfsImport.UpdatedAt == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.UpdatedAt(childComplexity), true

	case "FeedVersionGtfsImport.warning_count":
		if e.complexity.FeedVersionGtfsImport.WarningCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.WarningCount(childComplexity), true

	case "FeedVersionImportResult.success":
		if e.complexity.FeedVersionImportResult.Success == nil {
			break
		}

		return e.complexity.FeedVersionImportResult.Success(childComplexity), true

	case "FeedVersionServiceLevel.end_date":
		if e.complexity.FeedVersionServiceLevel.EndDate == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.EndDate(childComplexity), true

	case "FeedVersionServiceLevel.friday":
		if e.complexity.FeedVersionServiceLevel.Friday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Friday(childComplexity), true

	case "FeedVersionServiceLevel.id":
		if e.complexity.FeedVersionServiceLevel.ID == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.ID(childComplexity), true

	case "FeedVersionServiceLevel.monday":
		if e.complexity.FeedVersionServiceLevel.Monday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Monday(childComplexity), true

	case "FeedVersionServiceLevel.saturday":
		if e.complexity.FeedVersionServiceLevel.Saturday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Saturday(childComplexity), true

	case "FeedVersionServiceLevel.start_date":
		if e.complexity.FeedVersionServiceLevel.StartDate == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.StartDate(childComplexity), true

	case "FeedVersionServiceLevel.sunday":
		if e.complexity.FeedVersionServiceLevel.Sunday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Sunday(childComplexity), true

	case "FeedVersionServiceLevel.thursday":
		if e.complexity.FeedVersionServiceLevel.Thursday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Thursday(childComplexity), true

	case "FeedVersionServiceLevel.tuesday":
		if e.complexity.FeedVersionServiceLevel.Tuesday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Tuesday(childComplexity), true

	case "FeedVersionServiceLevel.wednesday":
		if e.complexity.FeedVersionServiceLevel.Wednesday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Wednesday(childComplexity), true

	case "FeedVersionServiceWindow.default_timezone":
		if e.complexity.FeedVersionServiceWindow.DefaultTimezone == nil {
			break
		}

		return e.complexity.FeedVersionServiceWindow.DefaultTimezone(childComplexity), true

	case "FeedVersionServiceWindow.earliest_calendar_date":
		if e.complexity.FeedVersionServiceWindow.EarliestCalendarDate == nil {
			break
		}

		return e.complexity.FeedVersionServiceWindow.EarliestCalendarDate(childComplexity), true

	case "FeedVersionServiceWindow.fallback_week":
		if e.complexity.FeedVersionServiceWindow.FallbackWeek == nil {
			break
		}

		return e.complexity.FeedVersionServiceWindow.FallbackWeek(childComplexity), true

	case "FeedVersionServiceWindow.feed_end_date":
		if e.complexity.FeedVersionServiceWindow.FeedEndDate == nil {
			break
		}

		return e.complexity.FeedVersionServiceWindow.FeedEndDate(childComplexity), true

	case "FeedVersionServiceWindow.feed_start_date":
		if e.complexity.FeedVersionServiceWindow.FeedStartDate == nil {
			break
		}

		return e.complexity.FeedVersionServiceWindow.FeedStartDate(childComplexity), true

	case "FeedVersionServiceWindow.id":
		if e.complexity.FeedVersionServiceWindow.ID == nil {
			break
		}

		return e.complexity.FeedVersionServiceWindow.ID(childComplexity), true

	case "FeedVersionServiceWindow.latest_calendar_date":
		if e.complexity.FeedVersionServiceWindow.LatestCalendarDate == nil {
			break
		}

		return e.complexity.FeedVersionServiceWindow.LatestCalendarDate(childComplexity), true

	case "FeedVersionUnimportResult.success":
		if e.complexity.FeedVersionUnimportResult.Success == nil {
			break
		}

		return e.complexity.FeedVersionUnimportResult.Success(childComplexity), true

	case "FlexStopTime.arrival":
		if e.complexity.FlexStopTime.Arrival == nil {
			break
		}

		return e.complexity.FlexStopTime.Arrival(childComplexity), true

	case "FlexStopTime.arrival_time":
		if e.complexity.FlexStopTime.ArrivalTime == nil {
			break
		}

		return e.complexity.FlexStopTime.ArrivalTime(childComplexity), true

	case "FlexStopTime.continuous_drop_off":
		if e.complexity.FlexStopTime.ContinuousDropOff == nil {
			break
		}

		return e.complexity.FlexStopTime.ContinuousDropOff(childComplexity), true

	case "FlexStopTime.continuous_pickup":
		if e.complexity.FlexStopTime.ContinuousPickup == nil {
			break
		}

		return e.complexity.FlexStopTime.ContinuousPickup(childComplexity), true

	case "FlexStopTime.date":
		if e.complexity.FlexStopTime.Date == nil {
			break
		}

		return e.complexity.FlexStopTime.Date(childComplexity), true

	case "FlexStopTime.departure":
		if e.complexity.FlexStopTime.Departure == nil {
			break
		}

		return e.complexity.FlexStopTime.Departure(childComplexity), true

	case "FlexStopTime.departure_time":
		if e.complexity.FlexStopTime.DepartureTime == nil {
			break
		}

		return e.complexity.FlexStopTime.DepartureTime(childComplexity), true

	case "FlexStopTime.drop_off_booking_rule":
		if e.complexity.FlexStopTime.DropOffBookingRule == nil {
			break
		}

		return e.complexity.FlexStopTime.DropOffBookingRule(childComplexity), true

	case "FlexStopTime.drop_off_type":
		if e.complexity.FlexStopTime.DropOffType == nil {
			break
		}

		return e.complexity.FlexStopTime.DropOffType(childComplexity), true

	case "FlexStopTime.end_pickup_drop_off_window":
		if e.complexity.FlexStopTime.EndPickupDropOffWindow == nil {
			break
		}

		return e.complexity.FlexStopTime.EndPickupDropOffWindow(childComplexity), true

	case "FlexStopTime.interpolated":
		if e.complexity.FlexStopTime.Interpolated == nil {
			break
		}

		return e.complexity.FlexStopTime.Interpolated(childComplexity), true

	case "FlexStopTime.location":
		if e.complexity.FlexStopTime.Location == nil {
			break
		}

		return e.complexity.FlexStopTime.Location(childComplexity), true

	case "FlexStopTime.location_group":
		if e.complexity.FlexStopTime.LocationGroup == nil {
			break
		}

		return e.complexity.FlexStopTime.LocationGroup(childComplexity), true

	case "FlexStopTime.pickup_booking_rule":
		if e.complexity.FlexStopTime.PickupBookingRule == nil {
			break
		}

		return e.complexity.FlexStopTime.PickupBookingRule(childComplexity), true

	case "FlexStopTime.pickup_type":
		if e.complexity.FlexStopTime.PickupType == nil {
			break
		}

		return e.complexity.FlexStopTime.PickupType(childComplexity), true

	case "FlexStopTime.schedule_relationship":
		if e.complexity.FlexStopTime.ScheduleRelationship == nil {
			break
		}

		return e.complexity.FlexStopTime.ScheduleRelationship(childComplexity), true

	case "FlexStopTime.service_date":
		if e.complexity.FlexStopTime.ServiceDate == nil {
			break
		}

		return e.complexity.FlexStopTime.ServiceDate(childComplexity), true

	case "FlexStopTime.shape_dist_traveled":
		if e.complexity.FlexStopTime.ShapeDistTraveled == nil {
			break
		}

		return e.complexity.FlexStopTime.ShapeDistTraveled(childComplexity), true

	case "FlexStopTime.start_pickup_drop_off_window":
		if e.complexity.FlexStopTime.StartPickupDropOffWindow == nil {
			break
		}

		return e.complexity.FlexStopTime.StartPickupDropOffWindow(childComplexity), true

	case "FlexStopTime.stop_headsign":
		if e.complexity.FlexStopTime.StopHeadsign == nil {
			break
		}

		return e.complexity.FlexStopTime.StopHeadsign(childComplexity), true

	case "FlexStopTime.stop_sequence":
		if e.complexity.FlexStopTime.StopSequence == nil {
			break
		}

		return e.complexity.FlexStopTime.StopSequence(childComplexity), true

	case "FlexStopTime.timepoint":
		if e.complexity.FlexStopTime.Timepoint == nil {
			break
		}

		return e.complexity.FlexStopTime.Timepoint(childComplexity), true

	case "FlexStopTime.trip":
		if e.complexity.FlexStopTime.Trip == nil {
			break
		}

		return e.complexity.FlexStopTime.Trip(childComplexity), true

	case "Frequency.end_time":
		if e.complexity.Frequency.EndTime == nil {
			break
		}

		return e.complexity.Frequency.EndTime(childComplexity), true

	case "Frequency.exact_times":
		if e.complexity.Frequency.ExactTimes == nil {
			break
		}

		return e.complexity.Frequency.ExactTimes(childComplexity), true

	case "Frequency.headway_secs":
		if e.complexity.Frequency.HeadwaySecs == nil {
			break
		}

		return e.complexity.Frequency.HeadwaySecs(childComplexity), true

	case "Frequency.id":
		if e.complexity.Frequency.ID == nil {
			break
		}

		return e.complexity.Frequency.ID(childComplexity), true

	case "Frequency.start_time":
		if e.complexity.Frequency.StartTime == nil {
			break
		}

		return e.complexity.Frequency.StartTime(childComplexity), true

	case "GbfsAlertTime.end":
		if e.complexity.GbfsAlertTime.End == nil {
			break
		}

		return e.complexity.GbfsAlertTime.End(childComplexity), true

	case "GbfsAlertTime.start":
		if e.complexity.GbfsAlertTime.Start == nil {
			break
		}

		return e.complexity.GbfsAlertTime.Start(childComplexity), true

	case "GbfsBrandAsset.brand_image_url":
		if e.complexity.GbfsBrandAsset.BrandImageURL == nil {
			break
		}

		return e.complexity.GbfsBrandAsset.BrandImageURL(childComplexity), true

	case "GbfsBrandAsset.brand_image_url_dark":
		if e.complexity.GbfsBrandAsset.BrandImageURLDark == nil {
			break
		}

		return e.complexity.GbfsBrandAsset.BrandImageURLDark(childComplexity), true

	case "GbfsBrandAsset.brand_last_modified":
		if e.complexity.GbfsBrandAsset.BrandLastModified == nil {
			break
		}

		return e.complexity.GbfsBrandAsset.BrandLastModified(childComplexity), true

	case "GbfsBrandAsset.brand_terms_url":
		if e.complexity.GbfsBrandAsset.BrandTermsURL == nil {
			break
		}

		return e.complexity.GbfsBrandAsset.BrandTermsURL(childComplexity), true

	case "GbfsBrandAsset.color":
		if e.complexity.GbfsBrandAsset.Color == nil {
			break
		}

		return e.complexity.GbfsBrandAsset.Color(childComplexity), true

	case "GbfsFeed.alerts":
		if e.complexity.GbfsFeed.Alerts == nil {
			break
		}

		return e.complexity.GbfsFeed.Alerts(childComplexity), true

	case "GbfsFeed.calendars":
		if e.complexity.GbfsFeed.Calendars == nil {
			break
		}

		return e.complexity.GbfsFeed.Calendars(childComplexity), true

	case "GbfsFeed.rental_hours":
		if e.complexity.GbfsFeed.RentalHours == nil {
			break
		}

		return e.complexity.GbfsFeed.RentalHours(childComplexity), true

	case "GbfsFeed.station_information":
		if e.complexity.GbfsFeed.StationInformation == nil {
			break
		}

		return e.complexity.GbfsFeed.StationInformation(childComplexity), true

	case "GbfsFeed.system_information":
		if e.complexity.GbfsFeed.SystemInformation == nil {
			break
		}

		return e.complexity.GbfsFeed.SystemInformation(childComplexity), true

	case "GbfsFreeBikeStatus.available_until":
		if e.complexity.GbfsFreeBikeStatus.AvailableUntil == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.AvailableUntil(childComplexity), true

	case "GbfsFreeBikeStatus.bike_id":
		if e.complexity.GbfsFreeBikeStatus.BikeID == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.BikeID(childComplexity), true

	case "GbfsFreeBikeStatus.current_fuel_percent":
		if e.complexity.GbfsFreeBikeStatus.CurrentFuelPercent == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.CurrentFuelPercent(childComplexity), true

	case "GbfsFreeBikeStatus.current_range_meters":
		if e.complexity.GbfsFreeBikeStatus.CurrentRangeMeters == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.CurrentRangeMeters(childComplexity), true

	case "GbfsFreeBikeStatus.feed":
		if e.complexity.GbfsFreeBikeStatus.Feed == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.Feed(childComplexity), true

	case "GbfsFreeBikeStatus.home_station":
		if e.complexity.GbfsFreeBikeStatus.HomeStation == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.HomeStation(childComplexity), true

	case "GbfsFreeBikeStatus.is_disabled":
		if e.complexity.GbfsFreeBikeStatus.IsDisabled == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.IsDisabled(childComplexity), true

	case "GbfsFreeBikeStatus.is_reserved":
		if e.complexity.GbfsFreeBikeStatus.IsReserved == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.IsReserved(childComplexity), true

	case "GbfsFreeBikeStatus.last_reported":
		if e.complexity.GbfsFreeBikeStatus.LastReported == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.LastReported(childComplexity), true

	case "GbfsFreeBikeStatus.lat":
		if e.complexity.GbfsFreeBikeStatus.Lat == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.Lat(childComplexity), true

	case "GbfsFreeBikeStatus.lon":
		if e.complexity.GbfsFreeBikeStatus.Lon == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.Lon(childComplexity), true

	case "GbfsFreeBikeStatus.pricing_plan":
		if e.complexity.GbfsFreeBikeStatus.PricingPlan == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.PricingPlan(childComplexity), true

	case "GbfsFreeBikeStatus.rental_uris":
		if e.complexity.GbfsFreeBikeStatus.RentalUris == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.RentalUris(childComplexity), true

	case "GbfsFreeBikeStatus.station":
		if e.complexity.GbfsFreeBikeStatus.Station == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.Station(childComplexity), true

	case "GbfsFreeBikeStatus.vehicle_equipment":
		if e.complexity.GbfsFreeBikeStatus.VehicleEquipment == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.VehicleEquipment(childComplexity), true

	case "GbfsFreeBikeStatus.vehicle_type":
		if e.complexity.GbfsFreeBikeStatus.VehicleType == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.VehicleType(childComplexity), true

	case "GbfsGeofenceFeature.geometry":
		if e.complexity.GbfsGeofenceFeature.Geometry == nil {
			break
		}

		return e.complexity.GbfsGeofenceFeature.Geometry(childComplexity), true

	case "GbfsGeofenceFeature.type":
		if e.complexity.GbfsGeofenceFeature.Type == nil {
			break
		}

		return e.complexity.GbfsGeofenceFeature.Type(childComplexity), true

	case "GbfsGeofenceProperty.end":
		if e.complexity.GbfsGeofenceProperty.End == nil {
			break
		}

		return e.complexity.GbfsGeofenceProperty.End(childComplexity), true

	case "GbfsGeofenceProperty.name":
		if e.complexity.GbfsGeofenceProperty.Name == nil {
			break
		}

		return e.complexity.GbfsGeofenceProperty.Name(childComplexity), true

	case "GbfsGeofenceProperty.rules":
		if e.complexity.GbfsGeofenceProperty.Rules == nil {
			break
		}

		return e.complexity.GbfsGeofenceProperty.Rules(childComplexity), true

	case "GbfsGeofenceProperty.start":
		if e.complexity.GbfsGeofenceProperty.Start == nil {
			break
		}

		return e.complexity.GbfsGeofenceProperty.Start(childComplexity), true

	case "GbfsGeofenceRule.maximum_speed_kph":
		if e.complexity.GbfsGeofenceRule.MaximumSpeedKph == nil {
			break
		}

		return e.complexity.GbfsGeofenceRule.MaximumSpeedKph(childComplexity), true

	case "GbfsGeofenceRule.ride_allowed":
		if e.complexity.GbfsGeofenceRule.RideAllowed == nil {
			break
		}

		return e.complexity.GbfsGeofenceRule.RideAllowed(childComplexity), true

	case "GbfsGeofenceRule.ride_through_allowed":
		if e.complexity.GbfsGeofenceRule.RideThroughAllowed == nil {
			break
		}

		return e.complexity.GbfsGeofenceRule.RideThroughAllowed(childComplexity), true

	case "GbfsGeofenceRule.station_parking":
		if e.complexity.GbfsGeofenceRule.StationParking == nil {
			break
		}

		return e.complexity.GbfsGeofenceRule.StationParking(childComplexity), true

	case "GbfsGeofenceRule.vehicle_type":
		if e.complexity.GbfsGeofenceRule.VehicleType == nil {
			break
		}

		return e.complexity.GbfsGeofenceRule.VehicleType(childComplexity), true

	case "GbfsGeofenceZone.features":
		if e.complexity.GbfsGeofenceZone.Features == nil {
			break
		}

		return e.complexity.GbfsGeofenceZone.Features(childComplexity), true

	case "GbfsGeofenceZone.type":
		if e.complexity.GbfsGeofenceZone.Type == nil {
			break
		}

		return e.complexity.GbfsGeofenceZone.Type(childComplexity), true

	case "GbfsPlanPrice.end":
		if e.complexity.GbfsPlanPrice.End == nil {
			break
		}

		return e.complexity.GbfsPlanPrice.End(childComplexity), true

	case "GbfsPlanPrice.interval":
		if e.complexity.GbfsPlanPrice.Interval == nil {
			break
		}

		return e.complexity.GbfsPlanPrice.Interval(childComplexity), true

	case "GbfsPlanPrice.rate":
		if e.complexity.GbfsPlanPrice.Rate == nil {
			break
		}

		return e.complexity.GbfsPlanPrice.Rate(childComplexity), true

	case "GbfsPlanPrice.start":
		if e.complexity.GbfsPlanPrice.Start == nil {
			break
		}

		return e.complexity.GbfsPlanPrice.Start(childComplexity), true

	case "GbfsRentalApp.discovery_uri":
		if e.complexity.GbfsRentalApp.DiscoveryURI == nil {
			break
		}

		return e.complexity.GbfsRentalApp.DiscoveryURI(childComplexity), true

	case "GbfsRentalApp.store_uri":
		if e.complexity.GbfsRentalApp.StoreURI == nil {
			break
		}

		return e.complexity.GbfsRentalApp.StoreURI(childComplexity), true

	case "GbfsRentalApps.android":
		if e.complexity.GbfsRentalApps.Android == nil {
			break
		}

		return e.complexity.GbfsRentalApps.Android(childComplexity), true

	case "GbfsRentalApps.ios":
		if e.complexity.GbfsRentalApps.Ios == nil {
			break
		}

		return e.complexity.GbfsRentalApps.Ios(childComplexity), true

	case "GbfsRentalUris.android":
		if e.complexity.GbfsRentalUris.Android == nil {
			break
		}

		return e.complexity.GbfsRentalUris.Android(childComplexity), true

	case "GbfsRentalUris.ios":
		if e.complexity.GbfsRentalUris.IOS == nil {
			break
		}

		return e.complexity.GbfsRentalUris.IOS(childComplexity), true

	case "GbfsRentalUris.web":
		if e.complexity.GbfsRentalUris.Web == nil {
			break
		}

		return e.complexity.GbfsRentalUris.Web(childComplexity), true

	case "GbfsStationInformation.address":
		if e.complexity.GbfsStationInformation.Address == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Address(childComplexity), true

	case "GbfsStationInformation.capacity":
		if e.complexity.GbfsStationInformation.Capacity == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Capacity(childComplexity), true

	case "GbfsStationInformation.contact_phone":
		if e.complexity.GbfsStationInformation.ContactPhone == nil {
			break
		}

		return e.complexity.GbfsStationInformation.ContactPhone(childComplexity), true

	case "GbfsStationInformation.cross_street":
		if e.complexity.GbfsStationInformation.CrossStreet == nil {
			break
		}

		return e.complexity.GbfsStationInformation.CrossStreet(childComplexity), true

	case "GbfsStationInformation.feed":
		if e.complexity.GbfsStationInformation.Feed == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Feed(childComplexity), true

	case "GbfsStationInformation.is_charging_station":
		if e.complexity.GbfsStationInformation.IsChargingStation == nil {
			break
		}

		return e.complexity.GbfsStationInformation.IsChargingStation(childComplexity), true

	case "GbfsStationInformation.is_valet_station":
		if e.complexity.GbfsStationInformation.IsValetStation == nil {
			break
		}

		return e.complexity.GbfsStationInformation.IsValetStation(childComplexity), true

	case "GbfsStationInformation.is_virtual_station":
		if e.complexity.GbfsStationInformation.IsVirtualStation == nil {
			break
		}

		return e.complexity.GbfsStationInformation.IsVirtualStation(childComplexity), true

	case "GbfsStationInformation.lat":
		if e.complexity.GbfsStationInformation.Lat == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Lat(childComplexity), true

	case "GbfsStationInformation.lon":
		if e.complexity.GbfsStationInformation.Lon == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Lon(childComplexity), true

	case "GbfsStationInformation.name":
		if e.complexity.GbfsStationInformation.Name == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Name(childComplexity), true

	case "GbfsStationInformation.parking_hoop":
		if e.complexity.GbfsStationInformation.ParkingHoop == nil {
			break
		}

		return e.complexity.GbfsStationInformation.ParkingHoop(childComplexity), true

	case "GbfsStationInformation.parking_type":
		if e.complexity.GbfsStationInformation.ParkingType == nil {
			break
		}

		return e.complexity.GbfsStationInformation.ParkingType(childComplexity), true

	case "GbfsStationInformation.post_code":
		if e.complexity.GbfsStationInformation.PostCode == nil {
			break
		}

		return e.complexity.GbfsStationInformation.PostCode(childComplexity), true

	case "GbfsStationInformation.region":
		if e.complexity.GbfsStationInformation.Region == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Region(childComplexity), true

	case "GbfsStationInformation.rental_methods":
		if e.complexity.GbfsStationInformation.RentalMethods == nil {
			break
		}

		return e.complexity.GbfsStationInformation.RentalMethods(childComplexity), true

	case "GbfsStationInformation.short_name":
		if e.complexity.GbfsStationInformation.ShortName == nil {
			break
		}

		return e.complexity.GbfsStationInformation.ShortName(childComplexity), true

	case "GbfsStationInformation.station_area":
		if e.complexity.GbfsStationInformation.StationArea == nil {
			break
		}

		return e.complexity.GbfsStationInformation.StationArea(childComplexity), true

	case "GbfsStationInformation.station_id":
		if e.complexity.GbfsStationInformation.StationID == nil {
			break
		}

		return e.complexity.GbfsStationInformation.StationID(childComplexity), true

	case "GbfsStationInformation.status":
		if e.complexity.GbfsStationInformation.Status == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Status(childComplexity), true

	case "GbfsStationStatus.is_installed":
		if e.complexity.GbfsStationStatus.IsInstalled == nil {
			break
		}

		return e.complexity.GbfsStationStatus.IsInstalled(childComplexity), true

	case "GbfsStationStatus.is_renting":
		if e.complexity.GbfsStationStatus.IsRenting == nil {
			break
		}

		return e.complexity.GbfsStationStatus.IsRenting(childComplexity), true

	case "GbfsStationStatus.is_returning":
		if e.complexity.GbfsStationStatus.IsReturning == nil {
			break
		}

		return e.complexity.GbfsStationStatus.IsReturning(childComplexity), true

	case "GbfsStationStatus.last_reported":
		if e.complexity.GbfsStationStatus.LastReported == nil {
			break
		}

		return e.complexity.GbfsStationStatus.LastReported(childComplexity), true

	case "GbfsStationStatus.num_bikes_available":
		if e.complexity.GbfsStationStatus.NumBikesAvailable == nil {
			break
		}

		return e.complexity.GbfsStationStatus.NumBikesAvailable(childComplexity), true

	case "GbfsStationStatus.num_bikes_disabled":
		if e.complexity.GbfsStationStatus.NumBikesDisabled == nil {
			break
		}

		return e.complexity.GbfsStationStatus.NumBikesDisabled(childComplexity), true

	case "GbfsStationStatus.num_docks_available":
		if e.complexity.GbfsStationStatus.NumDocksAvailable == nil {
			break
		}

		return e.complexity.GbfsStationStatus.NumDocksAvailable(childComplexity), true

	case "GbfsStationStatus.num_docks_disabled":
		if e.complexity.GbfsStationStatus.NumDocksDisabled == nil {
			break
		}

		return e.complexity.GbfsStationStatus.NumDocksDisabled(childComplexity), true

	case "GbfsStationStatus.station_id":
		if e.complexity.GbfsStationStatus.StationID == nil {
			break
		}

		return e.complexity.GbfsStationStatus.StationID(childComplexity), true

	case "GbfsStationStatus.vehicle_docks_available":
		if e.complexity.GbfsStationStatus.VehicleDocksAvailable == nil {
			break
		}

		return e.complexity.GbfsStationStatus.VehicleDocksAvailable(childComplexity), true

	case "GbfsStationStatus.vehicle_types_available":
		if e.complexity.GbfsStationStatus.VehicleTypesAvailable == nil {
			break
		}

		return e.complexity.GbfsStationStatus.VehicleTypesAvailable(childComplexity), true

	case "GbfsSystemAlert.alert_id":
		if e.complexity.GbfsSystemAlert.AlertID == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.AlertID(childComplexity), true

	case "GbfsSystemAlert.description":
		if e.complexity.GbfsSystemAlert.Description == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.Description(childComplexity), true

	case "GbfsSystemAlert.last_updated":
		if e.complexity.GbfsSystemAlert.LastUpdated == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.LastUpdated(childComplexity), true

	case "GbfsSystemAlert.summary":
		if e.complexity.GbfsSystemAlert.Summary == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.Summary(childComplexity), true

	case "GbfsSystemAlert.times":
		if e.complexity.GbfsSystemAlert.Times == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.Times(childComplexity), true

	case "GbfsSystemAlert.type":
		if e.complexity.GbfsSystemAlert.Type == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.Type(childComplexity), true

	case "GbfsSystemAlert.url":
		if e.complexity.GbfsSystemAlert.URL == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.URL(childComplexity), true

	case "GbfsSystemCalendar.end_day":
		if e.complexity.GbfsSystemCalendar.EndDay == nil {
			break
		}

		return e.complexity.GbfsSystemCalendar.EndDay(childComplexity), true

	case "GbfsSystemCalendar.end_month":
		if e.complexity.GbfsSystemCalendar.EndMonth == nil {
			break
		}

		return e.complexity.GbfsSystemCalendar.EndMonth(childComplexity), true

	case "GbfsSystemCalendar.end_year":
		if e.complexity.GbfsSystemCalendar.EndYear == nil {
			break
		}

		return e.complexity.GbfsSystemCalendar.EndYear(childComplexity), true

	case "GbfsSystemCalendar.start_day":
		if e.complexity.GbfsSystemCalendar.StartDay == nil {
			break
		}

		return e.complexity.GbfsSystemCalendar.StartDay(childComplexity), true

	case "GbfsSystemCalendar.start_month":
		if e.complexity.GbfsSystemCalendar.StartMonth == nil {
			break
		}

		return e.complexity.GbfsSystemCalendar.StartMonth(childComplexity), true

	case "GbfsSystemCalendar.start_year":
		if e.complexity.GbfsSystemCalendar.StartYear == nil {
			break
		}

		return e.complexity.GbfsSystemCalendar.StartYear(childComplexity), true

	case "GbfsSystemHour.days":
		if e.complexity.GbfsSystemHour.Days == nil {
			break
		}

		return e.complexity.GbfsSystemHour.Days(childComplexity), true

	case "GbfsSystemHour.end_time":
		if e.complexity.GbfsSystemHour.EndTime == nil {
			break
		}

		return e.complexity.GbfsSystemHour.EndTime(childComplexity), true

	case "GbfsSystemHour.start_time":
		if e.complexity.GbfsSystemHour.StartTime == nil {
			break
		}

		return e.complexity.GbfsSystemHour.StartTime(childComplexity), true

	case "GbfsSystemHour.user_types":
		if e.complexity.GbfsSystemHour.UserTypes == nil {
			break
		}

		return e.complexity.GbfsSystemHour.UserTypes(childComplexity), true

	case "GbfsSystemInformation.brand_assets":
		if e.complexity.GbfsSystemInformation.BrandAssets == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.BrandAssets(childComplexity), true

	case "GbfsSystemInformation.email":
		if e.complexity.GbfsSystemInformation.Email == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.Email(childComplexity), true

	case "GbfsSystemInformation.feed_contact_email":
		if e.complexity.GbfsSystemInformation.FeedContactEmail == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.FeedContactEmail(childComplexity), true

	case "GbfsSystemInformation.language":
		if e.complexity.GbfsSystemInformation.Language == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.Language(childComplexity), true

	case "GbfsSystemInformation.license_url":
		if e.complexity.GbfsSystemInformation.LicenseURL == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.LicenseURL(childComplexity), true

	case "GbfsSystemInformation.name":
		if e.complexity.GbfsSystemInformation.Name == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.Name(childComplexity), true

	case "GbfsSystemInformation.operator":
		if e.complexity.GbfsSystemInformation.Operator == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.Operator(childComplexity), true

	case "GbfsSystemInformation.phone_number":
		if e.complexity.GbfsSystemInformation.PhoneNumber == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.PhoneNumber(childComplexity), true

	case "GbfsSystemInformation.privacy_last_updated":
		if e.complexity.GbfsSystemInformation.PrivacyLastUpdated == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.PrivacyLastUpdated(childComplexity), true

	case "GbfsSystemInformation.privacy_url":
		if e.complexity.GbfsSystemInformation.PrivacyURL == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.PrivacyURL(childComplexity), true

	case "GbfsSystemInformation.purchase_url":
		if e.complexity.GbfsSystemInformation.PurchaseURL == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.PurchaseURL(childComplexity), true

	case "GbfsSystemInformation.rental_apps":
		if e.complexity.GbfsSystemInformation.RentalApps == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.RentalApps(childComplexity), true

	case "GbfsSystemInformation.short_name":
		if e.complexity.GbfsSystemInformation.ShortName == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.ShortName(childComplexity), true

	case "GbfsSystemInformation.start_date":
		if e.complexity.GbfsSystemInformation.StartDate == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.StartDate(childComplexity), true

	case "GbfsSystemInformation.system_id":
		if e.complexity.GbfsSystemInformation.SystemID == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.SystemID(childComplexity), true

	case "GbfsSystemInformation.terms_last_updated":
		if e.complexity.GbfsSystemInformation.TermsLastUpdated == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.TermsLastUpdated(childComplexity), true

	case "GbfsSystemInformation.terms_url":
		if e.complexity.GbfsSystemInformation.TermsURL == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.TermsURL(childComplexity), true

	case "GbfsSystemInformation.timezone":
		if e.complexity.GbfsSystemInformation.Timezone == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.Timezone(childComplexity), true

	case "GbfsSystemInformation.url":
		if e.complexity.GbfsSystemInformation.URL == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.URL(childComplexity), true

	case "GbfsSystemPricingPlan.currency":
		if e.complexity.GbfsSystemPricingPlan.Currency == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.Currency(childComplexity), true

	case "GbfsSystemPricingPlan.description":
		if e.complexity.GbfsSystemPricingPlan.Description == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.Description(childComplexity), true

	case "GbfsSystemPricingPlan.is_taxable":
		if e.complexity.GbfsSystemPricingPlan.IsTaxable == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.IsTaxable(childComplexity), true

	case "GbfsSystemPricingPlan.name":
		if e.complexity.GbfsSystemPricingPlan.Name == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.Name(childComplexity), true

	case "GbfsSystemPricingPlan.per_km_pricing":
		if e.complexity.GbfsSystemPricingPlan.PerKmPricing == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.PerKmPricing(childComplexity), true

	case "GbfsSystemPricingPlan.per_min_pricing":
		if e.complexity.GbfsSystemPricingPlan.PerMinPricing == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.PerMinPricing(childComplexity), true

	case "GbfsSystemPricingPlan.plan_id":
		if e.complexity.GbfsSystemPricingPlan.PlanID == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.PlanID(childComplexity), true

	case "GbfsSystemPricingPlan.price":
		if e.complexity.GbfsSystemPricingPlan.Price == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.Price(childComplexity), true

	case "GbfsSystemPricingPlan.surge_pricing":
		if e.complexity.GbfsSystemPricingPlan.SurgePricing == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.SurgePricing(childComplexity), true

	case "GbfsSystemPricingPlan.url":
		if e.complexity.GbfsSystemPricingPlan.URL == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.URL(childComplexity), true

	case "GbfsSystemRegion.name":
		if e.complexity.GbfsSystemRegion.Name == nil {
			break
		}

		return e.complexity.GbfsSystemRegion.Name(childComplexity), true

	case "GbfsSystemRegion.region_id":
		if e.complexity.GbfsSystemRegion.RegionID == nil {
			break
		}

		return e.complexity.GbfsSystemRegion.RegionID(childComplexity), true

	case "GbfsSystemVersion.url":
		if e.complexity.GbfsSystemVersion.URL == nil {
			break
		}

		return e.complexity.GbfsSystemVersion.URL(childComplexity), true

	case "GbfsSystemVersion.version":
		if e.complexity.GbfsSystemVersion.Version == nil {
			break
		}

		return e.complexity.GbfsSystemVersion.Version(childComplexity), true

	case "GbfsVehicleAssets.icon_last_modified":
		if e.complexity.GbfsVehicleAssets.IconLastModified == nil {
			break
		}

		return e.complexity.GbfsVehicleAssets.IconLastModified(childComplexity), true

	case "GbfsVehicleAssets.icon_url":
		if e.complexity.GbfsVehicleAssets.IconURL == nil {
			break
		}

		return e.complexity.GbfsVehicleAssets.IconURL(childComplexity), true

	case "GbfsVehicleAssets.icon_url_dark":
		if e.complexity.GbfsVehicleAssets.IconURLDark == nil {
			break
		}

		return e.complexity.GbfsVehicleAssets.IconURLDark(childComplexity), true

	case "GbfsVehicleDockAvailable.count":
		if e.complexity.GbfsVehicleDockAvailable.Count == nil {
			break
		}

		return e.complexity.GbfsVehicleDockAvailable.Count(childComplexity), true

	case "GbfsVehicleDockAvailable.vehicle_types":
		if e.complexity.GbfsVehicleDockAvailable.VehicleTypes == nil {
			break
		}

		return e.complexity.GbfsVehicleDockAvailable.VehicleTypes(childComplexity), true

	case "GbfsVehicleType.cargo_load_capacity":
		if e.complexity.GbfsVehicleType.CargoLoadCapacity == nil {
			break
		}

		return e.complexity.GbfsVehicleType.CargoLoadCapacity(childComplexity), true

	case "GbfsVehicleType.cargo_volume_capacity":
		if e.complexity.GbfsVehicleType.CargoVolumeCapacity == nil {
			break
		}

		return e.complexity.GbfsVehicleType.CargoVolumeCapacity(childComplexity), true

	case "GbfsVehicleType.color":
		if e.complexity.GbfsVehicleType.Color == nil {
			break
		}

		return e.complexity.GbfsVehicleType.Color(childComplexity), true

	case "GbfsVehicleType.country_code":
		if e.complexity.GbfsVehicleType.CountryCode == nil {
			break
		}

		return e.complexity.GbfsVehicleType.CountryCode(childComplexity), true

	case "GbfsVehicleType.default_pricing_plan":
		if e.complexity.GbfsVehicleType.DefaultPricingPlan == nil {
			break
		}

		return e.complexity.GbfsVehicleType.DefaultPricingPlan(childComplexity), true

	case "GbfsVehicleType.default_reserve_time":
		if e.complexity.GbfsVehicleType.DefaultReserveTime == nil {
			break
		}

		return e.complexity.GbfsVehicleType.DefaultReserveTime(childComplexity), true

	case "GbfsVehicleType.eco_label":
		if e.complexity.GbfsVehicleType.EcoLabel == nil {
			break
		}

		return e.complexity.GbfsVehicleType.EcoLabel(childComplexity), true

	case "GbfsVehicleType.eco_sticker":
		if e.complexity.GbfsVehicleType.EcoSticker == nil {
			break
		}

		return e.complexity.GbfsVehicleType.EcoSticker(childComplexity), true

	case "GbfsVehicleType.form_factor":
		if e.complexity.GbfsVehicleType.FormFactor == nil {
			break
		}

		return e.complexity.GbfsVehicleType.FormFactor(childComplexity), true

	case "GbfsVehicleType.gco_2_km":
		if e.complexity.GbfsVehicleType.GCO2Km == nil {
			break
		}

		return e.complexity.GbfsVehicleType.GCO2Km(childComplexity), true

	case "GbfsVehicleType.make":
		if e.complexity.GbfsVehicleType.Make == nil {
			break
		}

		return e.complexity.GbfsVehicleType.Make(childComplexity), true

	case "GbfsVehicleType.max_permitted_speed":
		if e.complexity.GbfsVehicleType.MaxPermittedSpeed == nil {
			break
		}

		return e.complexity.GbfsVehicleType.MaxPermittedSpeed(childComplexity), true

	case "GbfsVehicleType.max_range_meters":
		if e.complexity.GbfsVehicleType.MaxRangeMeters == nil {
			break
		}

		return e.complexity.GbfsVehicleType.MaxRangeMeters(childComplexity), true

	case "GbfsVehicleType.model":
		if e.complexity.GbfsVehicleType.Model == nil {
			break
		}

		return e.complexity.GbfsVehicleType.Model(childComplexity), true

	case "GbfsVehicleType.name":
		if e.complexity.GbfsVehicleType.Name == nil {
			break
		}

		return e.complexity.GbfsVehicleType.Name(childComplexity), true

	case "GbfsVehicleType.pricing_plans":
		if e.complexity.GbfsVehicleType.PricingPlans == nil {
			break
		}

		return e.complexity.GbfsVehicleType.PricingPlans(childComplexity), true

	case "GbfsVehicleType.propulsion_type":
		if e.complexity.GbfsVehicleType.PropulsionType == nil {
			break
		}

		return e.complexity.GbfsVehicleType.PropulsionType(childComplexity), true

	case "GbfsVehicleType.rated_power":
		if e.complexity.GbfsVehicleType.RatedPower == nil {
			break
		}

		return e.complexity.GbfsVehicleType.RatedPower(childComplexity), true

	case "GbfsVehicleType.rental_uris":
		if e.complexity.GbfsVehicleType.RentalUris == nil {
			break
		}

		return e.complexity.GbfsVehicleType.RentalUris(childComplexity), true

	case "GbfsVehicleType.return_constraint":
		if e.complexity.GbfsVehicleType.ReturnConstraint == nil {
			break
		}

		return e.complexity.GbfsVehicleType.ReturnConstraint(childComplexity), true

	case "GbfsVehicleType.rider_capacity":
		if e.complexity.GbfsVehicleType.RiderCapacity == nil {
			break
		}

		return e.complexity.GbfsVehicleType.RiderCapacity(childComplexity), true

	case "GbfsVehicleType.vehicle_accessories":
		if e.complexity.GbfsVehicleType.VehicleAccessories == nil {
			break
		}

		return e.complexity.GbfsVehicleType.VehicleAccessories(childComplexity), true

	case "GbfsVehicleType.vehicle_assets":
		if e.complexity.GbfsVehicleType.VehicleAssets == nil {
			break
		}

		return e.complexity.GbfsVehicleType.VehicleAssets(childComplexity), true

	case "GbfsVehicleType.vehicle_image":
		if e.complexity.GbfsVehicleType.VehicleImage == nil {
			break
		}

		return e.complexity.GbfsVehicleType.VehicleImage(childComplexity), true

	case "GbfsVehicleType.vehicle_type_id":
		if e.complexity.GbfsVehicleType.VehicleTypeID == nil {
			break
		}

		return e.complexity.GbfsVehicleType.VehicleTypeID(childComplexity), true

	case "GbfsVehicleType.wheel_count":
		if e.complexity.GbfsVehicleType.WheelCount == nil {
			break
		}

		return e.complexity.GbfsVehicleType.WheelCount(childComplexity), true

	case "GbfsVehicleTypeAvailable.count":
		if e.complexity.GbfsVehicleTypeAvailable.Count == nil {
			break
		}

		return e.complexity.GbfsVehicleTypeAvailable.Count(childComplexity), true

	case "GbfsVehicleTypeAvailable.num_bikes_disabled":
		if e.complexity.GbfsVehicleTypeAvailable.NumBikesDisabled == nil {
			break
		}

		return e.complexity.GbfsVehicleTypeAvailable.NumBikesDisabled(childComplexity), true

	case "GbfsVehicleTypeAvailable.num_docks_available":
		if e.complexity.GbfsVehicleTypeAvailable.NumDocksAvailable == nil {
			break
		}

		return e.complexity.GbfsVehicleTypeAvailable.NumDocksAvailable(childComplexity), true

	case "GbfsVehicleTypeAvailable.vehicle_type":
		if e.complexity.GbfsVehicleTypeAvailable.VehicleType == nil {
			break
		}

		return e.complexity.GbfsVehicleTypeAvailable.VehicleType(childComplexity), true

	case "Itinerary.distance":
		if e.complexity.Itinerary.Distance == nil {
			break
		}

		return e.complexity.Itinerary.Distance(childComplexity), true

	case "Itinerary.duration":
		if e.complexity.Itinerary.Duration == nil {
			break
		}

		return e.complexity.Itinerary.Duration(childComplexity), true

	case "Itinerary.end_time":
		if e.complexity.Itinerary.EndTime == nil {
			break
		}

		return e.complexity.Itinerary.EndTime(childComplexity), true

	case "Itinerary.from":
		if e.complexity.Itinerary.From == nil {
			break
		}

		return e.complexity.Itinerary.From(childComplexity), true

	case "Itinerary.legs":
		if e.complexity.Itinerary.Legs == nil {
			break
		}

		return e.complexity.Itinerary.Legs(childComplexity), true

	case "Itinerary.start_time":
		if e.complexity.Itinerary.StartTime == nil {
			break
		}

		return e.complexity.Itinerary.StartTime(childComplexity), true

	case "Itinerary.to":
		if e.complexity.Itinerary.To == nil {
			break
		}

		return e.complexity.Itinerary.To(childComplexity), true

	case "Leg.distance":
		if e.complexity.Leg.Distance == nil {
			break
		}

		return e.complexity.Leg.Distance(childComplexity), true

	case "Leg.duration":
		if e.complexity.Leg.Duration == nil {
			break
		}

		return e.complexity.Leg.Duration(childComplexity), true

	case "Leg.end_time":
		if e.complexity.Leg.EndTime == nil {
			break
		}

		return e.complexity.Leg.EndTime(childComplexity), true

	case "Leg.from":
		if e.complexity.Leg.From == nil {
			break
		}

		return e.complexity.Leg.From(childComplexity), true

	case "Leg.geometry":
		if e.complexity.Leg.Geometry == nil {
			break
		}

		return e.complexity.Leg.Geometry(childComplexity), true

	case "Leg.mode":
		if e.complexity.Leg.Mode == nil {
			break
		}

		return e.complexity.Leg.Mode(childComplexity), true

	case "Leg.start_time":
		if e.complexity.Leg.StartTime == nil {
			break
		}

		return e.complexity.Leg.StartTime(childComplexity), true

	case "Leg.steps":
		if e.complexity.Leg.Steps == nil {
			break
		}

		return e.complexity.Leg.Steps(childComplexity), true

	case "Leg.stops":
		if e.complexity.Leg.Stops == nil {
			break
		}

		return e.complexity.Leg.Stops(childComplexity), true

	case "Leg.to":
		if e.complexity.Leg.To == nil {
			break
		}

		return e.complexity.Leg.To(childComplexity), true

	case "Leg.trip":
		if e.complexity.Leg.Trip == nil {
			break
		}

		return e.complexity.Leg.Trip(childComplexity), true

	case "LegRoute.agency":
		if e.complexity.LegRoute.Agency == nil {
			break
		}

		return e.complexity.LegRoute.Agency(childComplexity), true

	case "LegRoute.route_color":
		if e.complexity.LegRoute.RouteColor == nil {
			break
		}

		return e.complexity.LegRoute.RouteColor(childComplexity), true

	case "LegRoute.route_id":
		if e.complexity.LegRoute.RouteID == nil {
			break
		}

		return e.complexity.LegRoute.RouteID(childComplexity), true

	case "LegRoute.route_long_name":
		if e.complexity.LegRoute.RouteLongName == nil {
			break
		}

		return e.complexity.LegRoute.RouteLongName(childComplexity), true

	case "LegRoute.route_onestop_id":
		if e.complexity.LegRoute.RouteOnestopID == nil {
			break
		}

		return e.complexity.LegRoute.RouteOnestopID(childComplexity), true

	case "LegRoute.route_short_name":
		if e.complexity.LegRoute.RouteShortName == nil {
			break
		}

		return e.complexity.LegRoute.RouteShortName(childComplexity), true

	case "LegRoute.route_text_color":
		if e.complexity.LegRoute.RouteTextColor == nil {
			break
		}

		return e.complexity.LegRoute.RouteTextColor(childComplexity), true

	case "LegRoute.route_type":
		if e.complexity.LegRoute.RouteType == nil {
			break
		}

		return e.complexity.LegRoute.RouteType(childComplexity), true

	case "LegRouteAgency.agency_id":
		if e.complexity.LegRouteAgency.AgencyID == nil {
			break
		}

		return e.complexity.LegRouteAgency.AgencyID(childComplexity), true

	case "LegRouteAgency.agency_name":
		if e.complexity.LegRouteAgency.AgencyName == nil {
			break
		}

		return e.complexity.LegRouteAgency.AgencyName(childComplexity), true

	case "LegRouteAgency.agency_onestop_id":
		if e.complexity.LegRouteAgency.AgencyOnestopID == nil {
			break
		}

		return e.complexity.LegRouteAgency.AgencyOnestopID(childComplexity), true

	case "LegTrip.feed_id":
		if e.complexity.LegTrip.FeedID == nil {
			break
		}

		return e.complexity.LegTrip.FeedID(childComplexity), true

	case "LegTrip.feed_version_sha1":
		if e.complexity.LegTrip.FeedVersionSha1 == nil {
			break
		}

		return e.complexity.LegTrip.FeedVersionSha1(childComplexity), true

	case "LegTrip.headsign":
		if e.complexity.LegTrip.Headsign == nil {
			break
		}

		return e.complexity.LegTrip.Headsign(childComplexity), true

	case "LegTrip.route":
		if e.complexity.LegTrip.Route == nil {
			break
		}

		return e.complexity.LegTrip.Route(childComplexity), true

	case "LegTrip.trip_id":
		if e.complexity.LegTrip.TripID == nil {
			break
		}

		return e.complexity.LegTrip.TripID(childComplexity), true

	case "LegTrip.trip_short_name":
		if e.complexity.LegTrip.TripShortName == nil {
			break
		}

		return e.complexity.LegTrip.TripShortName(childComplexity), true

	case "Level.geometry":
		if e.complexity.Level.Geometry == nil {
			break
		}

		return e.complexity.Level.Geometry(childComplexity), true

	case "Level.id":
		if e.complexity.Level.ID == nil {
			break
		}

		return e.complexity.Level.ID(childComplexity), true

	case "Level.level_id":
		if e.complexity.Level.LevelID == nil {
			break
		}

		return e.complexity.Level.LevelID(childComplexity), true

	case "Level.level_index":
		if e.complexity.Level.LevelIndex == nil {
			break
		}

		return e.complexity.Level.LevelIndex(childComplexity), true

	case "Level.level_name":
		if e.complexity.Level.LevelName == nil {
			break
		}

		return e.complexity.Level.LevelName(childComplexity), true

	case "Level.stops":
		if e.complexity.Level.Stops == nil {
			break
		}

		return e.complexity.Level.Stops(childComplexity), true

	case "Location.feed_onestop_id":
		if e.complexity.Location.FeedOnestopID == nil {
			break
		}

		return e.complexity.Location.FeedOnestopID(childComplexity), true

	case "Location.feed_version":
		if e.complexity.Location.FeedVersion == nil {
			break
		}

		return e.complexity.Location.FeedVersion(childComplexity), true

	case "Location.feed_version_sha1":
		if e.complexity.Location.FeedVersionSHA1 == nil {
			break
		}

		return e.complexity.Location.FeedVersionSHA1(childComplexity), true

	case "Location.geometry":
		if e.complexity.Location.Geometry == nil {
			break
		}

		return e.complexity.Location.Geometry(childComplexity), true

	case "Location.id":
		if e.complexity.Location.ID == nil {
			break
		}

		return e.complexity.Location.ID(childComplexity), true

	case "Location.location_id":
		if e.complexity.Location.LocationID == nil {
			break
		}

		return e.complexity.Location.LocationID(childComplexity), true

	case "Location.stop_desc":
		if e.complexity.Location.StopDesc == nil {
			break
		}

		return e.complexity.Location.StopDesc(childComplexity), true

	case "Location.stop_name":
		if e.complexity.Location.StopName == nil {
			break
		}

		return e.complexity.Location.StopName(childComplexity), true

	case "Location.stop_times":
		if e.complexity.Location.StopTimes == nil {
			break
		}

		args, err := ec.field_Location_stop_times_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Location.StopTimes(childComplexity, args["limit"].(*int), args["where"].(*model.StopTimeFilter)), true

	case "Location.stop_url":
		if e.complexity.Location.StopURL == nil {
			break
		}

		return e.complexity.Location.StopURL(childComplexity), true

	case "Location.zone_id":
		if e.complexity.Location.ZoneID == nil {
			break
		}

		return e.complexity.Location.ZoneID(childComplexity), true

	case "LocationGroup.feed_onestop_id":
		if e.complexity.LocationGroup.FeedOnestopID == nil {
			break
		}

		return e.complexity.LocationGroup.FeedOnestopID(childComplexity), true

	case "LocationGroup.feed_version":
		if e.complexity.LocationGroup.FeedVersion == nil {
			break
		}

		return e.complexity.LocationGroup.FeedVersion(childComplexity), true

	case "LocationGroup.feed_version_sha1":
		if e.complexity.LocationGroup.FeedVersionSHA1 == nil {
			break
		}

		return e.complexity.LocationGroup.FeedVersionSHA1(childComplexity), true

	case "LocationGroup.id":
		if e.complexity.LocationGroup.ID == nil {
			break
		}

		return e.complexity.LocationGroup.ID(childComplexity), true

	case "LocationGroup.location_group_id":
		if e.complexity.LocationGroup.LocationGroupID == nil {
			break
		}

		return e.complexity.LocationGroup.LocationGroupID(childComplexity), true

	case "LocationGroup.location_group_name":
		if e.complexity.LocationGroup.LocationGroupName == nil {
			break
		}

		return e.complexity.LocationGroup.LocationGroupName(childComplexity), true

	case "LocationGroup.stop_times":
		if e.complexity.LocationGroup.StopTimes == nil {
			break
		}

		args, err := ec.field_LocationGroup_stop_times_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.LocationGroup.StopTimes(childComplexity, args["limit"].(*int), args["where"].(*model.StopTimeFilter)), true

	case "LocationGroup.stops":
		if e.complexity.LocationGroup.Stops == nil {
			break
		}

		args, err := ec.field_LocationGroup_stops_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.LocationGroup.Stops(childComplexity, args["limit"].(*int)), true

	case "LocationGroupStop.id":
		if e.complexity.LocationGroupStop.ID == nil {
			break
		}

		return e.complexity.LocationGroupStop.ID(childComplexity), true

	case "LocationGroupStop.location_group":
		if e.complexity.LocationGroupStop.LocationGroup == nil {
			break
		}

		return e.complexity.LocationGroupStop.LocationGroup(childComplexity), true

	case "LocationGroupStop.stop":
		if e.complexity.LocationGroupStop.Stop == nil {
			break
		}

		return e.complexity.LocationGroupStop.Stop(childComplexity), true

	case "Me.email":
		if e.complexity.Me.Email == nil {
			break
		}

		return e.complexity.Me.Email(childComplexity), true

	case "Me.external_data":
		if e.complexity.Me.ExternalData == nil {
			break
		}

		return e.complexity.Me.ExternalData(childComplexity), true

	case "Me.id":
		if e.complexity.Me.ID == nil {
			break
		}

		return e.complexity.Me.ID(childComplexity), true

	case "Me.name":
		if e.complexity.Me.Name == nil {
			break
		}

		return e.complexity.Me.Name(childComplexity), true

	case "Me.roles":
		if e.complexity.Me.Roles == nil {
			break
		}

		return e.complexity.Me.Roles(childComplexity), true

	case "Mutation.feed_version_delete":
		if e.complexity.Mutation.FeedVersionDelete == nil {
			break
		}

		args, err := ec.field_Mutation_feed_version_delete_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FeedVersionDelete(childComplexity, args["id"].(int)), true

	case "Mutation.feed_version_fetch":
		if e.complexity.Mutation.FeedVersionFetch == nil {
			break
		}

		args, err := ec.field_Mutation_feed_version_fetch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FeedVersionFetch(childComplexity, args["file"].(*graphql.Upload), args["url"].(*string), args["feed_onestop_id"].(string)), true

	case "Mutation.feed_version_import":
		if e.complexity.Mutation.FeedVersionImport == nil {
			break
		}

		args, err := ec.field_Mutation_feed_version_import_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FeedVersionImport(childComplexity, args["id"].(int)), true

	case "Mutation.feed_version_unimport":
		if e.complexity.Mutation.FeedVersionUnimport == nil {
			break
		}

		args, err := ec.field_Mutation_feed_version_unimport_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FeedVersionUnimport(childComplexity, args["id"].(int)), true

	case "Mutation.feed_version_update":
		if e.complexity.Mutation.FeedVersionUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_feed_version_update_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FeedVersionUpdate(childComplexity, args["set"].(model.FeedVersionSetInput)), true

	case "Mutation.level_create":
		if e.complexity.Mutation.LevelCreate == nil {
			break
		}

		args, err := ec.field_Mutation_level_create_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LevelCreate(childComplexity, args["set"].(model.LevelSetInput)), true

	case "Mutation.level_delete":
		if e.complexity.Mutation.LevelDelete == nil {
			break
		}

		args, err := ec.field_Mutation_level_delete_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LevelDelete(childComplexity, args["id"].(int)), true

	case "Mutation.level_update":
		if e.complexity.Mutation.LevelUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_level_update_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LevelUpdate(childComplexity, args["set"].(model.LevelSetInput)), true

	case "Mutation.pathway_create":
		if e.complexity.Mutation.PathwayCreate == nil {
			break
		}

		args, err := ec.field_Mutation_pathway_create_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PathwayCreate(childComplexity, args["set"].(model.PathwaySetInput)), true

	case "Mutation.pathway_delete":
		if e.complexity.Mutation.PathwayDelete == nil {
			break
		}

		args, err := ec.field_Mutation_pathway_delete_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PathwayDelete(childComplexity, args["id"].(int)), true

	case "Mutation.pathway_update":
		if e.complexity.Mutation.PathwayUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_pathway_update_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PathwayUpdate(childComplexity, args["set"].(model.PathwaySetInput)), true

	case "Mutation.stop_create":
		if e.complexity.Mutation.StopCreate == nil {
			break
		}

		args, err := ec.field_Mutation_stop_create_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StopCreate(childComplexity, args["set"].(model.StopSetInput)), true

	case "Mutation.stop_delete":
		if e.complexity.Mutation.StopDelete == nil {
			break
		}

		args, err := ec.field_Mutation_stop_delete_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StopDelete(childComplexity, args["id"].(int)), true

	case "Mutation.stop_update":
		if e.complexity.Mutation.StopUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_stop_update_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.StopUpdate(childComplexity, args["set"].(model.StopSetInput)), true

	case "Mutation.validate_gtfs":
		if e.complexity.Mutation.ValidateGtfs == nil {
			break
		}

		args, err := ec.field_Mutation_validate_gtfs_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ValidateGtfs(childComplexity, args["file"].(*graphql.Upload), args["url"].(*string), args["realtime_urls"].([]string)), true

	case "Operator.agencies":
		if e.complexity.Operator.Agencies == nil {
			break
		}

		return e.complexity.Operator.Agencies(childComplexity), true

	case "Operator.feeds":
		if e.complexity.Operator.Feeds == nil {
			break
		}

		args, err := ec.field_Operator_feeds_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Operator.Feeds(childComplexity, args["limit"].(*int), args["where"].(*model.FeedFilter)), true

	case "Operator.file":
		if e.complexity.Operator.File == nil {
			break
		}

		return e.complexity.Operator.File(childComplexity), true

	case "Operator.generated":
		if e.complexity.Operator.Generated == nil {
			break
		}

		return e.complexity.Operator.Generated(childComplexity), true

	case "Operator.id":
		if e.complexity.Operator.ID == nil {
			break
		}

		return e.complexity.Operator.ID(childComplexity), true

	case "Operator.name":
		if e.complexity.Operator.Name == nil {
			break
		}

		return e.complexity.Operator.Name(childComplexity), true

	case "Operator.onestop_id":
		if e.complexity.Operator.OnestopID == nil {
			break
		}

		return e.complexity.Operator.OnestopID(childComplexity), true

	case "Operator.search_rank":
		if e.complexity.Operator.SearchRank == nil {
			break
		}

		return e.complexity.Operator.SearchRank(childComplexity), true

	case "Operator.short_name":
		if e.complexity.Operator.ShortName == nil {
			break
		}

		return e.complexity.Operator.ShortName(childComplexity), true

	case "Operator.tags":
		if e.complexity.Operator.Tags == nil {
			break
		}

		return e.complexity.Operator.Tags(childComplexity), true

	case "Operator.website":
		if e.complexity.Operator.Website == nil {
			break
		}

		return e.complexity.Operator.Website(childComplexity), true

	case "Pathway.from_stop":
		if e.complexity.Pathway.FromStop == nil {
			break
		}

		return e.complexity.Pathway.FromStop(childComplexity), true

	case "Pathway.id":
		if e.complexity.Pathway.ID == nil {
			break
		}

		return e.complexity.Pathway.ID(childComplexity), true

	case "Pathway.is_bidirectional":
		if e.complexity.Pathway.IsBidirectional == nil {
			break
		}

		return e.complexity.Pathway.IsBidirectional(childComplexity), true

	case "Pathway.length":
		if e.complexity.Pathway.Length == nil {
			break
		}

		return e.complexity.Pathway.Length(childComplexity), true

	case "Pathway.max_slope":
		if e.complexity.Pathway.MaxSlope == nil {
			break
		}

		return e.complexity.Pathway.MaxSlope(childComplexity), true

	case "Pathway.min_width":
		if e.complexity.Pathway.MinWidth == nil {
			break
		}

		return e.complexity.Pathway.MinWidth(childComplexity), true

	case "Pathway.pathway_id":
		if e.complexity.Pathway.PathwayID == nil {
			break
		}

		return e.complexity.Pathway.PathwayID(childComplexity), true

	case "Pathway.pathway_mode":
		if e.complexity.Pathway.PathwayMode == nil {
			break
		}

		return e.complexity.Pathway.PathwayMode(childComplexity), true

	case "Pathway.reverse_signposted_as":
		if e.complexity.Pathway.ReverseSignpostedAs == nil {
			break
		}

		return e.complexity.Pathway.ReverseSignpostedAs(childComplexity), true

	case "Pathway.signposted_as":
		if e.complexity.Pathway.SignpostedAs == nil {
			break
		}

		return e.complexity.Pathway.SignpostedAs(childComplexity), true

	case "Pathway.stair_count":
		if e.complexity.Pathway.StairCount == nil {
			break
		}

		return e.complexity.Pathway.StairCount(childComplexity), true

	case "Pathway.to_stop":
		if e.complexity.Pathway.ToStop == nil {
			break
		}

		return e.complexity.Pathway.ToStop(childComplexity), true

	case "Pathway.traversal_time":
		if e.complexity.Pathway.TraversalTime == nil {
			break
		}

		return e.complexity.Pathway.TraversalTime(childComplexity), true

	case "Place.adm0_name":
		if e.complexity.Place.Adm0Name == nil {
			break
		}

		return e.complexity.Place.Adm0Name(childComplexity), true

	case "Place.adm1_name":
		if e.complexity.Place.Adm1Name == nil {
			break
		}

		return e.complexity.Place.Adm1Name(childComplexity), true

	case "Place.city_name":
		if e.complexity.Place.CityName == nil {
			break
		}

		return e.complexity.Place.CityName(childComplexity), true

	case "Place.count":
		if e.complexity.Place.Count == nil {
			break
		}

		return e.complexity.Place.Count(childComplexity), true

	case "Place.operators":
		if e.complexity.Place.Operators == nil {
			break
		}

		return e.complexity.Place.Operators(childComplexity), true

	case "Query.agencies":
		if e.complexity.Query.Agencies == nil {
			break
		}

		args, err := ec.field_Query_agencies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Agencies(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.AgencyFilter)), true

	case "Query.bikes":
		if e.complexity.Query.Bikes == nil {
			break
		}

		args, err := ec.field_Query_bikes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Bikes(childComplexity, args["limit"].(*int), args["where"].(*model.GbfsBikeRequest)), true

	case "Query.census_datasets":
		if e.complexity.Query.CensusDatasets == nil {
			break
		}

		args, err := ec.field_Query_census_datasets_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CensusDatasets(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.CensusDatasetFilter)), true

	case "Query.census_values":
		if e.complexity.Query.CensusValues == nil {
			break
		}

		args, err := ec.field_Query_census_values_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CensusValues(childComplexity, args["limit"].(*int), args["where"].(*model.CensusValueFilter)), true

	case "Query.directions":
		if e.complexity.Query.Directions == nil {
			break
		}

		args, err := ec.field_Query_directions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Directions(childComplexity, args["where"].(model.DirectionRequest)), true

	case "Query.docks":
		if e.complexity.Query.Docks == nil {
			break
		}

		args, err := ec.field_Query_docks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Docks(childComplexity, args["limit"].(*int), args["where"].(*model.GbfsDockRequest)), true

	case "Query.feed_versions":
		if e.complexity.Query.FeedVersions == nil {
			break
		}

		args, err := ec.field_Query_feed_versions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FeedVersions(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.FeedVersionFilter)), true

	case "Query.feeds":
		if e.complexity.Query.Feeds == nil {
			break
		}

		args, err := ec.field_Query_feeds_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Feeds(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.FeedFilter)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.operators":
		if e.complexity.Query.Operators == nil {
			break
		}

		args, err := ec.field_Query_operators_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Operators(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.OperatorFilter)), true

	case "Query.places":
		if e.complexity.Query.Places == nil {
			break
		}

		args, err := ec.field_Query_places_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Places(childComplexity, args["limit"].(*int), args["after"].(*int), args["level"].(*model.PlaceAggregationLevel), args["where"].(*model.PlaceFilter)), true

	case "Query.routes":
		if e.complexity.Query.Routes == nil {
			break
		}

		args, err := ec.field_Query_routes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Routes(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.RouteFilter)), true

	case "Query.stops":
		if e.complexity.Query.Stops == nil {
			break
		}

		args, err := ec.field_Query_stops_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Stops(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.StopFilter)), true

	case "Query.trips":
		if e.complexity.Query.Trips == nil {
			break
		}

		args, err := ec.field_Query_trips_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Trips(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.TripFilter)), true

	case "RTTimeRange.end":
		if e.complexity.RTTimeRange.End == nil {
			break
		}

		return e.complexity.RTTimeRange.End(childComplexity), true

	case "RTTimeRange.start":
		if e.complexity.RTTimeRange.Start == nil {
			break
		}

		return e.complexity.RTTimeRange.Start(childComplexity), true

	case "RTTranslation.language":
		if e.complexity.RTTranslation.Language == nil {
			break
		}

		return e.complexity.RTTranslation.Language(childComplexity), true

	case "RTTranslation.text":
		if e.complexity.RTTranslation.Text == nil {
			break
		}

		return e.complexity.RTTranslation.Text(childComplexity), true

	case "RTTripDescriptor.direction_id":
		if e.complexity.RTTripDescriptor.DirectionID == nil {
			break
		}

		return e.complexity.RTTripDescriptor.DirectionID(childComplexity), true

	case "RTTripDescriptor.route_id":
		if e.complexity.RTTripDescriptor.RouteID == nil {
			break
		}

		return e.complexity.RTTripDescriptor.RouteID(childComplexity), true

	case "RTTripDescriptor.schedule_relationship":
		if e.complexity.RTTripDescriptor.ScheduleRelationship == nil {
			break
		}

		return e.complexity.RTTripDescriptor.ScheduleRelationship(childComplexity), true

	case "RTTripDescriptor.start_date":
		if e.complexity.RTTripDescriptor.StartDate == nil {
			break
		}

		return e.complexity.RTTripDescriptor.StartDate(childComplexity), true

	case "RTTripDescriptor.start_time":
		if e.complexity.RTTripDescriptor.StartTime == nil {
			break
		}

		return e.complexity.RTTripDescriptor.StartTime(childComplexity), true

	case "RTTripDescriptor.trip_id":
		if e.complexity.RTTripDescriptor.TripID == nil {
			break
		}

		return e.complexity.RTTripDescriptor.TripID(childComplexity), true

	case "RTVehicleDescriptor.id":
		if e.complexity.RTVehicleDescriptor.ID == nil {
			break
		}

		return e.complexity.RTVehicleDescriptor.ID(childComplexity), true

	case "RTVehicleDescriptor.label":
		if e.complexity.RTVehicleDescriptor.Label == nil {
			break
		}

		return e.complexity.RTVehicleDescriptor.Label(childComplexity), true

	case "RTVehicleDescriptor.license_plate":
		if e.complexity.RTVehicleDescriptor.LicensePlate == nil {
			break
		}

		return e.complexity.RTVehicleDescriptor.LicensePlate(childComplexity), true

	case "Route.agency":
		if e.complexity.Route.Agency == nil {
			break
		}

		return e.complexity.Route.Agency(childComplexity), true

	case "Route.alerts":
		if e.complexity.Route.Alerts == nil {
			break
		}

		args, err := ec.field_Route_alerts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.Alerts(childComplexity, args["active"].(*bool), args["limit"].(*int)), true

	case "Route.census_geographies":
		if e.complexity.Route.CensusGeographies == nil {
			break
		}

		args, err := ec.field_Route_census_geographies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.CensusGeographies(childComplexity, args["limit"].(*int), args["where"].(*model.CensusGeographyFilter)), true

	case "Route.continuous_drop_off":
		if e.complexity.Route.ContinuousDropOff == nil {
			break
		}

		return e.complexity.Route.ContinuousDropOff(childComplexity), true

	case "Route.continuous_pickup":
		if e.complexity.Route.ContinuousPickup == nil {
			break
		}

		return e.complexity.Route.ContinuousPickup(childComplexity), true

	case "Route.feed_onestop_id":
		if e.complexity.Route.FeedOnestopID == nil {
			break
		}

		return e.complexity.Route.FeedOnestopID(childComplexity), true

	case "Route.feed_version":
		if e.complexity.Route.FeedVersion == nil {
			break
		}

		return e.complexity.Route.FeedVersion(childComplexity), true

	case "Route.feed_version_sha1":
		if e.complexity.Route.FeedVersionSHA1 == nil {
			break
		}

		return e.complexity.Route.FeedVersionSHA1(childComplexity), true

	case "Route.geometries":
		if e.complexity.Route.Geometries == nil {
			break
		}

		args, err := ec.field_Route_geometries_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.Geometries(childComplexity, args["limit"].(*int)), true

	case "Route.geometry":
		if e.complexity.Route.Geometry == nil {
			break
		}

		return e.complexity.Route.Geometry(childComplexity), true

	case "Route.headways":
		if e.complexity.Route.Headways == nil {
			break
		}

		args, err := ec.field_Route_headways_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.Headways(childComplexity, args["limit"].(*int)), true

	case "Route.id":
		if e.complexity.Route.ID == nil {
			break
		}

		return e.complexity.Route.ID(childComplexity), true

	case "Route.onestop_id":
		if e.complexity.Route.OnestopID == nil {
			break
		}

		return e.complexity.Route.OnestopID(childComplexity), true

	case "Route.patterns":
		if e.complexity.Route.Patterns == nil {
			break
		}

		return e.complexity.Route.Patterns(childComplexity), true

	case "Route.route_attribute":
		if e.complexity.Route.RouteAttribute == nil {
			break
		}

		return e.complexity.Route.RouteAttribute(childComplexity), true

	case "Route.route_color":
		if e.complexity.Route.RouteColor == nil {
			break
		}

		return e.complexity.Route.RouteColor(childComplexity), true

	case "Route.route_desc":
		if e.complexity.Route.RouteDesc == nil {
			break
		}

		return e.complexity.Route.RouteDesc(childComplexity), true

	case "Route.route_id":
		if e.complexity.Route.RouteID == nil {
			break
		}

		return e.complexity.Route.RouteID(childComplexity), true

	case "Route.route_long_name":
		if e.complexity.Route.RouteLongName == nil {
			break
		}

		return e.complexity.Route.RouteLongName(childComplexity), true

	case "Route.route_short_name":
		if e.complexity.Route.RouteShortName == nil {
			break
		}

		return e.complexity.Route.RouteShortName(childComplexity), true

	case "Route.route_sort_order":
		if e.complexity.Route.RouteSortOrder == nil {
			break
		}

		return e.complexity.Route.RouteSortOrder(childComplexity), true

	case "Route.route_stop_buffer":
		if e.complexity.Route.RouteStopBuffer == nil {
			break
		}

		args, err := ec.field_Route_route_stop_buffer_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.RouteStopBuffer(childComplexity, args["radius"].(*float64)), true

	case "Route.route_stops":
		if e.complexity.Route.RouteStops == nil {
			break
		}

		args, err := ec.field_Route_route_stops_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.RouteStops(childComplexity, args["limit"].(*int)), true

	case "Route.route_text_color":
		if e.complexity.Route.RouteTextColor == nil {
			break
		}

		return e.complexity.Route.RouteTextColor(childComplexity), true

	case "Route.route_type":
		if e.complexity.Route.RouteType == nil {
			break
		}

		return e.complexity.Route.RouteType(childComplexity), true

	case "Route.route_url":
		if e.complexity.Route.RouteURL == nil {
			break
		}

		return e.complexity.Route.RouteURL(childComplexity), true

	case "Route.search_rank":
		if e.complexity.Route.SearchRank == nil {
			break
		}

		return e.complexity.Route.SearchRank(childComplexity), true

	case "Route.segment_patterns":
		if e.complexity.Route.SegmentPatterns == nil {
			break
		}

		args, err := ec.field_Route_segment_patterns_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.SegmentPatterns(childComplexity, args["limit"].(*int), args["where"].(*model.SegmentPatternFilter)), true

	case "Route.segments":
		if e.complexity.Route.Segments == nil {
			break
		}

		args, err := ec.field_Route_segments_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.Segments(childComplexity, args["limit"].(*int), args["where"].(*model.SegmentFilter)), true

	case "Route.stops":
		if e.complexity.Route.Stops == nil {
			break
		}

		args, err := ec.field_Route_stops_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.Stops(childComplexity, args["limit"].(*int), args["where"].(*model.StopFilter)), true

	case "Route.trips":
		if e.complexity.Route.Trips == nil {
			break
		}

		args, err := ec.field_Route_trips_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.Trips(childComplexity, args["limit"].(*int), args["where"].(*model.TripFilter)), true

	case "RouteAttribute.category":
		if e.complexity.RouteAttribute.Category == nil {
			break
		}

		return e.complexity.RouteAttribute.Category(childComplexity), true

	case "RouteAttribute.running_way":
		if e.complexity.RouteAttribute.RunningWay == nil {
			break
		}

		return e.complexity.RouteAttribute.RunningWay(childComplexity), true

	case "RouteAttribute.subcategory":
		if e.complexity.RouteAttribute.Subcategory == nil {
			break
		}

		return e.complexity.RouteAttribute.Subcategory(childComplexity), true

	case "RouteGeometry.combined_geometry":
		if e.complexity.RouteGeometry.CombinedGeometry == nil {
			break
		}

		return e.complexity.RouteGeometry.CombinedGeometry(childComplexity), true

	case "RouteGeometry.first_point_max_distance":
		if e.complexity.RouteGeometry.FirstPointMaxDistance == nil {
			break
		}

		return e.complexity.RouteGeometry.FirstPointMaxDistance(childComplexity), true

	case "RouteGeometry.generated":
		if e.complexity.RouteGeometry.Generated == nil {
			break
		}

		return e.complexity.RouteGeometry.Generated(childComplexity), true

	case "RouteGeometry.geometry":
		if e.complexity.RouteGeometry.Geometry == nil {
			break
		}

		return e.complexity.RouteGeometry.Geometry(childComplexity), true

	case "RouteGeometry.length":
		if e.complexity.RouteGeometry.Length == nil {
			break
		}

		return e.complexity.RouteGeometry.Length(childComplexity), true

	case "RouteGeometry.max_segment_length":
		if e.complexity.RouteGeometry.MaxSegmentLength == nil {
			break
		}

		return e.complexity.RouteGeometry.MaxSegmentLength(childComplexity), true

	case "RouteHeadway.departures":
		if e.complexity.RouteHeadway.Departures == nil {
			break
		}

		return e.complexity.RouteHeadway.Departures(childComplexity), true

	case "RouteHeadway.direction_id":
		if e.complexity.RouteHeadway.DirectionID == nil {
			break
		}

		return e.complexity.RouteHeadway.DirectionID(childComplexity), true

	case "RouteHeadway.dow_category":
		if e.complexity.RouteHeadway.DowCategory == nil {
			break
		}

		return e.complexity.RouteHeadway.DowCategory(childComplexity), true

	case "RouteHeadway.headway_secs":
		if e.complexity.RouteHeadway.HeadwaySecs == nil {
			break
		}

		return e.complexity.RouteHeadway.HeadwaySecs(childComplexity), true

	case "RouteHeadway.service_date":
		if e.complexity.RouteHeadway.ServiceDate == nil {
			break
		}

		return e.complexity.RouteHeadway.ServiceDate(childComplexity), true

	case "RouteHeadway.stop":
		if e.complexity.RouteHeadway.Stop == nil {
			break
		}

		return e.complexity.RouteHeadway.Stop(childComplexity), true

	case "RouteHeadway.stop_trip_count":
		if e.complexity.RouteHeadway.StopTripCount == nil {
			break
		}

		return e.complexity.RouteHeadway.StopTripCount(childComplexity), true

	case "RouteStop.agency":
		if e.complexity.RouteStop.Agency == nil {
			break
		}

		return e.complexity.RouteStop.Agency(childComplexity), true

	case "RouteStop.agency_id":
		if e.complexity.RouteStop.AgencyID == nil {
			break
		}

		return e.complexity.RouteStop.AgencyID(childComplexity), true

	case "RouteStop.id":
		if e.complexity.RouteStop.ID == nil {
			break
		}

		return e.complexity.RouteStop.ID(childComplexity), true

	case "RouteStop.route":
		if e.complexity.RouteStop.Route == nil {
			break
		}

		return e.complexity.RouteStop.Route(childComplexity), true

	case "RouteStop.route_id":
		if e.complexity.RouteStop.RouteID == nil {
			break
		}

		return e.complexity.RouteStop.RouteID(childComplexity), true

	case "RouteStop.stop":
		if e.complexity.RouteStop.Stop == nil {
			break
		}

		return e.complexity.RouteStop.Stop(childComplexity), true

	case "RouteStop.stop_id":
		if e.complexity.RouteStop.StopID == nil {
			break
		}

		return e.complexity.RouteStop.StopID(childComplexity), true

	case "RouteStopBuffer.stop_buffer":
		if e.complexity.RouteStopBuffer.StopBuffer == nil {
			break
		}

		return e.complexity.RouteStopBuffer.StopBuffer(childComplexity), true

	case "RouteStopBuffer.stop_convexhull":
		if e.complexity.RouteStopBuffer.StopConvexhull == nil {
			break
		}

		return e.complexity.RouteStopBuffer.StopConvexhull(childComplexity), true

	case "RouteStopBuffer.stop_points":
		if e.complexity.RouteStopBuffer.StopPoints == nil {
			break
		}

		return e.complexity.RouteStopBuffer.StopPoints(childComplexity), true

	case "RouteStopPattern.count":
		if e.complexity.RouteStopPattern.Count == nil {
			break
		}

		return e.complexity.RouteStopPattern.Count(childComplexity), true

	case "RouteStopPattern.direction_id":
		if e.complexity.RouteStopPattern.DirectionID == nil {
			break
		}

		return e.complexity.RouteStopPattern.DirectionID(childComplexity), true

	case "RouteStopPattern.stop_pattern_id":
		if e.complexity.RouteStopPattern.StopPatternID == nil {
			break
		}

		return e.complexity.RouteStopPattern.StopPatternID(childComplexity), true

	case "RouteStopPattern.trips":
		if e.complexity.RouteStopPattern.Trips == nil {
			break
		}

		args, err := ec.field_RouteStopPattern_trips_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RouteStopPattern.Trips(childComplexity, args["limit"].(*int)), true

	case "Segment.geometry":
		if e.complexity.Segment.Geometry == nil {
			break
		}

		return e.complexity.Segment.Geometry(childComplexity), true

	case "Segment.id":
		if e.complexity.Segment.ID == nil {
			break
		}

		return e.complexity.Segment.ID(childComplexity), true

	case "Segment.segment_patterns":
		if e.complexity.Segment.SegmentPatterns == nil {
			break
		}

		return e.complexity.Segment.SegmentPatterns(childComplexity), true

	case "Segment.way_id":
		if e.complexity.Segment.WayID == nil {
			break
		}

		return e.complexity.Segment.WayID(childComplexity), true

	case "SegmentPattern.id":
		if e.complexity.SegmentPattern.ID == nil {
			break
		}

		return e.complexity.SegmentPattern.ID(childComplexity), true

	case "SegmentPattern.route":
		if e.complexity.SegmentPattern.Route == nil {
			break
		}

		return e.complexity.SegmentPattern.Route(childComplexity), true

	case "SegmentPattern.segment":
		if e.complexity.SegmentPattern.Segment == nil {
			break
		}

		return e.complexity.SegmentPattern.Segment(childComplexity), true

	case "SegmentPattern.stop_pattern_id":
		if e.complexity.SegmentPattern.StopPatternID == nil {
			break
		}

		return e.complexity.SegmentPattern.StopPatternID(childComplexity), true

	case "Shape.generated":
		if e.complexity.Shape.Generated == nil {
			break
		}

		return e.complexity.Shape.Generated(childComplexity), true

	case "Shape.geometry":
		if e.complexity.Shape.Geometry == nil {
			break
		}

		return e.complexity.Shape.Geometry(childComplexity), true

	case "Shape.id":
		if e.complexity.Shape.ID == nil {
			break
		}

		return e.complexity.Shape.ID(childComplexity), true

	case "Shape.shape_id":
		if e.complexity.Shape.ShapeID == nil {
			break
		}

		return e.complexity.Shape.ShapeID(childComplexity), true

	case "Step.distance":
		if e.complexity.Step.Distance == nil {
			break
		}

		return e.complexity.Step.Distance(childComplexity), true

	case "Step.duration":
		if e.complexity.Step.Duration == nil {
			break
		}

		return e.complexity.Step.Duration(childComplexity), true

	case "Step.end_time":
		if e.complexity.Step.EndTime == nil {
			break
		}

		return e.complexity.Step.EndTime(childComplexity), true

	case "Step.geometry_offset":
		if e.complexity.Step.GeometryOffset == nil {
			break
		}

		return e.complexity.Step.GeometryOffset(childComplexity), true

	case "Step.instruction":
		if e.complexity.Step.Instruction == nil {
			break
		}

		return e.complexity.Step.Instruction(childComplexity), true

	case "Step.mode":
		if e.complexity.Step.Mode == nil {
			break
		}

		return e.complexity.Step.Mode(childComplexity), true

	case "Step.start_time":
		if e.complexity.Step.StartTime == nil {
			break
		}

		return e.complexity.Step.StartTime(childComplexity), true

	case "Step.to":
		if e.complexity.Step.To == nil {
			break
		}

		return e.complexity.Step.To(childComplexity), true

	case "Stop.alerts":
		if e.complexity.Stop.Alerts == nil {
			break
		}

		args, err := ec.field_Stop_alerts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.Alerts(childComplexity, args["active"].(*bool), args["limit"].(*int)), true

	case "Stop.arrivals":
		if e.complexity.Stop.Arrivals == nil {
			break
		}

		args, err := ec.field_Stop_arrivals_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.Arrivals(childComplexity, args["limit"].(*int), args["where"].(*model.StopTimeFilter)), true

	case "Stop.census_geographies":
		if e.complexity.Stop.CensusGeographies == nil {
			break
		}

		args, err := ec.field_Stop_census_geographies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.CensusGeographies(childComplexity, args["limit"].(*int), args["where"].(*model.CensusGeographyFilter)), true

	case "Stop.child_levels":
		if e.complexity.Stop.ChildLevels == nil {
			break
		}

		args, err := ec.field_Stop_child_levels_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.ChildLevels(childComplexity, args["limit"].(*int)), true

	case "Stop.children":
		if e.complexity.Stop.Children == nil {
			break
		}

		args, err := ec.field_Stop_children_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.Children(childComplexity, args["limit"].(*int)), true

	case "Stop.departures":
		if e.complexity.Stop.Departures == nil {
			break
		}

		args, err := ec.field_Stop_departures_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.Departures(childComplexity, args["limit"].(*int), args["where"].(*model.StopTimeFilter)), true

	case "Stop.directions":
		if e.complexity.Stop.Directions == nil {
			break
		}

		args, err := ec.field_Stop_directions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.Directions(childComplexity, args["to"].(*model.WaypointInput), args["from"].(*model.WaypointInput), args["mode"].(*model.StepMode), args["depart_at"].(*time.Time)), true

	case "Stop.external_reference":
		if e.complexity.Stop.ExternalReference == nil {
			break
		}

		return e.complexity.Stop.ExternalReference(childComplexity), true

	case "Stop.feed_onestop_id":
		if e.complexity.Stop.FeedOnestopID == nil {
			break
		}

		return e.complexity.Stop.FeedOnestopID(childComplexity), true

	case "Stop.feed_version":
		if e.complexity.Stop.FeedVersion == nil {
			break
		}

		return e.complexity.Stop.FeedVersion(childComplexity), true

	case "Stop.feed_version_sha1":
		if e.complexity.Stop.FeedVersionSHA1 == nil {
			break
		}

		return e.complexity.Stop.FeedVersionSHA1(childComplexity), true

	case "Stop.geometry":
		if e.complexity.Stop.Geometry == nil {
			break
		}

		return e.complexity.Stop.Geometry(childComplexity), true

	case "Stop.id":
		if e.complexity.Stop.ID == nil {
			break
		}

		return e.complexity.Stop.ID(childComplexity), true

	case "Stop.level":
		if e.complexity.Stop.Level == nil {
			break
		}

		return e.complexity.Stop.Level(childComplexity), true

	case "Stop.location_groups":
		if e.complexity.Stop.LocationGroups == nil {
			break
		}

		args, err := ec.field_Stop_location_groups_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.LocationGroups(childComplexity, args["limit"].(*int)), true

	case "Stop.location_type":
		if e.complexity.Stop.LocationType == nil {
			break
		}

		return e.complexity.Stop.LocationType(childComplexity), true

	case "Stop.nearby_stops":
		if e.complexity.Stop.NearbyStops == nil {
			break
		}

		args, err := ec.field_Stop_nearby_stops_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.NearbyStops(childComplexity, args["limit"].(*int), args["radius"].(*float64)), true

	case "Stop.observations":
		if e.complexity.Stop.Observations == nil {
			break
		}

		args, err := ec.field_Stop_observations_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.Observations(childComplexity, args["limit"].(*int), args["where"].(*model.StopObservationFilter)), true

	case "Stop.onestop_id":
		if e.complexity.Stop.OnestopID == nil {
			break
		}

		return e.complexity.Stop.OnestopID(childComplexity), true

	case "Stop.parent":
		if e.complexity.Stop.Parent == nil {
			break
		}

		return e.complexity.Stop.Parent(childComplexity), true

	case "Stop.pathways_from_stop":
		if e.complexity.Stop.PathwaysFromStop == nil {
			break
		}

		args, err := ec.field_Stop_pathways_from_stop_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.PathwaysFromStop(childComplexity, args["limit"].(*int)), true

	case "Stop.pathways_to_stop":
		if e.complexity.Stop.PathwaysToStop == nil {
			break
		}

		args, err := ec.field_Stop_pathways_to_stop_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.PathwaysToStop(childComplexity, args["limit"].(*int)), true

	case "Stop.place":
		if e.complexity.Stop.Place == nil {
			break
		}

		return e.complexity.Stop.Place(childComplexity), true

	case "Stop.platform_code":
		if e.complexity.Stop.PlatformCode == nil {
			break
		}

		return e.complexity.Stop.PlatformCode(childComplexity), true

	case "Stop.route_stops":
		if e.complexity.Stop.RouteStops == nil {
			break
		}

		args, err := ec.field_Stop_route_stops_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.RouteStops(childComplexity, args["limit"].(*int)), true

	case "Stop.search_rank":
		if e.complexity.Stop.SearchRank == nil {
			break
		}

		return e.complexity.Stop.SearchRank(childComplexity), true

	case "Stop.stop_code":
		if e.complexity.Stop.StopCode == nil {
			break
		}

		return e.complexity.Stop.StopCode(childComplexity), true

	case "Stop.stop_desc":
		if e.complexity.Stop.StopDesc == nil {
			break
		}

		return e.complexity.Stop.StopDesc(childComplexity), true

	case "Stop.stop_id":
		if e.complexity.Stop.StopID == nil {
			break
		}

		return e.complexity.Stop.StopID(childComplexity), true

	case "Stop.stop_name":
		if e.complexity.Stop.StopName == nil {
			break
		}

		return e.complexity.Stop.StopName(childComplexity), true

	case "Stop.stop_times":
		if e.complexity.Stop.StopTimes == nil {
			break
		}

		args, err := ec.field_Stop_stop_times_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.StopTimes(childComplexity, args["limit"].(*int), args["where"].(*model.StopTimeFilter)), true

	case "Stop.stop_timezone":
		if e.complexity.Stop.StopTimezone == nil {
			break
		}

		return e.complexity.Stop.StopTimezone(childComplexity), true

	case "Stop.stop_url":
		if e.complexity.Stop.StopURL == nil {
			break
		}

		return e.complexity.Stop.StopURL(childComplexity), true

	case "Stop.tts_stop_name":
		if e.complexity.Stop.TtsStopName == nil {
			break
		}

		return e.complexity.Stop.TtsStopName(childComplexity), true

	case "Stop.wheelchair_boarding":
		if e.complexity.Stop.WheelchairBoarding == nil {
			break
		}

		return e.complexity.Stop.WheelchairBoarding(childComplexity), true

	case "Stop.within_features":
		if e.complexity.Stop.WithinFeatures == nil {
			break
		}

		return e.complexity.Stop.WithinFeatures(childComplexity), true

	case "Stop.zone_id":
		if e.complexity.Stop.ZoneID == nil {
			break
		}

		return e.complexity.Stop.ZoneID(childComplexity), true

	case "StopExternalReference.id":
		if e.complexity.StopExternalReference.ID == nil {
			break
		}

		return e.complexity.StopExternalReference.ID(childComplexity), true

	case "StopExternalReference.inactive":
		if e.complexity.StopExternalReference.Inactive == nil {
			break
		}

		return e.complexity.StopExternalReference.Inactive(childComplexity), true

	case "StopExternalReference.target_active_stop":
		if e.complexity.StopExternalReference.TargetActiveStop == nil {
			break
		}

		return e.complexity.StopExternalReference.TargetActiveStop(childComplexity), true

	case "StopExternalReference.target_feed_onestop_id":
		if e.complexity.StopExternalReference.TargetFeedOnestopID == nil {
			break
		}

		return e.complexity.StopExternalReference.TargetFeedOnestopID(childComplexity), true

	case "StopExternalReference.target_stop_id":
		if e.complexity.StopExternalReference.TargetStopID == nil {
			break
		}

		return e.complexity.StopExternalReference.TargetStopID(childComplexity), true

	case "StopObservation.agency_id":
		if e.complexity.StopObservation.AgencyID == nil {
			break
		}

		return e.complexity.StopObservation.AgencyID(childComplexity), true

	case "StopObservation.from_stop_id":
		if e.complexity.StopObservation.FromStopID == nil {
			break
		}

		return e.complexity.StopObservation.FromStopID(childComplexity), true

	case "StopObservation.observed_arrival_time":
		if e.complexity.StopObservation.ObservedArrivalTime == nil {
			break
		}

		return e.complexity.StopObservation.ObservedArrivalTime(childComplexity), true

	case "StopObservation.observed_departure_time":
		if e.complexity.StopObservation.ObservedDepartureTime == nil {
			break
		}

		return e.complexity.StopObservation.ObservedDepartureTime(childComplexity), true

	case "StopObservation.route_id":
		if e.complexity.StopObservation.RouteID == nil {
			break
		}

		return e.complexity.StopObservation.RouteID(childComplexity), true

	case "StopObservation.schedule_relationship":
		if e.complexity.StopObservation.ScheduleRelationship == nil {
			break
		}

		return e.complexity.StopObservation.ScheduleRelationship(childComplexity), true

	case "StopObservation.scheduled_arrival_time":
		if e.complexity.StopObservation.ScheduledArrivalTime == nil {
			break
		}

		return e.complexity.StopObservation.ScheduledArrivalTime(childComplexity), true

	case "StopObservation.scheduled_departure_time":
		if e.complexity.StopObservation.ScheduledDepartureTime == nil {
			break
		}

		return e.complexity.StopObservation.ScheduledDepartureTime(childComplexity), true

	case "StopObservation.source":
		if e.complexity.StopObservation.Source == nil {
			break
		}

		return e.complexity.StopObservation.Source(childComplexity), true

	case "StopObservation.stop_sequence":
		if e.complexity.StopObservation.StopSequence == nil {
			break
		}

		return e.complexity.StopObservation.StopSequence(childComplexity), true

	case "StopObservation.to_stop_id":
		if e.complexity.StopObservation.ToStopID == nil {
			break
		}

		return e.complexity.StopObservation.ToStopID(childComplexity), true

	case "StopObservation.trip_id":
		if e.complexity.StopObservation.TripID == nil {
			break
		}

		return e.complexity.StopObservation.TripID(childComplexity), true

	case "StopObservation.trip_start_date":
		if e.complexity.StopObservation.TripStartDate == nil {
			break
		}

		return e.complexity.StopObservation.TripStartDate(childComplexity), true

	case "StopObservation.trip_start_time":
		if e.complexity.StopObservation.TripStartTime == nil {
			break
		}

		return e.complexity.StopObservation.TripStartTime(childComplexity), true

	case "StopPlace.adm0_iso":
		if e.complexity.StopPlace.Adm0Iso == nil {
			break
		}

		return e.complexity.StopPlace.Adm0Iso(childComplexity), true

	case "StopPlace.adm0_name":
		if e.complexity.StopPlace.Adm0Name == nil {
			break
		}

		return e.complexity.StopPlace.Adm0Name(childComplexity), true

	case "StopPlace.adm1_iso":
		if e.complexity.StopPlace.Adm1Iso == nil {
			break
		}

		return e.complexity.StopPlace.Adm1Iso(childComplexity), true

	case "StopPlace.adm1_name":
		if e.complexity.StopPlace.Adm1Name == nil {
			break
		}

		return e.complexity.StopPlace.Adm1Name(childComplexity), true

	case "StopTime.arrival":
		if e.complexity.StopTime.Arrival == nil {
			break
		}

		return e.complexity.StopTime.Arrival(childComplexity), true

	case "StopTime.arrival_time":
		if e.complexity.StopTime.ArrivalTime == nil {
			break
		}

		return e.complexity.StopTime.ArrivalTime(childComplexity), true

	case "StopTime.continuous_drop_off":
		if e.complexity.StopTime.ContinuousDropOff == nil {
			break
		}

		return e.complexity.StopTime.ContinuousDropOff(childComplexity), true

	case "StopTime.continuous_pickup":
		if e.complexity.StopTime.ContinuousPickup == nil {
			break
		}

		return e.complexity.StopTime.ContinuousPickup(childComplexity), true

	case "StopTime.date":
		if e.complexity.StopTime.Date == nil {
			break
		}

		return e.complexity.StopTime.Date(childComplexity), true

	case "StopTime.departure":
		if e.complexity.StopTime.Departure == nil {
			break
		}

		return e.complexity.StopTime.Departure(childComplexity), true

	case "StopTime.departure_time":
		if e.complexity.StopTime.DepartureTime == nil {
			break
		}

		return e.complexity.StopTime.DepartureTime(childComplexity), true

	case "StopTime.drop_off_booking_rule":
		if e.complexity.StopTime.DropOffBookingRule == nil {
			break
		}

		return e.complexity.StopTime.DropOffBookingRule(childComplexity), true

	case "StopTime.drop_off_type":
		if e.complexity.StopTime.DropOffType == nil {
			break
		}

		return e.complexity.StopTime.DropOffType(childComplexity), true

	case "StopTime.end_pickup_drop_off_window":
		if e.complexity.StopTime.EndPickupDropOffWindow == nil {
			break
		}

		return e.complexity.StopTime.EndPickupDropOffWindow(childComplexity), true

	case "StopTime.interpolated":
		if e.complexity.StopTime.Interpolated == nil {
			break
		}

		return e.complexity.StopTime.Interpolated(childComplexity), true

	case "StopTime.pickup_booking_rule":
		if e.complexity.StopTime.PickupBookingRule == nil {
			break
		}

		return e.complexity.StopTime.PickupBookingRule(childComplexity), true

	case "StopTime.pickup_type":
		if e.complexity.StopTime.PickupType == nil {
			break
		}

		return e.complexity.StopTime.PickupType(childComplexity), true

	case "StopTime.schedule_relationship":
		if e.complexity.StopTime.ScheduleRelationship == nil {
			break
		}

		return e.complexity.StopTime.ScheduleRelationship(childComplexity), true

	case "StopTime.service_date":
		if e.complexity.StopTime.ServiceDate == nil {
			break
		}

		return e.complexity.StopTime.ServiceDate(childComplexity), true

	case "StopTime.shape_dist_traveled":
		if e.complexity.StopTime.ShapeDistTraveled == nil {
			break
		}

		return e.complexity.StopTime.ShapeDistTraveled(childComplexity), true

	case "StopTime.start_pickup_drop_off_window":
		if e.complexity.StopTime.StartPickupDropOffWindow == nil {
			break
		}

		return e.complexity.StopTime.StartPickupDropOffWindow(childComplexity), true

	case "StopTime.stop":
		if e.complexity.StopTime.Stop == nil {
			break
		}

		return e.complexity.StopTime.Stop(childComplexity), true

	case "StopTime.stop_headsign":
		if e.complexity.StopTime.StopHeadsign == nil {
			break
		}

		return e.complexity.StopTime.StopHeadsign(childComplexity), true

	case "StopTime.stop_sequence":
		if e.complexity.StopTime.StopSequence == nil {
			break
		}

		return e.complexity.StopTime.StopSequence(childComplexity), true

	case "StopTime.timepoint":
		if e.complexity.StopTime.Timepoint == nil {
			break
		}

		return e.complexity.StopTime.Timepoint(childComplexity), true

	case "StopTime.trip":
		if e.complexity.StopTime.Trip == nil {
			break
		}

		return e.complexity.StopTime.Trip(childComplexity), true

	case "StopTimeEvent.delay":
		if e.complexity.StopTimeEvent.Delay == nil {
			break
		}

		return e.complexity.StopTimeEvent.Delay(childComplexity), true

	case "StopTimeEvent.estimated":
		if e.complexity.StopTimeEvent.Estimated == nil {
			break
		}

		return e.complexity.StopTimeEvent.Estimated(childComplexity), true

	case "StopTimeEvent.estimated_delay":
		if e.complexity.StopTimeEvent.EstimatedDelay == nil {
			break
		}

		return e.complexity.StopTimeEvent.EstimatedDelay(childComplexity), true

	case "StopTimeEvent.estimated_local":
		if e.complexity.StopTimeEvent.EstimatedLocal == nil {
			break
		}

		return e.complexity.StopTimeEvent.EstimatedLocal(childComplexity), true

	case "StopTimeEvent.estimated_unix":
		if e.complexity.StopTimeEvent.EstimatedUnix == nil {
			break
		}

		return e.complexity.StopTimeEvent.EstimatedUnix(childComplexity), true

	case "StopTimeEvent.estimated_utc":
		if e.complexity.StopTimeEvent.EstimatedUtc == nil {
			break
		}

		return e.complexity.StopTimeEvent.EstimatedUtc(childComplexity), true

	case "StopTimeEvent.scheduled":
		if e.complexity.StopTimeEvent.Scheduled == nil {
			break
		}

		return e.complexity.StopTimeEvent.Scheduled(childComplexity), true

	case "StopTimeEvent.scheduled_local":
		if e.complexity.StopTimeEvent.ScheduledLocal == nil {
			break
		}

		return e.complexity.StopTimeEvent.ScheduledLocal(childComplexity), true

	case "StopTimeEvent.scheduled_unix":
		if e.complexity.StopTimeEvent.ScheduledUnix == nil {
			break
		}

		return e.complexity.StopTimeEvent.ScheduledUnix(childComplexity), true

	case "StopTimeEvent.scheduled_utc":
		if e.complexity.StopTimeEvent.ScheduledUtc == nil {
			break
		}

		return e.complexity.StopTimeEvent.ScheduledUtc(childComplexity), true

	case "StopTimeEvent.stop_timezone":
		if e.complexity.StopTimeEvent.StopTimezone == nil {
			break
		}

		return e.complexity.StopTimeEvent.StopTimezone(childComplexity), true

	case "StopTimeEvent.time_unix":
		if e.complexity.StopTimeEvent.TimeUnix == nil {
			break
		}

		return e.complexity.StopTimeEvent.TimeUnix(childComplexity), true

	case "StopTimeEvent.time_utc":
		if e.complexity.StopTimeEvent.TimeUtc == nil {
			break
		}

		return e.complexity.StopTimeEvent.TimeUtc(childComplexity), true

	case "StopTimeEvent.uncertainty":
		if e.complexity.StopTimeEvent.Uncertainty == nil {
			break
		}

		return e.complexity.StopTimeEvent.Uncertainty(childComplexity), true

	case "Trip.alerts":
		if e.complexity.Trip.Alerts == nil {
			break
		}

		args, err := ec.field_Trip_alerts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Trip.Alerts(childComplexity, args["active"].(*bool), args["limit"].(*int)), true

	case "Trip.bikes_allowed":
		if e.complexity.Trip.BikesAllowed == nil {
			break
		}

		return e.complexity.Trip.BikesAllowed(childComplexity), true

	case "Trip.block_id":
		if e.complexity.Trip.BlockID == nil {
			break
		}

		return e.complexity.Trip.BlockID(childComplexity), true

	case "Trip.calendar":
		if e.complexity.Trip.Calendar == nil {
			break
		}

		return e.complexity.Trip.Calendar(childComplexity), true

	case "Trip.direction_id":
		if e.complexity.Trip.DirectionID == nil {
			break
		}

		return e.complexity.Trip.DirectionID(childComplexity), true

	case "Trip.feed_version":
		if e.complexity.Trip.FeedVersion == nil {
			break
		}

		return e.complexity.Trip.FeedVersion(childComplexity), true

	case "Trip.flex_stop_times":
		if e.complexity.Trip.FlexStopTimes == nil {
			break
		}

		args, err := ec.field_Trip_flex_stop_times_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Trip.FlexStopTimes(childComplexity, args["limit"].(*int), args["where"].(*model.TripStopTimeFilter)), true

	case "Trip.frequencies":
		if e.complexity.Trip.Frequencies == nil {
			break
		}

		args, err := ec.field_Trip_frequencies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Trip.Frequencies(childComplexity, args["limit"].(*int)), true

	case "Trip.id":
		if e.complexity.Trip.ID == nil {
			break
		}

		return e.complexity.Trip.ID(childComplexity), true

	case "Trip.route":
		if e.complexity.Trip.Route == nil {
			break
		}

		return e.complexity.Trip.Route(childComplexity), true

	case "Trip.schedule_relationship":
		if e.complexity.Trip.ScheduleRelationship == nil {
			break
		}

		return e.complexity.Trip.ScheduleRelationship(childComplexity), true

	case "Trip.shape":
		if e.complexity.Trip.Shape == nil {
			break
		}

		return e.complexity.Trip.Shape(childComplexity), true

	case "Trip.stop_pattern_id":
		if e.complexity.Trip.StopPatternID == nil {
			break
		}

		return e.complexity.Trip.StopPatternID(childComplexity), true

	case "Trip.stop_times":
		if e.complexity.Trip.StopTimes == nil {
			break
		}

		args, err := ec.field_Trip_stop_times_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Trip.StopTimes(childComplexity, args["limit"].(*int), args["where"].(*model.TripStopTimeFilter)), true

	case "Trip.timestamp":
		if e.complexity.Trip.Timestamp == nil {
			break
		}

		return e.complexity.Trip.Timestamp(childComplexity), true

	case "Trip.trip_headsign":
		if e.complexity.Trip.TripHeadsign == nil {
			break
		}

		return e.complexity.Trip.TripHeadsign(childComplexity), true

	case "Trip.trip_id":
		if e.complexity.Trip.TripID == nil {
			break
		}

		return e.complexity.Trip.TripID(childComplexity), true

	case "Trip.trip_short_name":
		if e.complexity.Trip.TripShortName == nil {
			break
		}

		return e.complexity.Trip.TripShortName(childComplexity), true

	case "Trip.wheelchair_accessible":
		if e.complexity.Trip.WheelchairAccessible == nil {
			break
		}

		return e.complexity.Trip.WheelchairAccessible(childComplexity), true

	case "ValidationRealtimeResult.json":
		if e.complexity.ValidationRealtimeResult.JSON == nil {
			break
		}

		return e.complexity.ValidationRealtimeResult.JSON(childComplexity), true

	case "ValidationRealtimeResult.url":
		if e.complexity.ValidationRealtimeResult.URL == nil {
			break
		}

		return e.complexity.ValidationRealtimeResult.URL(childComplexity), true

	case "ValidationReport.details":
		if e.complexity.ValidationReport.Details == nil {
			break
		}

		return e.complexity.ValidationReport.Details(childComplexity), true

	case "ValidationReport.errors":
		if e.complexity.ValidationReport.Errors == nil {
			break
		}

		args, err := ec.field_ValidationReport_errors_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationReport.Errors(childComplexity, args["limit"].(*int)), true

	case "ValidationReport.failure_reason":
		if e.complexity.ValidationReport.FailureReason == nil {
			break
		}

		return e.complexity.ValidationReport.FailureReason(childComplexity), true

	case "ValidationReport.id":
		if e.complexity.ValidationReport.ID == nil {
			break
		}

		return e.complexity.ValidationReport.ID(childComplexity), true

	case "ValidationReport.includes_rt":
		if e.complexity.ValidationReport.IncludesRt == nil {
			break
		}

		return e.complexity.ValidationReport.IncludesRt(childComplexity), true

	case "ValidationReport.includes_static":
		if e.complexity.ValidationReport.IncludesStatic == nil {
			break
		}

		return e.complexity.ValidationReport.IncludesStatic(childComplexity), true

	case "ValidationReport.reported_at":
		if e.complexity.ValidationReport.ReportedAt == nil {
			break
		}

		return e.complexity.ValidationReport.ReportedAt(childComplexity), true

	case "ValidationReport.reported_at_local":
		if e.complexity.ValidationReport.ReportedAtLocal == nil {
			break
		}

		return e.complexity.ValidationReport.ReportedAtLocal(childComplexity), true

	case "ValidationReport.reported_at_local_timezone":
		if e.complexity.ValidationReport.ReportedAtLocalTimezone == nil {
			break
		}

		return e.complexity.ValidationReport.ReportedAtLocalTimezone(childComplexity), true

	case "ValidationReport.success":
		if e.complexity.ValidationReport.Success == nil {
			break
		}

		return e.complexity.ValidationReport.Success(childComplexity), true

	case "ValidationReport.validator":
		if e.complexity.ValidationReport.Validator == nil {
			break
		}

		return e.complexity.ValidationReport.Validator(childComplexity), true

	case "ValidationReport.validator_version":
		if e.complexity.ValidationReport.ValidatorVersion == nil {
			break
		}

		return e.complexity.ValidationReport.ValidatorVersion(childComplexity), true

	case "ValidationReport.warnings":
		if e.complexity.ValidationReport.Warnings == nil {
			break
		}

		args, err := ec.field_ValidationReport_warnings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationReport.Warnings(childComplexity, args["limit"].(*int)), true

	case "ValidationReportDetails.agencies":
		if e.complexity.ValidationReportDetails.Agencies == nil {
			break
		}

		args, err := ec.field_ValidationReportDetails_agencies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationReportDetails.Agencies(childComplexity, args["limit"].(*int)), true

	case "ValidationReportDetails.earliest_calendar_date":
		if e.complexity.ValidationReportDetails.EarliestCalendarDate == nil {
			break
		}

		return e.complexity.ValidationReportDetails.EarliestCalendarDate(childComplexity), true

	case "ValidationReportDetails.feed_infos":
		if e.complexity.ValidationReportDetails.FeedInfos == nil {
			break
		}

		args, err := ec.field_ValidationReportDetails_feed_infos_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationReportDetails.FeedInfos(childComplexity, args["limit"].(*int)), true

	case "ValidationReportDetails.files":
		if e.complexity.ValidationReportDetails.Files == nil {
			break
		}

		return e.complexity.ValidationReportDetails.Files(childComplexity), true

	case "ValidationReportDetails.latest_calendar_date":
		if e.complexity.ValidationReportDetails.LatestCalendarDate == nil {
			break
		}

		return e.complexity.ValidationReportDetails.LatestCalendarDate(childComplexity), true

	case "ValidationReportDetails.realtime":
		if e.complexity.ValidationReportDetails.Realtime == nil {
			break
		}

		return e.complexity.ValidationReportDetails.Realtime(childComplexity), true

	case "ValidationReportDetails.routes":
		if e.complexity.ValidationReportDetails.Routes == nil {
			break
		}

		args, err := ec.field_ValidationReportDetails_routes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationReportDetails.Routes(childComplexity, args["limit"].(*int)), true

	case "ValidationReportDetails.service_levels":
		if e.complexity.ValidationReportDetails.ServiceLevels == nil {
			break
		}

		args, err := ec.field_ValidationReportDetails_service_levels_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationReportDetails.ServiceLevels(childComplexity, args["limit"].(*int), args["route_id"].(*string)), true

	case "ValidationReportDetails.sha1":
		if e.complexity.ValidationReportDetails.Sha1 == nil {
			break
		}

		return e.complexity.ValidationReportDetails.Sha1(childComplexity), true

	case "ValidationReportDetails.stops":
		if e.complexity.ValidationReportDetails.Stops == nil {
			break
		}

		args, err := ec.field_ValidationReportDetails_stops_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationReportDetails.Stops(childComplexity, args["limit"].(*int)), true

	case "ValidationReportError.entity_id":
		if e.complexity.ValidationReportError.EntityID == nil {
			break
		}

		return e.complexity.ValidationReportError.EntityID(childComplexity), true

	case "ValidationReportError.entity_json":
		if e.complexity.ValidationReportError.EntityJSON == nil {
			break
		}

		return e.complexity.ValidationReportError.EntityJSON(childComplexity), true

	case "ValidationReportError.error_code":
		if e.complexity.ValidationReportError.ErrorCode == nil {
			break
		}

		return e.complexity.ValidationReportError.ErrorCode(childComplexity), true

	case "ValidationReportError.error_type":
		if e.complexity.ValidationReportError.ErrorType == nil {
			break
		}

		return e.complexity.ValidationReportError.ErrorType(childComplexity), true

	case "ValidationReportError.field":
		if e.complexity.ValidationReportError.Field == nil {
			break
		}

		return e.complexity.ValidationReportError.Field(childComplexity), true

	case "ValidationReportError.filename":
		if e.complexity.ValidationReportError.Filename == nil {
			break
		}

		return e.complexity.ValidationReportError.Filename(childComplexity), true

	case "ValidationReportError.geometry":
		if e.complexity.ValidationReportError.Geometry == nil {
			break
		}

		return e.complexity.ValidationReportError.Geometry(childComplexity), true

	case "ValidationReportError.group_key":
		if e.complexity.ValidationReportError.GroupKey == nil {
			break
		}

		return e.complexity.ValidationReportError.GroupKey(childComplexity), true

	case "ValidationReportError.line":
		if e.complexity.ValidationReportError.Line == nil {
			break
		}

		return e.complexity.ValidationReportError.Line(childComplexity), true

	case "ValidationReportError.message":
		if e.complexity.ValidationReportError.Message == nil {
			break
		}

		return e.complexity.ValidationReportError.Message(childComplexity), true

	case "ValidationReportError.value":
		if e.complexity.ValidationReportError.Value == nil {
			break
		}

		return e.complexity.ValidationReportError.Value(childComplexity), true

	case "ValidationReportErrorGroup.count":
		if e.complexity.ValidationReportErrorGroup.Count == nil {
			break
		}

		return e.complexity.ValidationReportErrorGroup.Count(childComplexity), true

	case "ValidationReportErrorGroup.error_code":
		if e.complexity.ValidationReportErrorGroup.ErrorCode == nil {
			break
		}

		return e.complexity.ValidationReportErrorGroup.ErrorCode(childComplexity), true

	case "ValidationReportErrorGroup.error_type":
		if e.complexity.ValidationReportErrorGroup.ErrorType == nil {
			break
		}

		return e.complexity.ValidationReportErrorGroup.ErrorType(childComplexity), true

	case "ValidationReportErrorGroup.errors":
		if e.complexity.ValidationReportErrorGroup.Errors == nil {
			break
		}

		args, err := ec.field_ValidationReportErrorGroup_errors_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationReportErrorGroup.Errors(childComplexity, args["limit"].(*int)), true

	case "ValidationReportErrorGroup.field":
		if e.complexity.ValidationReportErrorGroup.Field == nil {
			break
		}

		return e.complexity.ValidationReportErrorGroup.Field(childComplexity), true

	case "ValidationReportErrorGroup.filename":
		if e.complexity.ValidationReportErrorGroup.Filename == nil {
			break
		}

		return e.complexity.ValidationReportErrorGroup.Filename(childComplexity), true

	case "ValidationReportErrorGroup.group_key":
		if e.complexity.ValidationReportErrorGroup.GroupKey == nil {
			break
		}

		return e.complexity.ValidationReportErrorGroup.GroupKey(childComplexity), true

	case "VehiclePosition.congestion_level":
		if e.complexity.VehiclePosition.CongestionLevel == nil {
			break
		}

		return e.complexity.VehiclePosition.CongestionLevel(childComplexity), true

	case "VehiclePosition.current_status":
		if e.complexity.VehiclePosition.CurrentStatus == nil {
			break
		}

		return e.complexity.VehiclePosition.CurrentStatus(childComplexity), true

	case "VehiclePosition.current_stop_sequence":
		if e.complexity.VehiclePosition.CurrentStopSequence == nil {
			break
		}

		return e.complexity.VehiclePosition.CurrentStopSequence(childComplexity), true

	case "VehiclePosition.position":
		if e.complexity.VehiclePosition.Position == nil {
			break
		}

		return e.complexity.VehiclePosition.Position(childComplexity), true

	case "VehiclePosition.stop_id":
		if e.complexity.VehiclePosition.StopID == nil {
			break
		}

		return e.complexity.VehiclePosition.StopID(childComplexity), true

	case "VehiclePosition.timestamp":
		if e.complexity.VehiclePosition.Timestamp == nil {
			break
		}

		return e.complexity.VehiclePosition.Timestamp(childComplexity), true

	case "VehiclePosition.vehicle":
		if e.complexity.VehiclePosition.Vehicle == nil {
			break
		}

		return e.complexity.VehiclePosition.Vehicle(childComplexity), true

	case "Waypoint.lat":
		if e.complexity.Waypoint.Lat == nil {
			break
		}

		return e.complexity.Waypoint.Lat(childComplexity), true

	case "Waypoint.lon":
		if e.complexity.Waypoint.Lon == nil {
			break
		}

		return e.complexity.Waypoint.Lon(childComplexity), true

	case "Waypoint.name":
		if e.complexity.Waypoint.Name == nil {
			break
		}

		return e.complexity.Waypoint.Name(childComplexity), true

	case "Waypoint.stop":
		if e.complexity.Waypoint.Stop == nil {
			break
		}

		return e.complexity.Waypoint.Stop(childComplexity), true

	case "WaypointDeparture.departure":
		if e.complexity.WaypointDeparture.Departure == nil {
			break
		}

		return e.complexity.WaypointDeparture.Departure(childComplexity), true

	case "WaypointDeparture.lat":
		if e.complexity.WaypointDeparture.Lat == nil {
			break
		}

		return e.complexity.WaypointDeparture.Lat(childComplexity), true

	case "WaypointDeparture.lon":
		if e.complexity.WaypointDeparture.Lon == nil {
			break
		}

		return e.complexity.WaypointDeparture.Lon(childComplexity), true

	case "WaypointDeparture.stop_code":
		if e.complexity.WaypointDeparture.StopCode == nil {
			break
		}

		return e.complexity.WaypointDeparture.StopCode(childComplexity), true

	case "WaypointDeparture.stop_id":
		if e.complexity.WaypointDeparture.StopID == nil {
			break
		}

		return e.complexity.WaypointDeparture.StopID(childComplexity), true

	case "WaypointDeparture.stop_index":
		if e.complexity.WaypointDeparture.StopIndex == nil {
			break
		}

		return e.complexity.WaypointDeparture.StopIndex(childComplexity), true

	case "WaypointDeparture.stop_name":
		if e.complexity.WaypointDeparture.StopName == nil {
			break
		}

		return e.complexity.WaypointDeparture.StopName(childComplexity), true

	case "WaypointDeparture.stop_onestop_id":
		if e.complexity.WaypointDeparture.StopOnestopID == nil {
			break
		}

		return e.complexity.WaypointDeparture.StopOnestopID(childComplexity), true

	case "WaypointDeparture.stop_sequence":
		if e.complexity.WaypointDeparture.StopSequence == nil {
			break
		}

		return e.complexity.WaypointDeparture.StopSequence(childComplexity), true

	case "WaypointStop.departure":
		if e.complexity.WaypointStop.Departure == nil {
			break
		}

		return e.complexity.WaypointStop.Departure(childComplexity), true

	case "WaypointStop.lat":
		if e.complexity.WaypointStop.Lat == nil {
			break
		}

		return e.complexity.WaypointStop.Lat(childComplexity), true

	case "WaypointStop.lon":
		if e.complexity.WaypointStop.Lon == nil {
			break
		}

		return e.complexity.WaypointStop.Lon(childComplexity), true

	case "WaypointStop.stop_code":
		if e.complexity.WaypointStop.StopCode == nil {
			break
		}

		return e.complexity.WaypointStop.StopCode(childComplexity), true

	case "WaypointStop.stop_id":
		if e.complexity.WaypointStop.StopID == nil {
			break
		}

		return e.complexity.WaypointStop.StopID(childComplexity), true

	case "WaypointStop.stop_name":
		if e.complexity.WaypointStop.StopName == nil {
			break
		}

		return e.complexity.WaypointStop.StopName(childComplexity), true

	case "WaypointStop.stop_onestop_id":
		if e.complexity.WaypointStop.StopOnestopID == nil {
			break
		}

		return e.complexity.WaypointStop.StopOnestopID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAgencyFilter,
		ec.unmarshalInputAgencyLocationFilter,
		ec.unmarshalInputAgencyPlaceFilter,
		ec.unmarshalInputBookingRuleFilter,
		ec.unmarshalInputBoundingBox,
		ec.unmarshalInputCalendarDateFilter,
		ec.unmarshalInputCensusDatasetFilter,
		ec.unmarshalInputCensusDatasetGeographyFilter,
		ec.unmarshalInputCensusDatasetGeographyLocationFilter,
		ec.unmarshalInputCensusGeographyFilter,
		ec.unmarshalInputCensusSourceFilter,
		ec.unmarshalInputCensusSourceGeographyFilter,
		ec.unmarshalInputCensusTableFilter,
		ec.unmarshalInputCensusValueFilter,
		ec.unmarshalInputDirectionRequest,
		ec.unmarshalInputFeature,
		ec.unmarshalInputFeedFetchFilter,
		ec.unmarshalInputFeedFilter,
		ec.unmarshalInputFeedSourceUrl,
		ec.unmarshalInputFeedVersionFilter,
		ec.unmarshalInputFeedVersionInput,
		ec.unmarshalInputFeedVersionServiceLevelFilter,
		ec.unmarshalInputFeedVersionSetInput,
		ec.unmarshalInputFocusPoint,
		ec.unmarshalInputGbfsBikeRequest,
		ec.unmarshalInputGbfsDockRequest,
		ec.unmarshalInputLevelSetInput,
		ec.unmarshalInputLicenseFilter,
		ec.unmarshalInputLocationFilter,
		ec.unmarshalInputLocationGroupFilter,
		ec.unmarshalInputOperatorFilter,
		ec.unmarshalInputPathwayFilter,
		ec.unmarshalInputPathwaySetInput,
		ec.unmarshalInputPlaceFilter,
		ec.unmarshalInputPointRadius,
		ec.unmarshalInputRouteFilter,
		ec.unmarshalInputRouteLocationFilter,
		ec.unmarshalInputSegmentFilter,
		ec.unmarshalInputSegmentPatternFilter,
		ec.unmarshalInputServiceCoversFilter,
		ec.unmarshalInputStopBuffer,
		ec.unmarshalInputStopExternalReferenceSetInput,
		ec.unmarshalInputStopFilter,
		ec.unmarshalInputStopLocationFilter,
		ec.unmarshalInputStopObservationFilter,
		ec.unmarshalInputStopSetInput,
		ec.unmarshalInputStopTimeFilter,
		ec.unmarshalInputTripFilter,
		ec.unmarshalInputTripStopTimeFilter,
		ec.unmarshalInputValidationReportFilter,
		ec.unmarshalInputWaypointInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../schema/graphql/directions.graphqls", Input: `# Directions API

input DirectionRequest {
  to: WaypointInput!
  from: WaypointInput!
  mode: StepMode!
  depart_at: Time
}

input WaypointInput {
  lon: Float!
  lat: Float!
  name: String
}

type Waypoint {
  lon: Float!
  lat: Float!
  name: String
  stop: WaypointStop
}

type WaypointStop {
  lon: Float!
  lat: Float!
  departure: Time!
  stop_id: String!
  stop_name: String!
  stop_code: String!
  stop_onestop_id: String!
}

type WaypointDeparture {
  lon: Float!
  lat: Float!
  departure: Time!
  stop_id: String!
  stop_name: String!
  stop_code: String!
  stop_onestop_id: String!
  stop_index: Int
  stop_sequence: Int
}

type LegTrip {
  trip_id: String!
  trip_short_name: String!
  headsign: String!
  feed_id: String!
  feed_version_sha1: String!
  route: LegRoute!
}

type LegRoute {
  route_id: String!
  route_short_name: String!
  route_long_name: String!
  route_onestop_id: String!
  route_type: Int!
  route_color: String
  route_text_color: String
  agency: LegRouteAgency!
}

type LegRouteAgency {
  agency_id: String!
  agency_name: String!
  agency_onestop_id: String!
}

type Directions {
  # metadata
  success: Boolean!
  exception: String
  data_source: String
  # input
  origin: Waypoint
  destination: Waypoint
  # first itin summary
  duration: Duration
  distance: Distance
  start_time: Time
  end_time: Time
  # itineraries
  itineraries: [Itinerary!]
}

type Itinerary {
  duration: Duration!
  distance: Distance!
  start_time: Time!
  end_time: Time!
  from: Waypoint!
  to: Waypoint!
  legs: [Leg!]
}

type Leg {
  duration: Duration!
  distance: Distance!
  start_time: Time!
  end_time: Time!
  from: Waypoint
  to: Waypoint
  mode: StepMode
  steps: [Step!]
  stops: [WaypointDeparture!]
  geometry: LineString!
  trip: LegTrip
}

type Step {
  duration: Duration!
  distance: Distance!
  start_time: Time!
  end_time: Time!
  to: Waypoint
  mode: StepMode!
  instruction: String!
  geometry_offset: Int!
}

type Distance {
  distance: Float!
  units: DistanceUnit!
}

type Duration {
  duration: Float!
  units: DurationUnit!
}

enum DurationUnit {
  SECONDS
}

enum DistanceUnit {
  KILOMETERS
  METERS
  MILES
}

enum StepMode {
  WALK
  AUTO
  BICYCLE
  TRANSIT
  LINE
}
`, BuiltIn: false},
	{Name: "../../../schema/graphql/gbfs.graphqls", Input: `# GBFS

type GbfsFeed {
	system_information:  GbfsSystemInformation
	station_information: [GbfsStationInformation!]
	rental_hours:  [GbfsSystemHour!]
	calendars: [GbfsSystemCalendar!]
	alerts: [GbfsSystemAlert!]
}

type GbfsSystemInformation  {
  system_id: String
  language: String
  name: String
  short_name: String
  operator: String
  url: String
  purchase_url: String
  start_date: Date
  phone_number: String
  email: String
  feed_contact_email: String
  timezone: String
  license_url: String
  terms_url: String
  terms_last_updated: Date
  privacy_url: String
  privacy_last_updated: Date
  brand_assets: GbfsBrandAsset
  rental_apps: GbfsRentalApps
}

type GbfsRentalApps {
	ios: GbfsRentalApp
	android: GbfsRentalApp
}

type GbfsRentalApp {
	store_uri: String
	discovery_uri: String
}

type GbfsBrandAsset {
	brand_last_modified: Date
	brand_terms_url: String
	brand_image_url: String
	brand_image_url_dark: String
	color: String
}

type GbfsStationInformation {
	station_id: String
	name: String
	short_name: String
	lat: Float
	lon: Float
	address: String
	cross_street: String
	post_code: String
	rental_methods: Strings
	is_virtual_station: Bool
	station_area: Geometry
	parking_type: String
	parking_hoop: Int
	contact_phone: String
	capacity: Int
	is_valet_station: Bool
	is_charging_station: Bool
	# vehicle_capacity: map[string]int
	feed: GbfsFeed
	region: GbfsSystemRegion
	status: GbfsStationStatus
}

type GbfsStationStatus  {
	station_id: String                
	num_bikes_available: Int                
	num_bikes_disabled: Int                
	num_docks_available: Int                
	num_docks_disabled:  Int                
	is_returning: Bool               
	is_renting: Bool               
	is_installed: Bool               
	last_reported: Int               
	vehicle_types_available: [GbfsVehicleTypeAvailable!]
	vehicle_docks_available: [GbfsVehicleDockAvailable!]
}

type GbfsVehicleTypeAvailable  {
	num_bikes_disabled: Int 
	num_docks_available: Int 
	count: Int 
	vehicle_type: GbfsVehicleType
}

type GbfsVehicleDockAvailable  {
	count: Int     
	vehicle_types: [GbfsVehicleType!]
}

type GbfsSystemVersion  {
	version: String 
	url: String 
}

type GbfsVehicleType  {
	vehicle_type_id: String     
	form_factor: String  
	rider_capacity: Int     
	cargo_volume_capacity: Int     
	cargo_load_capacity: Int     
	propulsion_type: String  
	eco_label: String  
	country_code: String  
	eco_sticker: String  
	max_range_meters: Float   
	name: String  
	vehicle_accessories: Strings
	gco_2_km: Int     
	vehicle_image: String  
	make: String  
	model: String  
	color: String  
	wheel_count: Int     
	max_permitted_speed: Int     
	rated_power: Int     
	default_reserve_time: Int     
	return_constraint: String  
	default_pricing_plan: GbfsSystemPricingPlan
	pricing_plans: [GbfsSystemPricingPlan!]
	rental_uris: GbfsRentalUris
	vehicle_assets: GbfsVehicleAssets
}

type GbfsVehicleAssets {
	icon_url: String
	icon_url_dark: String
	icon_last_modified: Date
}

type GbfsFreeBikeStatus {
	bike_id: String
	lat: Float   
	lon: Float   
	is_reserved: Bool    
	is_disabled: Bool    
	last_reported: Int
	current_range_meters: Float   
	current_fuel_percent: Float   
	vehicle_equipment: Strings
	available_until: Int    
	station: GbfsStationInformation    
	home_station: GbfsStationInformation    
	pricing_plan: GbfsSystemPricingPlan
	vehicle_type: GbfsVehicleType
	rental_uris: GbfsRentalUris
	feed: GbfsFeed
}

type GbfsRentalUris {
	android: String
	ios: String
	web: String
}

type GbfsSystemHour  {
	user_types: Strings 
	days: Strings
	start_time: String  
	end_time: String  
}

type GbfsSystemCalendar  {
	start_month: Int 
	start_day: Int 
	start_year: Int 
	end_month: Int 
	end_day: Int 
	end_year: Int 
}

type GbfsSystemRegion  {
	region_id: String    
	name: String 
}

type GbfsSystemPricingPlan  {
	plan_id: String      
	url: String   
	name: String   
	currency: String   
	price: Float    
	is_taxable: Bool     
	description: String   
	surge_pricing: Bool     
	per_km_pricing: [GbfsPlanPrice!] 
	per_min_pricing: [GbfsPlanPrice!]
}

type GbfsPlanPrice  {
	start: Int 
	rate: Float
	interval: Int 
	end: Int 
}

type GbfsSystemAlert  {
	alert_id: String      
	type: String   
	url: String   
	summary: String   
	description: String   
	last_updated: Int     
	# station_ids: Strings
	# region_ids: Strings
	times: [GbfsAlertTime!]
}

type GbfsAlertTime  {
	start: Int
	end: Int
}

type GbfsGeofenceZone  {
	type:     String
	features: [GbfsGeofenceFeature!]
}

type GbfsGeofenceFeature  {
	type: String           
	geometry: Geometry         
	# properties: map[string]GbfsGeofenceProperty 
}

type GbfsGeofenceProperty  {
	name: String      
	start: Int        
	end: Int        
	rules: [GbfsGeofenceRule]
}

type GbfsGeofenceRule  {
	ride_allowed: Bool    
	ride_through_allowed: Bool    
	maximum_speed_kph: Int     
	station_parking: Bool    
	vehicle_type: GbfsVehicleType
}

########

input GbfsBikeRequest {
	near: PointRadius
}

input GbfsDockRequest {
	near: PointRadius
}
`, BuiltIn: false},
	{Name: "../../../schema/graphql/schema.graphqls", Input: `# Scalar types

"""Counts of entities by filename"""
scalar Counts

"""String key/value pairs"""
scalar Tags

"""GeoJSON style geometry"""
scalar Geometry

"""Date with time, in UTC"""
scalar Time

"""Date"""
scalar Date

"""Geographic point (longitude,latitude)"""
scalar Point

"""Geographic points comprising a line"""
scalar LineString

"""Geographic polygon"""
scalar Polygon

"""Geographic MultiPolygon"""
scalar MultiPolygon

"""Local time since midnight, in HH:MM:SS. May also be input as integer seconds."""
scalar Seconds

"""Map with arbitrary keys and values"""
scalar Map

"""Any value"""
scalar Any

"""File upload"""
scalar Upload

"""Entity key"""
scalar Key

"""Boolean (true, false, null)"""
scalar Bool

"""Array of strings"""
scalar Strings

"""A color"""
scalar Color

"""A Language"""
scalar Language

"""URL"""
scalar Url

"""Email"""
scalar Email

"""Timezone"""
scalar Timezone

# Force resolver
directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

# Root query
type Query {
  "Feeds"
  feeds(limit: Int, after: Int, ids: [Int!], where: FeedFilter): [Feed!]!
  "Operators"
  operators(limit: Int, after: Int, ids: [Int!], where: OperatorFilter): [Operator!]!
  "Feed versions"
  feed_versions(limit: Int, after: Int, ids: [Int!], where: FeedVersionFilter): [FeedVersion!]!
  "Currently imported agencies. If no feed version is specified, defaults to active feed versions."
  agencies(limit: Int, after: Int, ids: [Int!], where: AgencyFilter): [Agency!]!
  "Currently imported routes. If no feed version is specified, defaults to active feed versions."
  routes(limit: Int, after: Int, ids: [Int!], where: RouteFilter): [Route!]!
  "Currently imported stops. If no feed version is specified, defaults to active feed versions."
  stops(limit: Int, after: Int, ids: [Int!], where: StopFilter): [Stop!]!
  "Currently imported trips. If no feed version is specified, defaults to active feed versions."
  trips(limit: Int, after: Int, ids: [Int!], where: TripFilter): [Trip!]!
  "Operator counts by administrative place"
  places(limit: Int,after: Int, level: PlaceAggregationLevel, where: PlaceFilter): [Place!]
  "Directions requests API"
  directions(where: DirectionRequest!): Directions!
  "Current GBFS floating bike data"
  bikes(limit: Int, where: GbfsBikeRequest): [GbfsFreeBikeStatus!]
  "Current GBFS dock data"
  docks(limit: Int, where: GbfsDockRequest): [GbfsStationInformation!]
  "Current user metadata"
  me: Me!
  """Census datasets"""
  census_datasets(limit: Int, after: Int, ids: [Int!], where: CensusDatasetFilter): [CensusDataset!]
  """Census values - query by geoid, dataset, or table"""
  census_values(limit: Int, where: CensusValueFilter): [CensusValue!]!
}

# Root mutation
type Mutation {
  "Validate GTFS"
  validate_gtfs(file: Upload, url: String, realtime_urls: [String!]): ValidationReport
  "Update a feed version"
  feed_version_update(set: FeedVersionSetInput!): FeedVersion
  "Fetch a feed version"
  feed_version_fetch(file: Upload, url: String, feed_onestop_id: String!): FeedVersionFetchResult
  "Import a feed version"
  feed_version_import(id: Int!): FeedVersionImportResult!
  "Unimport a feed version"
  feed_version_unimport(id: Int!): FeedVersionUnimportResult!
  "Delete a feed version"
  feed_version_delete(id: Int!): FeedVersionDeleteResult!

  "Create a stop"
  stop_create(set: StopSetInput!): Stop!
  "Update a stop"
  stop_update(set: StopSetInput!): Stop!
  "Delete a stop"
  stop_delete(id: Int!): EntityDeleteResult!

  # levels
  "Create a level"
  level_create(set: LevelSetInput!): Level!
  "Update a level"
  level_update(set: LevelSetInput!): Level!
  "Delete a level"
  level_delete(id: Int!): EntityDeleteResult!

  # pathways
  "Create a pathway"
  pathway_create(set: PathwaySetInput!): Pathway!
  "Update a pathway"
  pathway_update(set: PathwaySetInput!): Pathway!
  "Delete a pathway"
  pathway_delete(id: Int!): EntityDeleteResult!
}

"""Result of entity delete operation"""
type EntityDeleteResult {
  "ID of deleted entity"
  id: Int!
}

"""Current user metadata"""
type Me {
  "Internal identifier"
  id: String!
  "User name"
  name: String
  "User email"
  email: String
  "User associated roles"
  roles: [String!]
  "User associated external data, e.g. metering service identifiers"
  external_data: Map!
}

"""Feeds contain details on how to access transit information, including URLs to data sources in various formats (GTFS, GTFS-RT, GBFS, etc), license information, related feeds, details on how to make authorized requests, and current and archived feed versions.

Feed versions are archived (as ` + "`" + `.zip` + "`" + ` files) and imported into the database for querying agencies, stops, routes, trips, etc."""
type Feed {
  "Internal integer ID"
  id: Int!
  "OnestopID for this feed"
  onestop_id: String!
  "A common name for this feed. Optional. Alternatively use ` + "`" + `associated_operators[].name` + "`" + `"
  name: String
  "Source DMFR file for this feed"
  file: String!
  "Type of feed"
  spec: FeedSpecTypes
  "Language(s) included in this feed"
  languages: [String!]
  "Optional tags defined in Transitlant Atlas providing more info about this feed"
  tags: Tags
  "Authorization metadata for fetching data from this feed"
  authorization: FeedAuthorization
  "URLs associated with this feed"
  urls: FeedUrls
  "Feed license metadata"
  license: FeedLicense
  "Search rank: internal"
  search_rank: String # only for search results
  "Operators associated with this feed"
  associated_operators: [Operator!]
  "Current feed state"
  feed_state: FeedState
  "Fetch attempts for this feed"
  feed_fetches(limit: Int, where: FeedFetchFilter): [FeedFetch!]
  "Versions of this feed that have been fetched, archived, and imported"
  feed_versions(limit: Int, where: FeedVersionFilter): [FeedVersion!]!
}

"""Details on the current state of this feed, such as active version, last fetch time, etc."""
type FeedState {
  "Internal integer ID"
  id: Int!
  "The active feed version for this feed"
  feed_version: FeedVersion
}

"""Record of a feed fetch operation"""
type FeedFetch {
  "Internal integer ID"
  id: Int!
  "URL type, e.g. static_current, realtime_alerts..."
  url_type: String
  "URL fetched"
  url: String
  "Was the request successful?"
  success: Boolean
  "Fetched at"
  fetched_at: Time
  "Exception log if the fetch did not succeed"
  fetch_error: String
  "Server response size, in bytes"
  response_size: Int
  "Server response code (if HTTP)"
  response_code: Int
  "SHA1 sum of the server response"
  response_sha1: String
}

"""Details on how to construct an HTTP request to access a protected resource"""
type FeedAuthorization {
  "Method for inserting authorization secret into request"
  type: String!
  "When ` + "`" + `type=query_param` + "`" + `, this specifies the name of the query parameter. When ` + "`" + `type=header` + "`" + `, this specifies the name of the header"
  param_name: String!
  "Website to visit to sign up for an account"
  info_url: String!
}

"""License information for this feed, curated by Interline and contributors to the Transitland Atlas feed registry. Note that this does not constitute legal advice. Users are advised to review and confirm any terms and conditions attached to a source feed."""
type FeedLicense {
  "SPDX identifier for a common license. See https://spdx.org/licenses/"
  spdx_identifier: String!
  "URL for a custom license"
  url: String!
  "Are feed consumers allowed to use the feed contents without including attribution text in their app or map?"
  use_without_attribution: String!
  "Are feed consumers allowed to create and share derived products from the feed?"
  create_derived_product: String!
  "Are feed consumers allowed to redistribute the feed in its entirety?"
  redistribution_allowed: String!
  "Are feed consumers allowed to use the feed for commercial purposes?"
  commercial_use_allowed: String!
  "Are feed consumers allowed to keep their modifications of this feed private?"
  share_alike_optional: String!
  "Feed consumers must include this particular text when using this feed"
  attribution_text: String!
  "Feed consumers must follow these instructions for how to provide attribution"
  attribution_instructions: String!
}

"""URL(s) from which Transitland sources a feed"""
type FeedUrls {
  "URL for the static feed that represents today's service"
  static_current: String!
  "URLs for static feeds that represent past service that is no longer in effect "
  static_historic: [String!]!
  "URLs for static feeds that represent service planned for upcoming dates. Typically used to represent calendar/service changes that will take effect few weeks or months in the future"
  static_planned: [String!]!
  "URL for GTFS-RT VehiclePosition messages"
  realtime_vehicle_positions: String!
  "URL for GTFS-RT TripUpdate messages"
  realtime_trip_updates: String!
  "URL for GTFS-RT Alert messages"
  realtime_alerts: String!
  "URL for GBFS feed ` + "`" + `gbfs.json` + "`" + ` auto-discovery file"
  gbfs_auto_discovery: String!
  "URL for MDS feed provider endpoint"
  mds_provider: String!
}

"""Feed versions represent a specific static GTFS file that was published at a particular point in time, and are generally accessed and referenced using the [SHA1 checksum](https://en.wikipedia.org/wiki/SHA-1) of the GTFS archive."""
type FeedVersion {
  "Internal integer ID"
  id: Int!
  "SHA1 hash of the zip file [example:ab5bdc8b6cedd06792d42186a9b542504c5eef9a]"
  sha1: String!
  "Time when the file was fetched from the url [example:2021-07-09T05:11:00Z]"
  fetched_at: Time!
  "URL used to fetch the file"
  url: String!
  "The earliest date with scheduled service [example:2020-01-01]"
  earliest_calendar_date: Date!
  "The latest date with scheduled service [example:2020-12-31]"
  latest_calendar_date: Date!
  "Record created by user"
  created_by: String
  "Record updated by user"
  updated_by: String
  "An optional name for this feed version"
  name: String
  "An optional description for this feed version"
  description: String
  "Reference to file storage location"
  file: String
  "Convex hull around all active stops in the feed version"
  geometry: Polygon
  "Feed associated with this feed version"
  feed: Feed!
  "Current database import status of this feed version"
  feed_version_gtfs_import: FeedVersionGtfsImport
  "Metadata for each text file present in the main directory of the zip archive"
  files(limit: Int): [FeedVersionFileInfo!]!
  "Service levels (in seconds per day) for this feed version"
  service_levels(limit: Int, where: FeedVersionServiceLevelFilter): [FeedVersionServiceLevel!]!
  "Summary details on service dates for this feed version"
  service_window: FeedVersionServiceWindow
  "Agencies associated with this feed version, if imported"
  agencies(limit: Int, where: AgencyFilter): [Agency!]!
  "Routes associated with this feed version, if imported"
  routes(limit: Int, where: RouteFilter): [Route!]!
  "Stops associated with this feed version, if imported"
  stops(limit: Int, where: StopFilter): [Stop!]!
  "Trips associated with this feed version, if imported"
  trips(limit: Int, where: TripFilter): [Trip!]!
  "GTFS Flex locations associated with this feed version, if imported"
  locations(limit: Int, where: LocationFilter): [Location!]!
  "GTFS Flex booking rules associated with this feed version, if imported"
  booking_rules(limit: Int, where: BookingRuleFilter): [BookingRule!]!
  "GTFS Flex location groups associated with this feed version, if imported"
  location_groups(limit: Int, where: LocationGroupFilter): [LocationGroup!]!
  "Feed infos associated with this feed version, if imported"
  feed_infos(limit: Int): [FeedInfo!]!
  "Validation reports associated with this feed version"
  validation_reports(limit: Int, where: ValidationReportFilter): [ValidationReport!]
  "Normalized route segment data associated with this feed version, if available"
  segments(limit: Int): [Segment!]
}

"""Metadata for each file contained within a GTFS archive"""
type FeedVersionFileInfo {
  "Internal integer ID"
  id: Int!
  "Name of the file"
  name: String!
  "Number of rows in the file"
  rows: Int!
  "SHA1 hash of the file"
  sha1: String!
  "Normalized header row of the file, if CSV-like"
  header: String!
  "Is the file CSV-like?"
  csv_like: Boolean!
  "File size, in bytes"
  size: Int!
  "Counts of values for each column"
  values_count: Counts!
  "Counts of number of unique values for each column"
  values_unique: Counts!
}

"""Current database import status for a feed version"""
type FeedVersionGtfsImport {
  "Internal integer ID"
  id: Int!
  "Is the import currently in-progress"
  in_progress: Boolean!
  "Did the import complete successfully"
  success: Boolean!
  "Has the schedule (stop times, trips) been archived"
  schedule_removed: Boolean!
  "Exception log if any errors occurred during import"
  exception_log: String!
  "Counts of entities skipped due to errors"
  skip_entity_error_count: Any
  "Counts of successfully imported entities by file name"
  entity_count: Any
  "Counts of warnings by file name"
  warning_count: Any
  "Counts of entities skipped due to reference errors"
  skip_entity_reference_count: Any
  "Counts of entities skipped due to import filters"
  skip_entity_filter_count: Any
  "Counts of entities skipped due to marker filters"
  skip_entity_marked_count: Any
  "Number of stop times with arrival/departure times set by interpolation during import process"
  interpolated_stop_time_count: Int
  "Created at"
  created_at: Time
  "Updated at"
  updated_at: Time
}

"""Summary details on service dates in a feed version"""
type FeedVersionServiceWindow {
  "Internal integer ID"
  id: Int!
  "Feed start date from feed_info.txt, if available"
  feed_start_date: Date
  "Feed end date from feed_info.txt, if available"
  feed_end_date: Date
  "Calculated earliest calendar date in service schedule"
  earliest_calendar_date: Date
  "Calculated latest calendar date in service schedule"
  latest_calendar_date: Date
  "Week with most typical service patterns inside the service window"
  fallback_week: Date
  "Default timezone for this feed version"
  default_timezone: String
}

"""Number of seconds of service scheduled for each day in a feed version"""
type FeedVersionServiceLevel {
  "Internal integer ID"
  id: Int!
  "Start date of this week"
  start_date: Date!
  "End date of this week"
  end_date: Date!
  "Number of seconds of service scheduled on the Monday of this week"
  monday: Int!
  "Number of seconds of service scheduled on the Tuesday of this week"
  tuesday: Int!
  "Number of seconds of service scheduled on the Wednesday of this week"
  wednesday: Int!
  "Number of seconds of service scheduled on the Thursday of this week"
  thursday: Int!
  "Number of seconds of service scheduled on the Friday of this week"
  friday: Int!
  "Number of seconds of service scheduled on the Saturday of this week"
  saturday: Int!
  "Number of seconds of service scheduled on the Sunday of this week"
  sunday: Int!
}

# Operator
"""
An agency represents a single GTFS ` + "`" + `agencies.txt` + "`" + ` entity that was imported from a single feed version. The metadata, routes, etc., for an agency include only the data for that specific agency in that specific feed version.

Operators are a higher-level abstraction over agencies, with each operator defined by an entry in the [Transitland Atlas](/documentation/atlas). Operators provide a method for enriching the basic GTFS agency data, as well as grouping agencies that span across multiple source feeds. Operators are matched with GTFS agencies using ` + "`" + `associated_feeds` + "`" + `, a simple list of Feed OnestopIDs and GTFS ` + "`" + `agency_id` + "`" + `s. For instance, the [Atlas operator record](https://github.com/transitland/transitland-atlas/blob/master/operators/o-dr5r-nyct.json) for the [New York City MTA](/operators/o-dr5r-nyct) has ` + "`" + `associated_feeds` + "`" + ` values for 8 different GTFS feeds. A query for this operator OnestopID thus represents the union of data from all 8 feeds, and includes routes for the subway, bus service for all 5 boroughs, commuter rail agencies, etc., operated by the MTA. This record also includes additional metadata about the MTA, such as the United States National Transit Database ID, Wikidata IDs, and alternate names for the agency. Operator records are created and maintained through pull requests to the Atlas json files and synchronized with the Transitland database on each commit.
"""
type Operator {
  "Internal integer ID"
  id: Int!
  "Was this operator generated automatically from GTFS data"
  generated: Boolean!
  "Source DMFR file for this operator"
  file: String
  "OnestopID for this operator"
  onestop_id: String
  "Operator name"
  name: String
  "Operator short name, if available"
  short_name: String
  "Operator website, if available"
  website: String
  "Optional tags defined in Transitlant Atlas providing more info about this operator"
  tags: Tags
  "Search rank: internal"
  search_rank: String
  "Currently imported and active agencies associated with this operator"
  agencies: [Agency!]
  "Feeds associated with this operator"
  feeds(limit: Int, where: FeedFilter): [Feed!]
}

# GTFS Entities

"""Record from a static GTFS [agency.txt](https://gtfs.org/reference/static/#agencytxt)"""
type Agency {
  "Internal integer ID"
  id: Int!
  "OnestopID for this agency (or its associated operator)"
  onestop_id: String!
  "GTFS agency.agency_email"
  agency_email: Email
  "GTFS agency.agency_fare_url"
  agency_fare_url: Url
  "GTFS agency.agency_id"
  agency_id: String!
  "GTFS agency.agency_lang"
  agency_lang: Language
  "GTFS agency.agency_name"
  agency_name: String!
  "GTFS agency.agency_phone"
  agency_phone: String
  "GTFS agency.agency_timezone"
  agency_timezone: Timezone!
  "GTFS agency.agency_url"
  agency_url: Url!
  "Feed version SHA1 associated with this entity"
  feed_version_sha1: String
  "Feed OnestopID associated with this entity"
  feed_onestop_id: String
  "Source feed version for this entity"
  feed_version: FeedVersion!
  "Geometry for this agency, generated as the convex hull of all stops"
  geometry: Polygon
  "Search rank: internal"
  search_rank: String
  "Operator associated with this agency"
  operator: Operator
  "Places associated with this agency through a matching process"
  places(limit: Int, where: AgencyPlaceFilter): [AgencyPlace!]
  "Routes associated with this agency"
  routes(limit: Int, where: RouteFilter): [Route!]!
  "Census geographies associated with this agency"
  census_geographies(limit: Int, where: CensusGeographyFilter): [CensusGeography!]
  "GTFS-RT alerts for this agency"
  alerts(active: Boolean, limit: Int): [Alert!]
}

"""Record from a static GTFS [routes.txt](https://gtfs.org/reference/static/#routestxt)"""
type Route {
  "Internal integer ID"
  id: Int!
  "OnestopID for this route"
  onestop_id: String
  "GTFS routes.route_id"
  route_id: String!
  "GTFS routes.route_short_name"
  route_short_name: String
  "GTFS routes.route_long_name"
  route_long_name: String
  "GTFS routes.route_type"
  route_type: Int!
  "GTFS routes.route_color"
  route_color: Color
  "GTFS routes.route_text_color"
  route_text_color: Color
  "GTFS routes.route_sort_order"
  route_sort_order: Int
  "GTFS routes.route_url"
  route_url: Url
  "GTFS routes.route_desc"
  route_desc: String
  "GTFS routes.continuous_pickup"
  continuous_pickup: Int
  "GTFS routes.continuous_drop_off"
  continuous_drop_off: Int
  "Representative geometry for this route"
  geometry: Geometry @goField(forceResolver: true)
  "Agency associated with this route"
  agency: Agency!
  "Feed version SHA1 associated with this entity"
  feed_version_sha1: String
  "Feed OnestopID associated with this entity"
  feed_onestop_id: String
  "Source feed version for this entity"
  feed_version: FeedVersion!
  "Search rank: internal"
  search_rank: String
  "Extended route attributes, based on MTC GTFS+ extension"
  route_attribute: RouteAttribute
  "Trips associated with this route"
  trips(limit: Int, where: TripFilter): [Trip!]!
  "Stops associated with this route"
  stops(limit: Int, where: StopFilter): [Stop!]!
  "Stops associated with this route"
  route_stops(limit: Int): [RouteStop!]!
  "Calculated headways for this route"
  headways(limit: Int): [RouteHeadway!]!
  "Representative geometries for this route"
  geometries(limit: Int): [RouteGeometry!]!
  "Census geographies associated with this route"
  census_geographies(limit: Int, where: CensusGeographyFilter): [CensusGeography!]
  "Calculated spatial buffer geometry around this route"
  route_stop_buffer(radius: Float): RouteStopBuffer!
  "Stop patterns for this route"
  patterns: [RouteStopPattern!]
  "GTFS-RT alerts for this route"
  alerts(active: Boolean, limit: Int): [Alert!]
  "Normalized route segment data for this route, if available"
  segments(limit: Int, where: SegmentFilter): [Segment!]
  "Normalized route segment patterns for this route, if available"
  segment_patterns(limit: Int, where: SegmentPatternFilter): [SegmentPattern!]
}

"""Record from a static GTFS [stops.txt](https://gtfs.org/reference/static/#stopstxt)"""
type Stop {
  "Internal integer ID"
  id: Int!
  "OnestopID for this stop, if available [example:s-dr5ruvgnyk-madisonav~e69st]"
  onestop_id: String!
  "GTFS stops.location_type; this is optional in GTFS spec [enum:0,1,2,3,4]"
  location_type: Int!
  "GTFS stops.stop_code"
  stop_code: String
  "GTFS stops.stop_desc [example:NW Corner of Broadway and 14th]"
  stop_desc: String
  "GTFS stops.stop_id [example:400029]"
  stop_id: String!
  "GTFS stops.stop_name [example:MADISON AV/E 68 ST]"
  stop_name: String
  "GTFS stops.stop_timezone; if overriding agency/route timezone [example:America/Los_Angeles]"
  stop_timezone: Timezone
  "GTFS stops.stop_url [example:https://www.bart.gov/stations/ftvl]"
  stop_url: Url
  "GTFS stops.wheelchair_boarding [enum:0,1,2]"
  wheelchair_boarding: Int
  "GTFS stops.zone_id"
  zone_id: String
  "GTFS stops.platform_code"
  platform_code: String
  "GTFS stops.tts_stop_name"
  tts_stop_name: String
  "Stop geometry"
  geometry: Point!
  "Feed version SHA1 identifier"
  feed_version_sha1: String!
  "Feed OnestopID"
  feed_onestop_id: String!
  "Feed version"
  feed_version: FeedVersion!
  "GTFS Flex location groups associated with this stop"
  location_groups(limit: Int): [LocationGroup!]!
  "Stop level"
  level: Level
  "Stop parent station"
  parent: Stop
  "Stop external reference"
  external_reference: StopExternalReference
  "Stop observations"
  observations(limit: Int, where: StopObservationFilter): [StopObservation!]
  "Stop children"
  children(limit: Int): [Stop!]
  "Associated routes"
  route_stops(limit: Int): [RouteStop!]!
  "Dependent levels"
  child_levels(limit: Int): [Level!]!
  "Pathways from this stop"
  pathways_from_stop(limit: Int): [Pathway!]!
  "Pathways to this stop"
  pathways_to_stop(limit: Int): [Pathway!]!
  "Stop times for this stop"
  stop_times(limit: Int, where: StopTimeFilter): [StopTime!]!
  "Departures from this stop for a given date and time"
  departures(limit: Int, where: StopTimeFilter): [StopTime!]!
  "Arrivals from this stop for a given date and time"
  arrivals(limit: Int, where: StopTimeFilter): [StopTime!]!
  "Search Rank: Internal"
  search_rank: String
  "State/Province associated with this stop"
  place: StopPlace
  "Census geographies associated with this stop"
  census_geographies(limit: Int, where: CensusGeographyFilter): [CensusGeography!]
  "Directions from this stop"
  directions(to:WaypointInput, from: WaypointInput, mode: StepMode, depart_at: Time): Directions!
  "Stops within a specified radius of this stop"
  nearby_stops(limit: Int, radius: Float): [Stop!]
  "GTFS-RT Alerts for this stop"
  alerts(active: Boolean, limit: Int): [Alert!]
  "Matching feature ids from polygon search"
  within_features: Strings
}

"""Record from a static GTFS [pathways.txt](https://gtfs.org/reference/static/#pathwaysstxt). Pathways are a graph representation of a subway or train station, with nodes (entrances, platforms, etc) and edges (the pathways). See https://gtfs.org/reference/static/#pathwaystxt"""
type Pathway {
  "Internal integer ID"
  id: Int!
  "GTFS pathways.pathway_id"
  pathway_id: String!
  "GTFS pathways.pathway_mode"
  pathway_mode: Int!
  "GTFS pathways.is_bidirectional"
  is_bidirectional: Int!
  "GTFS pathways.length"
  length: Float
  "GTFS pathways.traversal_time"
  traversal_time: Int
  "GTFS pathways.stair_count"
  stair_count: Int
  "GTFS pathways.max_slope"
  max_slope: Float
  "GTFS pathways.min_width"
  min_width: Float
  "GTFS pathways.signposted_ss"
  signposted_as: String
  "GTFS pathways.reverse_signposted_as"
  reverse_signposted_as: String
  "Pathway begins at this stop"
  from_stop: Stop!
  "Pathway ends at this stop"
  to_stop: Stop!
}

"""Record from a static GTFS [levels.txt](https://gtfs.org/reference/static/#levelstxt). Levels describes different levels of a station; used in conjunction with pathways."""
type Level {
  "Internal integer ID"
  id: Int!
  "GTFS levels.level_id"
  level_id: String!
  "GTFS levels.level_index"
  level_index: Float!
  "GTFS levels.level_name"
  level_name: String
  "An optional geometry describing the footprint of this level"
  geometry: MultiPolygon!
  "Stops associated with this level"
  stops: [Stop!]
}

"""Record from a static GTFS [trips.txt](https://gtfs.org/schedule/reference/#tripstxt) file optionally enriched with by GTFS Realtime [TripUpdate](https://gtfs.org/reference/realtime/v2/#message-tripupdate) and [Alert](https://gtfs.org/reference/realtime/v2/#message-alert) messages."""
type Trip {
  "Internal integer ID"
  id: Int!
  "GTFS trips.trip_id"
  trip_id: String!
  "GTFS trips.trip_headsign"
  trip_headsign: String
  "GTFS trips.trip_short_name"
  trip_short_name: String
  "GTFS trips.direction_id"
  direction_id: Int
  "GTFS trips.block_id"
  block_id: String
  "GTFS trips.wheelchair_accessible"
  wheelchair_accessible: Int
  "GTFS trips.bikes_allowed"
  bikes_allowed: Int
  "Calculated stop pattern ID; an integer scoped to the feed version"
  stop_pattern_id: Int!
  "Calendar for this trip"
  calendar: Calendar!
  "Route for this trip"
  route: Route!
  "Shape for this trip"
  shape: Shape
  "Feed version for this entity"
  feed_version: FeedVersion!
  "Stop times for this trip"
  stop_times(limit: Int, where: TripStopTimeFilter): [StopTime]!
  "GTFS Flex stop times for this trip (Locations and Location Groups)"
  flex_stop_times(limit: Int, where: TripStopTimeFilter): [FlexStopTime!]!
  "Frequencies for this trip"
  frequencies(limit: Int): [Frequency!]!
  "GTFS-RT alerts for this trip"
  alerts(active: Boolean, limit: Int): [Alert!]
  """A status flag for real-time information about this trip.

  If no real-time information is available, the value will be STATIC and the estimated arrival/departure times will be empty. A trip with real-time information available will be SCHEDULED; a canceled trip will be CANCELED, and an added trip that is not present in the static GTFS will be ADDED.
  """
  schedule_relationship: ScheduleRelationship
  "GTFS-RT TripUpdate timestamp"
  timestamp: Time
}

"""Record from a static GTFS [calendars.txt](https://gtfs.org/schedule/reference/#calendarstxt) file, plus associated [calendar_dates.txt](https://gtfs.org/schedule/reference/#calendar_datestxt)."""
type Calendar {
  "Internal integer ID"
  id: Int!
  "GTFS calendar.service_id"
  service_id: String!
  "GTFS calendar.start_date"
  start_date: Date!
  "GTFS calendar.end_date"
  end_date: Date!
  "GTFS calendar.monday"
  monday: Int!
  "GTFS calendar.tuesday"
  tuesday: Int!
  "GTFS calendar.wednesday"
  wednesday: Int!
  "GTFS calendar.thursday"
  thursday: Int!
  "GTFS calendar.friday"
  friday: Int!
  "GTFS calendar.saturday"
  saturday: Int!
  "GTFS calendar.sunday"
  sunday: Int!
  "Added dates, derived from GTFS calendar_dates"
  added_dates(limit: Int): [Date!]!
  "Removed dates, derived from GTFS calendar_dates"
  removed_dates(limit: Int): [Date!]!
}

"""Record from a static GTFS [shapes.txt](https://gtfs.org/schedule/reference/#shapestxt) file."""
type Shape {
  "Internal integer ID"
  id: Int!
  "GTFS shapes.shape_id"
  shape_id: String!
  "Geometry for this shape"
  geometry: LineString!
  "Was this geometry automatically generated from stop locations?"
  generated: Boolean!
}

"""Record from a static GTFS [frequencies.txt](https://gtfs.org/schedule/reference/#frequenciestxt) file."""
type Frequency {
  "Internal integer ID"
  id: Int!
  "GTFS frequencies.start_time"
  start_time: Seconds!
  "GTFS frequencies.end_time"
  end_time: Seconds!
  "GTFS frequencies.headway_secs"
  headway_secs: Int!
  "GTFS frequencies.exact_times"
  exact_times: Int
}

"""Record from a static GTFS [stop_times.txt](https://gtfs.org/schedule/reference/#stop_timestxt) file."""
type StopTime {
  "GTFS stop_times.arrival_time"
  arrival_time: Seconds
  "GTFS stop_times.departure_time"
  departure_time: Seconds
  "GTFS stop_times.stop_sequence"
  stop_sequence: Int!
  "GTFS stop_times.stop_headsign"
  stop_headsign: String
  "GTFS stop_times.pickup_type"
  pickup_type: Int
  "GTFS stop_times.drop_off_type"
  drop_off_type: Int
  "GTFS stop_times.timepoint"
  timepoint: Int
  "GTFS stop_times.continuous_drop_off"
  continuous_drop_off: Int
  "GTFS stop_times.continuous_pickup"
  continuous_pickup: Int
  "GTFS stop_times.shape_dist_traveled"
  shape_dist_traveled: Float
  "Set if this arrival/departure time was interpolated during import"
  interpolated: Int
  "GTFS stop_times.start_pickup_drop_off_window"
  start_pickup_drop_off_window: Seconds
  "GTFS stop_times.end_pickup_drop_off_window"
  end_pickup_drop_off_window: Seconds
  "GTFS stop_times.pickup_booking_rule_id"
  pickup_booking_rule: BookingRule
  "GTFS stop_times.drop_off_booking_rule_id"
  drop_off_booking_rule: BookingRule
  "Stop associated with this stop time"
  stop: Stop!
  "Trip associated with this stop time"
  trip: Trip!
  "Detailed arrival information, including GTFS-RT updates and estimates"
  arrival: StopTimeEvent!
  "Detailed departure information, including GTFS-RT updates and estimates"
  departure: StopTimeEvent!
  "If part of an arrival/departure query, the GTFS service date for this scheduled stop time"
  service_date: Date
  "If part of an arrival/departure query, the calendar date for this scheduled stop time"
  date: Date
  """A status flag for real-time information about this trip.

  If no real-time information is available, the value will be STATIC and the estimated arrival/departure times will be empty. A trip with real-time information available will be SCHEDULED; a canceled trip will be CANCELED, and an added trip that is not present in the static GTFS will be ADDED.
  """
  schedule_relationship: ScheduleRelationship
}

"""Record from a static GTFS [stop_times.txt](https://gtfs.org/schedule/reference/#stop_timestxt) file, representing a service at a Location or Location Group."""
type FlexStopTime {
  "GTFS stop_times.arrival_time"
  arrival_time: Seconds
  "GTFS stop_times.departure_time"
  departure_time: Seconds
  "GTFS stop_times.stop_sequence"
  stop_sequence: Int!
  "GTFS stop_times.stop_headsign"
  stop_headsign: String
  "GTFS stop_times.pickup_type"
  pickup_type: Int
  "GTFS stop_times.drop_off_type"
  drop_off_type: Int
  "GTFS stop_times.timepoint"
  timepoint: Int
  "GTFS stop_times.continuous_drop_off"
  continuous_drop_off: Int
  "GTFS stop_times.continuous_pickup"
  continuous_pickup: Int
  "GTFS stop_times.shape_dist_traveled"
  shape_dist_traveled: Float
  "Set if this arrival/departure time was interpolated during import"
  interpolated: Int
  "GTFS stop_times.start_pickup_drop_off_window"
  start_pickup_drop_off_window: Seconds
  "GTFS stop_times.end_pickup_drop_off_window"
  end_pickup_drop_off_window: Seconds
  "GTFS stop_times.pickup_booking_rule_id"
  pickup_booking_rule: BookingRule
  "GTFS stop_times.drop_off_booking_rule_id"
  drop_off_booking_rule: BookingRule
  "Location associated with this stop time"
  location: Location
  "Location Group associated with this stop time"
  location_group: LocationGroup
  "Trip associated with this stop time"
  trip: Trip!
  "Detailed arrival information, including GTFS-RT updates and estimates"
  arrival: StopTimeEvent!
  "Detailed departure information, including GTFS-RT updates and estimates"
  departure: StopTimeEvent!
  "If part of an arrival/departure query, the GTFS service date for this scheduled stop time"
  service_date: Date
  "If part of an arrival/departure query, the calendar date for this scheduled stop time"
  date: Date
  """A status flag for real-time information about this trip.

  If no real-time information is available, the value will be STATIC and the estimated arrival/departure times will be empty. A trip with real-time information available will be SCHEDULED; a canceled trip will be CANCELED, and an added trip that is not present in the static GTFS will be ADDED.
  """
  schedule_relationship: ScheduleRelationship
}

"""Record from a static GTFS [feed_info.txt](https://gtfs.org/schedule/reference/#feed_infotxt) file."""
type FeedInfo {
  "Internal integer ID"
  id: Int!
  "GTFS feed_info.feed_publisher_name"
  feed_publisher_name: String!
  "GTFS feed_info.feed_publisher_url"
  feed_publisher_url: Url!
  "GTFS feed_info.feed_lang"
  feed_lang: Language!
  "GTFS feed_info.default_lang"
  default_lang: Language
  "GTFS feed_info.feed_version"
  feed_version: String
  "GTFS feed_info.feed_start_date"
  feed_start_date: Date
  "GTFS feed_info.feed_end_date"
  feed_end_date: Date
  "GTFS feed_info.feed_contact_email"
  feed_contact_email: Email
  "GTFS feed_info.feed_contact_url"
  feed_contact_url: Url
}

"""Record from a static GTFS [locations.geojson](https://gtfs.org/schedule/reference/#locationsgeojson) file."""
type Location {
  "Internal integer ID"
  id: Int!
  "GTFS locations.location_id"
  location_id: String!
  "GTFS locations.stop_name"
  stop_name: String
  "GTFS locations.stop_desc"
  stop_desc: String
  "GTFS locations.zone_id"
  zone_id: String
  "GTFS locations.stop_url"
  stop_url: Url
  "Geometry for this location"
  geometry: Geometry!
  "Feed version SHA1 identifier"
  feed_version_sha1: String!
  "Feed OnestopID"
  feed_onestop_id: String!
  "Feed version"
  feed_version: FeedVersion!
  "Stop times associated with this location"
  stop_times(limit: Int, where: StopTimeFilter): [FlexStopTime!]!
}

"""Record from a static GTFS [booking_rules.txt](https://gtfs.org/schedule/reference/#booking_rulestxt) file."""
type BookingRule {
  "Internal integer ID"
  id: Int!
  "GTFS booking_rules.booking_rule_id"
  booking_rule_id: String!
  "GTFS booking_rules.booking_type"
  booking_type: Int!
  "GTFS booking_rules.prior_notice_duration_min"
  prior_notice_duration_min: Int
  "GTFS booking_rules.prior_notice_duration_max"
  prior_notice_duration_max: Int
  "GTFS booking_rules.prior_notice_last_day"
  prior_notice_last_day: Int
  "GTFS booking_rules.prior_notice_last_time"
  prior_notice_last_time: Seconds
  "GTFS booking_rules.prior_notice_start_day"
  prior_notice_start_day: Int
  "GTFS booking_rules.prior_notice_start_time"
  prior_notice_start_time: Seconds
  "Prior notice service calendar"
  prior_notice_service: Calendar
  "GTFS booking_rules.message"
  message: String
  "GTFS booking_rules.pickup_message"
  pickup_message: String
  "GTFS booking_rules.drop_off_message"
  drop_off_message: String
  "GTFS booking_rules.phone_number"
  phone_number: String
  "GTFS booking_rules.info_url"
  info_url: Url
  "GTFS booking_rules.booking_url"
  booking_url: Url
  "Feed version SHA1 identifier"
  feed_version_sha1: String!
  "Feed OnestopID"
  feed_onestop_id: String!
  "Feed version"
  feed_version: FeedVersion!
}

"""Record from a static GTFS [location_groups.txt](https://gtfs.org/schedule/reference/#location_groupstxt) file."""
type LocationGroup {
  "Internal integer ID"
  id: Int!
  "GTFS location_groups.location_group_id"
  location_group_id: String!
  "GTFS location_groups.location_group_name"
  location_group_name: String
  "Feed version SHA1 identifier"
  feed_version_sha1: String!
  "Feed OnestopID"
  feed_onestop_id: String!
  "Feed version"
  feed_version: FeedVersion!
  "Stops associated with this location group"
  stops(limit: Int): [Stop!]!
  "Stop times associated with this location group"
  stop_times(limit: Int, where: StopTimeFilter): [FlexStopTime!]!
}

"""Record from a static GTFS [location_group_stops.txt](https://gtfs.org/schedule/reference/#location_group_stopstxt) file."""
type LocationGroupStop {
  "Internal integer ID"
  id: Int!
  "Location group"
  location_group: LocationGroup!
  "Stop"
  stop: Stop!
}

# Archived observed stop-times

"""Measurements of observed arrival times based on GTFS-RT data"""
type StopObservation {
  "GTFS-RT TripUpdate schedule relationship"
  schedule_relationship: String
  "GTFS-RT TripUpdate trip start date"
  trip_start_date: Date
  "GTFS-RT TripUpdate trip start time"
  trip_start_time: Seconds
  "GTFS static origin stop id"
  from_stop_id: String
  "GTFS static destination stop id"
  to_stop_id: String
  "Agency ID for route"
  agency_id: String
  "Route ID for trip"
  route_id: String
  "Trip ID"
  trip_id: String
  "Stop sequence for origin stop"
  stop_sequence: Int
  "Source data used to calculate this stop observation. Can be trip update or vehicle positions."
  source: String
  "GTFS static scheduled arrival time"
  scheduled_arrival_time: Seconds
  "GTFS static scheduled departure time"
  scheduled_departure_time: Seconds
  "GTFS-RT calculated arrival time"
  observed_arrival_time: Seconds
  "GTFS-RT calculated departure time"
  observed_departure_time: Seconds
}

# GTFS Support Entities

"""Additional metadata for a stop to reference an externally defined stop"""
type StopExternalReference {
  "Internal integer ID"
  id: Int!
  "Target stop's feed OnestopID"
  target_feed_onestop_id: String
  "Target stop's stop_id"
  target_stop_id: String
  "Is this reference active"
  inactive: Boolean
  "Resolved target stop, if matched and available"
  target_active_stop: Stop
}

"""Place associated with a stop"""
type StopPlace {
  "Best-matched state or province name"
  adm1_name: String
  "Best-matched state or province ISO code"
  adm1_iso: String
  "Best-matched country name"
  adm0_name: String
  "Best-mached country ISO code"
  adm0_iso: String
}

"""Place associated with an agency"""
type AgencyPlace {
  "Best-matched city name"
  city_name: String
  "Best-matched state or province name"
  adm1_name: String
  "Best-matched state or province ISO code"
  adm1_iso: String
  "Best-matched country name"
  adm0_name: String
  "Best-mached country ISO code"
  adm0_iso: String
  "Relative weight of this place association"
  rank: Float
}

"""Place name and associated operators"""
type Place {
  "Country name"
  adm0_name: String
  "State or province name"
  adm1_name: String
  "City name"
  city_name: String
  "Number of associated operators"
  count: Int!
  "Operators associated with this place"
  operators: [Operator!]
}

"""RelativeDate specifies a calendar date relative to the current local time"""
enum RelativeDate {
  "The current date"
  TODAY
  "Next Monday, or today if it is currently Monday"
  MONDAY
  "Next Tuesday, or today if it is currently Tuesday"
  TUESDAY
  "Next Wednesday, or today if it is currently Wednesday"
  WEDNESDAY
  "Next Thursday, or today if it is currently Thursday"
  THURSDAY
  "Next Friday, or today if it is currently Friday"
  FRIDAY
  "Next Saturday, or today if it is currently Saturday"
  SATURDAY
  "Next Sunday, or today if it is currently Sunday"
  SUNDAY
  "Next Monday, not inclusive of today"
  NEXT_MONDAY
  "Next Tuesday, not inclusive of today"
  NEXT_TUESDAY
  "Next Wednesday, not inclusive of today"
  NEXT_WEDNESDAY
  "Next Thursday, not inclusive of today"
  NEXT_THURSDAY
  "Next Friday, not inclusive of today"
  NEXT_FRIDAY
  "Next Saturday, not inclusive of today"
  NEXT_SATURDAY
  "Next Sunday, not inclusive of today"
  NEXT_SUNDAY
}

"""PlaceAggregationLevel controls the level of aggregation in a places query"""
enum PlaceAggregationLevel {
  "Aggregate places based on country"
  ADM0
  "Aggregate places based on country and state/province"
  ADM0_ADM1
  "Aggregate places based on country, state/province, and city"
  ADM0_ADM1_CITY
  "Aggregate places based on country and city"
  ADM0_CITY
  "Aggregate places based on state/province and city"
  ADM1_CITY
  "Aggregate places based on city"
  CITY
}


"""RouteStops describe associations between stops, routes, and agencies."""
type RouteStop {
  "Internal integer ID"
  id: Int!
  "Internal integer ID for this associated stop"
  stop_id: Int!
  "Internal integer ID for this associated route"
  route_id: Int!
  "Internal integer ID for this associated agency"
  agency_id: Int!
  "Associated route"
  route: Route!
  "Associated stop"
  stop: Stop!
  "Associated agency"
  agency: Agency!
}

"""RouteStopPattern describes a unique pattern of stops for a route"""
type RouteStopPattern {
  "An identifier for this stop pattern; an integer scoped to this particular feed version"
  stop_pattern_id: Int!
  "Direction ID of the trip"
  direction_id: Int!
  "Count of trips for this stop pattern"
  count: Int!
  "Trips for this stop pattern"
  trips(limit: Int): [Trip!]
}

"""Representative route geometries"""
type RouteGeometry {
  "If true, the source GTFS feed provides no shapes. This route geometry is based on straight lines between stop points."
  generated: Boolean!
  "A single LineString of this most common shape"
  geometry: LineString
  "MultiLineString ensemble of the most common shapes for each direction"
  combined_geometry: Geometry
  "Length (in meters) of the simple geometry"
  length: Float
  "Maximum point-to-point distance in the geometry"
  max_segment_length: Float
  "First point max distance"
  first_point_max_distance: Float
}

"""Calculated route headways"""
type RouteHeadway {
  "Stop used for the headway calculation"
  stop: Stop!
  "Day of week category; 1=Weekday, 6=Saturday, 7=Sunday"
  dow_category: Int
  "Trip direction"
  direction_id: Int
  "Typical number of seconds between departing trips at this stop in this direction on this day of the week"
  headway_secs: Int
  "Date used for the headway calculation"
  service_date: Date
  "Number of departures on this stop, day, and direction"
  stop_trip_count: Int
  "Actual departure times on this stop, day, and direction"
  departures: [Seconds!]
}

"""Normalized route segment patterns"""
type SegmentPattern {
  "Internal integer ID"
  id: Int!
  "Route for this segment pattern"
  route: Route!
  "Stop pattern for this segment pattern"
  stop_pattern_id: Int!
  "Segment geometry for this pattern"
  segment: Segment!
}

"""Normalized route segments"""
type Segment {
  "Internal integer ID"
  id: Int!
  "OSM Way ID, if any, associated with this segment"
  way_id: Int!
  "Geometry for this segment"
  geometry: LineString!
  "Routes and stop patterns associated with this segment"
  segment_patterns: [SegmentPattern!]
}

"""MTC GTFS+ Extension: route_attributes.txt"""
type RouteAttribute {
  "Route category"
  category: Int
  "Route subcategory"
  subcategory: Int
  "Route running way category"
  running_way: Int
}

# Census entities

type CensusDataset {
  "Internal integer ID"
  id: Int!
  "Dataset name, e.g. acsdt5y2022"
  name: String!
  "Dataset description"
  description: String
  "Dataset url"
  url: Url
  "Minimum year of data in this dataset"
  year_min: Int
  "Maximum year of data in this dataset"
  year_max: Int
  # Sources in this dataset
  sources(limit: Int, where: CensusSourceFilter): [CensusSource!]
  # Census geographies in this dataset
  geographies(limit: Int, where: CensusDatasetGeographyFilter): [CensusGeography!]
  # Census tables in this dataset
  tables(limit: Int, where: CensusTableFilter): [CensusTable!]
  layers: [CensusLayer!]
}

type CensusSource {
  "Internal integer ID"
  id: Int!
  "Source name, e.g. tl_2024_01_tract.zip"
  name: String!
  "Source description"
  description: String
  "Source url"
  url: Url!
  "Source checksum"
  sha1: String!
  # Census geographies in this layer
  geographies(limit: Int, where: CensusSourceGeographyFilter): [CensusGeography!]
  # Census tables in this source
  tables(limit: Int): [CensusTable!]
  # Layers
  layers: [CensusLayer!]
}

""""Census layer metadata"""
type CensusLayer {
  "Internal integer ID"
  id: Int!
  "Layer name, e.g. tl_2024_01_tract"
  name: String!
  "Layer description"
  description: String
  # Census geographies in this layer
  geographies(limit: Int, where: CensusSourceGeographyFilter): [CensusGeography!]
}

"""Census geography data"""
type CensusGeography {
  "Internal integer ID"
  id: Int!
  "Dataset name, e.g. acsdt5y2022"
  dataset_name: String!
  "Source name, e.g. tl_2024_01_tract.zip"
  source_name: String!
  "Census geography source layer"
  layer_name: String!
  "Census geography GEOID"
  geoid: String
  "Census geography name"
  name: String
  "Geometry total area, in square meters"
  geometry_area: Float
  "Land area, in square meters"
  aland: Float
  "Water area, in square meters"
  awater: Float
  "State or province name"
  adm1_name: String
  "State or province ISO code"
  adm1_iso: String
  "Country name"
  adm0_name: String
  "Country ISO code"
  adm0_iso: String
  "Census geography polygon"
  geometry: MultiPolygon
  "Intersection area with a given geometry, in square meters"
  intersection_area: Float
  intersection_geometry: Geometry
  "Census tables containing data for this geography"
  values(table_names: [String!]!, dataset: String, limit: Int): [CensusValue]!
  "Layer"
  layer: CensusLayer
  "Source"
  source: CensusSource
}

"""Census values"""
type CensusValue {
  "Dataset name, e.g. acsdt5y2022"
  dataset_name: String!
  "Source name, e.g. tl_2024_01_tract.zip"
  source_name: String!
  "Source table"
  table: CensusTable!
  "Column:Value for this table"
  values: Map!
  "GEOID of associated census geography"
  geoid: String!
}

"""Census table metadata"""
type CensusTable {
  "Internal integer ID"
  id: Int!
  "Census table name"
  table_name: String!
  "Census table title"
  table_title: String!
  "Census table group"
  table_group: String
  "Additional details, e.g. population universe"
  table_details: String
  "Individial field definitions for this table"
  fields: [CensusField!]!
}

type CensusField {
  "Internal integer ID"
  id: Int!
  "Census field name"
  field_name: String!
  "Census field title"
  field_title: String!
  "Census field column order"
  column_order: Float
}

# Realtime updates

"""GTFS-RT TripUpdate and StopTimeEvent schedule relationship.

This enum combines possible values from both schedule relationship types, plus an additional STATIC value.

See:
- [ScheduleRelationship](https://gtfs.org/realtime/reference/#enum-schedulerelationship)
- [ScheduleRelationship](https://gtfs.org/realtime/reference/#enum-schedulerelationship-1)
"""
enum ScheduleRelationship {
  SCHEDULED
  ADDED
  UNSCHEDULED
  CANCELED
  STATIC
  SKIPPED
  NO_DATA
  REPLACEMENT
  DUPLICATED
  DELETED
}

"""
StopTimeEvent combines scheduled arrival/departure data with data sourced from GTFS-RT

Each scheduled StopTime will try to be matched with a relevant GTFS-RT TripUpdate and StopTimeUpdate.
If the StopTime has a matching TripUpdate (based on trip_id) and StopTimeUpdate (stop_sequence and/or stop_id), the estimated times will be used directly.
If a TripUpdate is matched, but no StopTimeUpdate, the last available delay value in the trip will be applied to later StopTimes in that trip.
If the Trip is ADDED and does not match a static schedule StopTime, the scheduled times will be absent.

See:
- https://gtfs.org/realtime/reference/#message-tripupdate
- https://gtfs.org/realtime/reference/#message-stoptimeupdate
- https://gtfs.org/realtime/reference/#message-stoptimeevent
"""
type StopTimeEvent {
  "Local time for stop"
  stop_timezone: String!
  "Estimated time in UTC"
  estimated_utc: Time
  "Estimated time in Unix epoch seconds"
  estimated_unix: Int
  "Estimated time in the local time zone"
  estimated_local: Time
  """
  Estimated schedule delay, in seconds, based on either a timestamp or overall trip delay.

  This value can be set directly from a matching GTFS-RT StopTimeUpdate timestamp or delay value or set via an estimated overall trip delay. The value is capped at +/- 86,400 seconds (24 hours). Values larger than that are are likely erroneous and will be set to null.
  """
  estimated_delay: Int
  "Estimated time in local time HH:MM:SS"
  estimated: Seconds
  "Scheduled time in UTC"
  scheduled_utc: Time
  "Scheduled time in Unix epoch seconds"
  scheduled_unix: Int
  "Sceduled time in the local time zone"
  scheduled_local: Time
  "Scheduled time local time HH:MM:SS"
  scheduled: Seconds
  "Estimated time in UTC, source directly from matching GTFS-RT StopTimeUpdate. See https://gtfs.org/realtime/reference/#message-stoptimeevent"
  time_utc: Time
  "Estimated time in Unix epoch seconds, source directly from matching GTFS-RT StopTimeUpdate. See https://gtfs.org/realtime/reference/#message-stoptimeevent"
  time_unix: Int
  "Estimated schedule delay, in seconds. This value is set when there is a directly matching GTFS-RT StopTimeUpdate for this stop and passed through as-is. See GTFS Realtime documentation. See https://gtfs.org/realtime/reference/#message-stoptimeevent"
  delay: Int
  "Estimation uncertainty. This value is set when there is a directly matching GTFS-RT StopTimeUpdate for this stop and passed through as-is. See https://gtfs.org/realtime/reference/#message-stoptimeevent"
  uncertainty: Int
}

"""[Vehicle Position](https://gtfs.org/reference/realtime/v2/#message-vehicleposition) message provided by a source GTFS Realtime feed."""
type VehiclePosition {
  "GTFS-RT VehiclePosition vehicle. See https://gtfs.org/realtime/reference/#message-vehicledescriptor"
  vehicle: RTVehicleDescriptor
  "GTFS-RT VehiclePosition current vehicle position"
  position: Point
  "GTFS-RT VehiclePosition current stop sequence in trip"
  current_stop_sequence: Int
  "GTFS-RT VehiclePosition current stop in trip"
  stop_id: Stop
  "GTFS-RT VehiclePosition current status string"
  current_status: String
  "GTFS-RT VehiclePosition timestamp"
  timestamp: Time
  "GTFS-RT VehiclePosition congestion level estimate"
  congestion_level: String
}

"""[Alert](https://gtfs.org/reference/realtime/v2/#message-alert) message, also called a service alert, provided by a source GTFS Realtime feed."""
type Alert {
  "GTFS-RT Alert active alert period. See https://gtfs.org/realtime/reference/#message-timerange"
  active_period: [RTTimeRange!]
  "GTFS-RT Alert [cause](https://gtfs.org/realtime/reference/#enum-cause)"
  cause: String
  "GTFS-RT Alert [effect](https://gtfs.org/realtime/reference/#enum-effect)"
  effect: String
  "GTFS-RT Alert header text"
  header_text: [RTTranslation!]!
  "GTFS-RT Alert description text"
  description_text: [RTTranslation!]!
  "GTFS-RT Alert TTS header text"
  tts_header_text: [RTTranslation!]
  "GTFS-RT Alert TTS description text"
  tts_description_text: [RTTranslation!]
  "GTFS-RT Alert uRL for more information"
  url: [RTTranslation!]
  "GTFS-RT Alert severity level"
  severity_level: String
}

"""See https://gtfs.org/reference/realtime/v2/#message-timerange"""
type RTTimeRange {
  "GTFS-RT TimeRange start time, in Unix epoch seconds"
  start: Int
  "GTFS-RT TimeRange end time, in Unix epoch seconds"
  end: Int
}

"""See https://gtfs.org/reference/realtime/v2/#message-vehicledescriptor"""
type RTVehicleDescriptor {
  "GTFS-RT VehicleDescriptor vehicle ID"
  id: String
  "GTFS-RT VehicleDescriptor vehicle label"
  label: String
  "GTFS-RT VehicleDescriptor vehicle license plate"
  license_plate: String
}

"""See https://gtfs.org/reference/realtime/v2/#message-tripdescriptor"""
type RTTripDescriptor {
  "GTFS-RT TripDescriptor trip ID"
  trip_id: String
  "GTFS-RT TripDescriptor route ID"
  route_id: String
  "GTFS-RT TripDescriptor trip direction"
  direction_id: Int
  "GTFS-RT TripDescriptor trip start time, in local time HH:MM:SS"
  start_time: Seconds
  "GTFS-RT TripDescriptor trip start time, in local date"
  start_date: Date
  "GTFS-RT TripDescriptor schedule relationship. See https://gtfs.org/realtime/reference/#enum-schedulerelationship-1"
  schedule_relationship: String
}

"""See https://gtfs.org/reference/realtime/v2/#message-translatedstring"""
type RTTranslation {
  "GTFS-RT TranslatedString translated text"
  text: String!
  "GTFS-RT TranslatedString language for this translation"
  language: String
}


# Analysis tools

"""Geographic buffer around a route"""
type RouteStopBuffer {
  "Geographic buffer around route, based on requested meters"
  stop_buffer: Geometry
  "Matching set of points (e.g. stops) found inside buffer"
  stop_points: Geometry
  "Convex hull of matching points"
  stop_convexhull: Polygon
}

# Validation tools

"""Validation report for GTFS static and/or GTFS-RT data"""
type ValidationReport {
  "Internal integer ID"
  id: Int!
  "Time the report was generated, in UTC"
  reported_at: Time
  "Time the reported was generated, in feed local time"
  reported_at_local: Time
  "Time the report was generated, local timezone"
  reported_at_local_timezone: String
  "Validation completed successfully"
  success: Boolean!
  "Exception log if feed failed to validate"
  failure_reason: String
  "The report includes GTFS static data"
  includes_static: Boolean
  "The report includes GTFS-RT data"
  includes_rt: Boolean
  "Name of validator used"
  validator: String
  "Version of validator used"
  validator_version: String
  "Validation errors, grouped by filename, if present"
  errors(limit: Int): [ValidationReportErrorGroup!]! @goField(forceResolver: true)
  "Validation warnings, grouped by filename, if present"
  warnings(limit: Int): [ValidationReportErrorGroup!]! @goField(forceResolver: true)
  "Details about the validated feed"
  details: ValidationReportDetails @goField(forceResolver: true)
}

"""Details about the validated feed, including selected entities, metadata of contained files, calendar extent, etc."""
type ValidationReportDetails {
  "SHA1 hash of the validated feed"
  sha1: String!
  "Calculated earliest calendar date in service schedule"
  earliest_calendar_date: Date
  "Calculated latest calendar date in service schedule"
  latest_calendar_date: Date
  "Details for each file contained in the feed"
  files: [FeedVersionFileInfo!]!
  "Calculated service levels for feed"
  service_levels(limit: Int, route_id: String): [FeedVersionServiceLevel!]!
  "Selected agencies contained in feed"
  agencies(limit: Int): [Agency!]!
  "Selected routes contained in feed"
  routes(limit: Int): [Route!]!
  "Selected stops contained in feed"
  stops(limit: Int): [Stop!]!
  "Feed info data contained in feed"
  feed_infos(limit: Int): [FeedInfo!]!
  "Detailed information about GTFS-RT sources used in validation"
  realtime: [ValidationRealtimeResult!]
}

"""Source URL and JSON representation of GTFS-RT data used for validation"""
type ValidationRealtimeResult {
  "Source URL"
  url: String!
  "JSON representation of GTFS-RT data"
  json: Map!
}

"""Validation errors and warnings for a particular file or RT source"""
type ValidationReportErrorGroup {
  "Filename for error group"
  filename: String!
  "Error type"
  error_type: String!
  "Error code (for GTFS-RT)"
  error_code: String!
  "Key for this error group"
  group_key: String!
  "Affected entity field for this error group"
  field: String!
  "Number of affected entities for this error group"
  count: Int!
  "Examples of this error"
  errors(limit: Int): [ValidationReportError!]! @goField(forceResolver: true)
}

"""An individual validation error or warning."""
type ValidationReportError {
  "Source filename"
  filename: String!
  "Error type"
  error_type: String!
  "Error code (for GTFS-RT)"
  error_code: String!
  "Key for this error group"
  group_key: String!
  "Affected entity ID"
  entity_id: String!
  "Affected entity field"
  field: String!
  "Affected entity line number (for static)"
  line: Int!
  "Value of affected field"
  value: String!
  "Error message describing problem"
  message: String!
  "Entity geometry, if available"
  geometry: Geometry
  "JSON representation of entity, if available"
  entity_json: Map!
}

# Query filters

"""Search options for operators"""
input OperatorFilter {
  "Merge multiple agency-operator associations into single operator results"
  merged: Boolean
  "Search for operators with this OnestopID"
  onestop_id: String
  "Search for operators with this feed OnestopID"
  feed_onestop_id: String
  "Search for operators with agencies having this GTFS agency_id"
  agency_id: String
  "Full-text search string"
  search: String
  "Search for operators with this set of tag key/values"
  tags: Tags
  "Search for operators by city name (provided by Natural Earth)"
  city_name: String
  "Search for operators by country name (provided by Natural Earth)"
  adm0_name: String
  "Search for operators by state/province/division name (provided by Natural Earth)"
  adm1_name: String
  "Search for operators by country 2 letter ISO 3166 code (provided by Natural Earth)"
  adm0_iso: String
  "Search for operators by state/province/division ISO 3166-2 code (provided by Natural Earth)"
  adm1_iso: String
  "Search for operators with these license details"
  license: LicenseFilter
  "Search for operators within this bounding box"
  bbox: BoundingBox
  "Search for operators within this geographic polygon"
  within: Polygon
  "Search for operators within specified radius of a point"
  near: PointRadius
}

"""Search options for validation reports"""
input ValidationReportFilter {
  "Search for validation reports with the following integer IDs"
  report_ids: [Int!]
  "Search for successful validation reports"
  success: Boolean
  "Search for validation reports generated by the specified validator"
  validator: String
  "Search for validation reports generated using the specified validator version"
  validator_version: String
  "Search for validation reports that include/exclude GTFS-RT data"
  includes_rt: Boolean
  "Search for validation reports that include/exclude GTFS static data"
  includes_static: Boolean
}


"""Search options for feed versions"""
input FeedVersionFilter {
  "Restrict to specific ids"
  ids: [Int!]
  "Search for feed versions with the specified import status"
  import_status: ImportStatus
  "Search for feed versions with this feed OnestopID"
  feed_onestop_id: String
  "Search for feed versions with this SHA1 hash"
  sha1: String
  "Search for feed versions with this file identifier"
  file: String
  "Search for feed versions with the specified feed integer IDs"
  feed_ids: [Int!]
  "Search for feed versions that cover the specified date range"
  covers: ServiceCoversFilter
  "Search for feed versions within this bounding box"
  bbox: BoundingBox
  "Search for feed versions within this geographic polygon"
  within: Polygon
  "Search for feed versions within specified radius of a point"
  near: PointRadius
  "Search for stops with these license details"
  license: LicenseFilter
}

"""Search options for locations"""
input LocationFilter {
  "Restrict to specific ids"
  ids: [Int!]
  "Search for locations with this location_id"
  location_id: String
}

input BookingRuleFilter {
  "Restrict to specific ids"
  ids: [Int!]
  "Search for booking rules with this booking_rule_id"
  booking_rule_id: String
}

"""Search options for location groups"""
input LocationGroupFilter {
  "Restrict to specific ids"
  ids: [Int!]
  "Search for location groups with this location_group_id"
  location_group_id: String
}

"""Import status for a feed version"""
enum ImportStatus {
  "Imported successfully"
  SUCCESS
  "Did not import successfully"
  ERROR
  "Import is currently in progress"
  IN_PROGRESS
}

"""Permissable and impermissable actions for a given license use"""
enum LicenseValue {
  "Use is allowed"
  YES
  "Use is not allowed"
  NO
  "Use is YES or UNKNOWN"
  EXCLUDE_NO
  "Use is not known"
  UNKNOWN
}

"""Search options for feeds"""
input FeedFilter {
  "Search for feed with a specific OnestopID"
  onestop_id: String
  "Search for feeds of certain data types"
  spec: [FeedSpecTypes!]
  "Search for feeds with or without a fetch error"
  fetch_error: Boolean
  "Search for feeds by their import status"
  import_status: ImportStatus
  "Full text search"
  search: String
  "Search for feeds with a tag"
  tags: Tags
  "Search for feeds by their source URLs"
  source_url: FeedSourceUrl
  "Search for feeds with these license details"
  license: LicenseFilter
  "Search for feeds within this bounding box"
  bbox: BoundingBox
  "Search for feeds within this geographic polygon"
  within: Polygon
  "Search for feeds within specified radius of a point"
  near: PointRadius
}

"""Search options for feed fetches"""
input FeedFetchFilter {
  "Search for feed fetches with success (true) or failure (false) or unspecified (null)"
  success: Boolean
}

"""Search options for searching by source URL"""
input FeedSourceUrl {
  "URL"
  url: String
  "URL type"
  type: FeedSourceUrlTypes
  "Case sensitive search (true) or case insensitive search (false or null)"
  case_sensitive: Boolean
}

"""Feed source URL types"""
enum FeedSourceUrlTypes {
  "URL to the current static GTFS"
  static_current
  "URL to a previously used static GTFS"
  static_historic
  "URL to a planned future static GTFS"
  static_planned
  "URL to a proposed future static GTFS"
  static_hypothetical
  "URL to GTFS-RT vehicle positions"
  realtime_vehicle_positions
  "URL to GTFS-RT trip updates"
  realtime_trip_updates
  "URL to GTFS-RT alerts"
  realtime_alerts
  "URL to a GBFS service auto-discovery endpoint"
  gbfs_auto_discovery
  "URL to a MDS data set"
  mds_provider
}

"""Type of data contained in a source feed"""
enum FeedSpecTypes {
  "Static data"
  GTFS
  "GTFS-RT data"
  GTFS_RT
  "GBFS data"
  GBFS
  "MDS data"
  MDS
}

"""Search options for agencies"""
input AgencyFilter {
  "Search for agencies with this operator OnestopID"
  onestop_id: String
  "Search for agencies with this feed version SHA1 hash"
  feed_version_sha1: String
  "Search for agencies with this feed OnestopID"
  feed_onestop_id: String
  "Search for agencies with this GTFS agency_id"
  agency_id: String
  "Search for records with this GTFS agency_name"
  agency_name: String
  "Full text search"
  search: String
  "Search for agencies by city name (provided by Natural Earth)"
  city_name: String
  "Search for agencies by country name (provided by Natural Earth)"
  adm0_name: String
  "Search for agencies by state/province/division name (provided by Natural Earth)"
  adm1_name: String
  "Search for agencies by country 2 letter ISO 3166 code (provided by Natural Earth)"
  adm0_iso: String
  "Search for agencies by state/province/division ISO 3166-2 code (provided by Natural Earth)"
  adm1_iso: String
  "Search for agencies with these license details"
  license: LicenseFilter
  "Location"
  location: AgencyLocationFilter
  "Backwards compat: Search for agencies within this bounding box"
  bbox: BoundingBox
  "Backwards compat: Search for agencies within this geographic polygon"
  within: Polygon
  "Backwards compat: Search for agencies within specified radius of a point"
  near: PointRadius
}

input AgencyLocationFilter {
  "Search for agencies within this bounding box"
  bbox: BoundingBox
  "Search for agencies within this geographic polygon"
  polygon: Polygon
  "Search for agencies within specified radius of a point"
  near: PointRadius
  "Focus search on this point; results will be sorted by distance"
  focus: FocusPoint
}

"""Search options for routes"""
input RouteFilter {
  "Search for routes with this OnestopID"
  onestop_id: String
  "Search for routes with these OnestopIDs"
  onestop_ids: [String!]
  "Include previously used OnestopIDs that match the same (feed,route_id)"
  allow_previous_onestop_ids: Boolean
  "Search for routes with this feed version SHA1 hash"
  feed_version_sha1: String
  "Search for routes with this feed OnestopID"
  feed_onestop_id: String
  "Search for routes with this GTFS route_id"
  route_id: String
  "Search for routes with this GTFS route_type"
  route_type: Int
  "Search for routes with any of these GTFS route_types"
  route_types: [Int!]
  "Search for routes with 1 or more trips (true) or 0 or more trips (false or null)"
  serviced: Boolean
  "Full text search"
  search: String
  "Search for routes operated by operators with this OnestopID"
  operator_onestop_id: String
  "Search for routes with these license details"
  license: LicenseFilter
  "Search for routes with these agency integer IDs. Deprecated."
  agency_ids: [Int!]
  "Location"
  location: RouteLocationFilter
  "Backwards compat:Search for routes within this bounding box"
  bbox: BoundingBox
  "Backwards compat: Search for routes within this geographic polygon"
  within: Polygon
  "Backwards compat: Search for routes within specified radius of a point"
  near: PointRadius

}

input RouteLocationFilter {
  "Search for routes within this bounding box"
  bbox: BoundingBox
  "Search for routes within this geographic polygon"
  polygon: Polygon
  "Search for routes within specified radius of a point"
  near: PointRadius
  "Focus search on this point; results will be sorted by distance"
  focus: FocusPoint
}

input Feature {
  id: String
  geometry: Geometry
  properties: Map
  type: String
}

input StopLocationFilter {
  "Search for stops within this bounding box"
  bbox: BoundingBox
  "Search for stops within this geographic polygon"
  polygon: Polygon
  "Search within these enclosing features, and return the matching feature ids"
  features: [Feature]
  "Search for stops within specified radius of a point"
  near: PointRadius
  "Search within these geography ids"
  geography_ids: [Int]
  "Focus search on this point; results will be sorted by distance"
  focus: FocusPoint  
}

"""Search options for stops"""
input StopFilter {
  "Search for stops with this OnestopID"
  onestop_id: String
  "Search for stops with these OnestopIDs"
  onestop_ids: [String!]
  "Include previous used OnestopIDs that match the same (feed,stop_id)"
  allow_previous_onestop_ids: Boolean
  "Search for stops with this feed version SHA1 hash"
  feed_version_sha1: String
  "Search for stops with this feed OnestopID"
  feed_onestop_id: String
  "Search for stops with this GTFS stop_id"
  stop_id: String
  "Search for stops with this GTFS stop_code"
  stop_code: String
  "Search for stops with this GTFS location_type"
  location_type: Int
  "Search for stops with 1 or more trips (true) or 0 or more trips (false or null)"
  serviced: Boolean
  "Full text search"
  search: String
  "Search for stops with these license details"
  license: LicenseFilter
  "Search for stops with service by routes or operators with these OnestopIDs"
  served_by_onestop_ids: [String!]
  "Search for stopswith service by routes with the specified GTFS route_type"
  served_by_route_type: Int
  "Search for stopswith service by routes with any of the specified GTFS route_types"
  served_by_route_types: [Int!]
  "Search for stops with these agency integer IDs. Deprecated."
  agency_ids: [Int!]
  "Search geographically"
  location: StopLocationFilter
  "Backwards compat: Search for stops within this bounding box"
  bbox: BoundingBox
  "Backwards compat: Search for stops within this geographic polygon"
  within: Polygon
  "Backwards compat: Search for stops within specified radius of a point"
  near: PointRadius
}

"""Search options for stop times, optionally on a given date"""
input StopTimeFilter {
  "Search for trips scheduled on the specified calendar date"
  date: Date
  "Search for trips scheduled on the specified relative date"
  relative_date: RelativeDate
  "Search for trips scheduled on the specified GTFS calendar service date"
  service_date: Date
  "Use the feed version fallback week for dates outside the normal service window for that feed version"
  use_service_window: Boolean
  "Search for stop times with departure times later than the specified time, in seconds since midnight"
  start_time: Int
  "Search for stop times with arrival times before the specified time, in seconds since midnight"
  end_time: Int
  "Search for stop times with departure times later than the specified time, in local time HH:MM:SS"
  start: Seconds
  "Search for stop times with arrival times before the specified time, in local time HH:MM:SS"
  end: Seconds
  "Search for stop times with departures within the specified number of seconds (in local time)"
  next: Int
  "Search for stop times with service by routes with the specified route OnestopIDs"
  route_onestop_ids: [String!] # keep?
  "Include previously used route OnestopIDs that match the same (feed,route_id)"
  allow_previous_route_onestop_ids: Boolean
  "Exclude the first stop_time in a trip"
  exclude_first: Boolean
  "Exclude the last stop_time in a trip"
  exclude_last: Boolean
}

"""Search options for stop times for a trip with no date specified"""
input TripStopTimeFilter {
  "Search for stop times with departure times later than the specified time, in local time HH:MM:SS"
  start: Seconds
  "Search for stop times with arrival times before the specified time, in local time HH:MM:SS"
  end: Seconds
}

"""Search options for stop observations"""
input StopObservationFilter {
  "Search for stop observations derived from the specified source"
  source: String!
  "Search for stop observations associated with this feed version integer ID"
  feed_version_id: Int!
  "Search for stop observations made on this trip start date"
  trip_start_date: Date!
}

"""Search options for pathways"""
input PathwayFilter {
  "Search for pathways with this GTFS pathway_mode"
  pathway_mode: Int
}

"""Search options for trips"""
input TripFilter {
  "Search for trips scheduled on the specified GTFS calendar service date"
  service_date: Date
  "Search for trips scheduled on the specified relative date"
  relative_date: RelativeDate
  "Use the feed version fallback week for dates outside the normal service window for that feed version"
  use_service_window: Boolean
  "Search for trips with this GTFS trip_id"
  trip_id: String
  "Search for trips with this stop pattern ID"
  stop_pattern_id: Int
  "Search for trips with these license details"
  license: LicenseFilter
  "Search for trips associated with these route integer IDs. Deprecated."
  route_ids: [Int!]
  "Search for trips associated with these route OnestopIDs"
  route_onestop_ids: [String!] # keep?
  "Search for trips with this feed version SHA1 hash"
  feed_version_sha1: String
  "Search for trips with this feed OnestopID"
  feed_onestop_id: String
}

"""Search options for census datasets"""
input CensusDatasetFilter {
  "Search for datasets with this name"
  name: String
  "Search for datasets matching this string"
  search: String
}

"""Search options for census geographies

Note: please see the CensusDatasetGeographyLocationFilter documentation for details on how spatial searches may return duplicate geographies based on multiple intersections.
"""
input CensusGeographyFilter {
  dataset: String
  layer: String
  radius: Float
  search: String
}

"""Search options for census geographies within a specific dataset

Note: please see the CensusDatasetGeographyLocationFilter documentation for details on how spatial searches may return duplicate geographies based on multiple intersections.
"""
input CensusDatasetGeographyFilter {
  "Geographies with these integer IDs"
  ids: [Int!]
  "Search within this dataset"
  dataset: String
  "Search within this layer"
  layer: String
  "Search for geographies matching this string"
  search: String
  "Location search"
  location: CensusDatasetGeographyLocationFilter
}

"""Search options for census geography sources

Note: please see the CensusDatasetGeographyLocationFilter documentation for details on how spatial searches may return duplicate geographies based on multiple intersections.
"""
input CensusSourceGeographyFilter {
  "Geographies with these integer IDs"
  ids: [Int!]
  "Search for geographies matching this string"
  search: String
  "Location search"
  location: CensusDatasetGeographyLocationFilter
}


"""Search options for census geographies

Note: when using spatial searches (radius, stop_buffer, etc.), individual census geographies may appear multiple times in the result set, each representing a different intersection with the search area. For example:
- Two stops with small radius buffers in the same census tract will return that tract twice, once for each buffer intersection
- A complex polygon search that touches multiple disconnected areas of the same geography will return separate entries for each intersection
- Each duplicate entry will have different ` + "`" + `intersection_area` + "`" + ` and ` + "`" + `intersection_geometry` + "`" + ` values representing the specific overlap

Clients should aggregate or de-duplicate results as needed based on the ` + "`" + `geoid` + "`" + ` field if a single entry per geography is desired.
"""
input CensusDatasetGeographyLocationFilter {
  "Search within this bounding box"
  bbox: BoundingBox
  "Search within this geographic polygon"
  within: Polygon
  "Search within specified radius of a point"
  near: PointRadius
  "Focus search on this point; results will be sorted by distance"
  focus: FocusPoint  
  "Search based on a buffer around these stop ids"
  stop_buffer: StopBuffer
}

"""Search options for census geographies based on stop IDs"""
input StopBuffer {
  "Search for geographies with these stop IDs"
  stop_ids: [Int!]
  "Stop ID search radius, in meters"
  radius: Float
}

input CensusTableFilter {
  search: String
}

"""Search options for census values"""
input CensusValueFilter {
  "Filter by dataset name"
  dataset: String
  "Filter by table name"
  table: String
  "Filter by exact geoid"
  geoid: String
  "Filter by geoid prefix (e.g. 'ntd:00001' to find all values for NTD agency 00001)"
  geoid_prefix: String
}

input CensusSourceFilter {
  name: String
  search: String
}

"""Search options for route segments"""
input SegmentFilter {
  "Search for segments associated with this layer name"
  layer: String
}

"""Search options for route segment patterns"""
input SegmentPatternFilter {
  "Search for segments patterns associated with this layer name"
  layer: String
}

"""Search for entities with these license requirements. See feed license documentation."""
input LicenseFilter {
  "Search for entities with this Share Alike license restriction"
  share_alike_optional: LicenseValue
  "Search for entities with this Create Derived Product license restriction"
  create_derived_product: LicenseValue
  "Search for entities with this Commercial Use Allowed restriction"
  commercial_use_allowed: LicenseValue
  "Search for entities with this Use Without Attribution restriction"
  use_without_attribution: LicenseValue
  "Search for entities with this Redistribution Allowed restriction"
  redistribution_allowed: LicenseValue
}


"""Search options for feed version service level summaries"""
input FeedVersionServiceLevelFilter {
  "Search for service level summaries starting on or after this date"
  start_date: Date
  "Search for service level summaries ending on or before this date"
  end_date: Date
}

"""Search options for feed version date range coverage"""
input ServiceCoversFilter {
  "Search for feed versions fetched after this time"
  fetched_after: Time
  "Search for feed versions fetched before this time"
  fetched_before: Time
  "Search using only feed_info.txt values"
  feed_start_date: Date
  "Search using only feed_info.txt values"
  feed_end_date: Date
  "Search using feed_info.txt values or calendar maximum service extent"
  start_date: Date
  "Search using feed_info.txt values or calendar maximum service extent"
  end_date: Date
  "Search using calendar maximum service extent"
  earliest_calendar_date: Date
  "Search using calendar maximum service extent"
  latest_calendar_date: Date
}

"""Search options for agency associated places"""
input AgencyPlaceFilter {
  "Search for associations with at least this rank value"
  min_rank: Float
}

"""Search options for associated places"""
input PlaceFilter {
  "Search for place associations with at least this rank value"
  min_rank: Float
  "Search for place associations by country name (provided by Natural Earth)"
  adm0_name: String
  "Search for place associations by state/province/division name (provided by Natural Earth)"
  adm1_name: String
  "Search for place associations by city name (provided by Natural Earth)"
  city_name: String
}

"""Search options for calendar dates"""
input CalendarDateFilter {
  "Search for calendar date exceptions on this date"
  date: Date
  "Search for calendar date exceptions with this GTFS exception_type"
  exception_type: Int
}

"""Search for entities within specified radius of a point"""
input PointRadius {
  "Latitude"
  lat: Float!
  "Longitude"
  lon: Float!
  "Radius around specified point"
  radius: Float!
}

input FocusPoint {
  "Latitude"
  lat: Float!
  "Longitude"
  lon: Float!
}

"""Search for entities within a specified bounding box"""
input BoundingBox {
  "Minimum longitude"
  min_lon: Float!
  "Minimum latitude"
  min_lat: Float!
  "Maximum longitude"
  max_lon: Float!
  "Maximum latitude"
  max_lat: Float!
}

# entity mutations

"""Result of a feed fetch operation"""
type FeedVersionFetchResult {
  "Details of fetched feed version, if successful"
  feed_version: FeedVersion
  "Exception log if fetch failed"
  fetch_error: String
  "Set if the fetched feed version is already present in the database with the same directory contents"
  found_sha1: Boolean!
  "Set if the fetched feed version is already present in the database with the same SHA1 hash"
  found_dir_sha1: Boolean!
}

"""Result of feed version import operation"""
type FeedVersionImportResult {
  "Did the import succeed"
  success: Boolean!
}

"""Result of feed version unimport operation"""
type FeedVersionUnimportResult {
  "Did the unimport succeed"
  success: Boolean!
}

"""Result of feed version delete operation"""
type FeedVersionDeleteResult {
  "Did the delete succeed"
  success: Boolean!
}


"""Update a feed version entity"""
input FeedVersionSetInput {
  "Entity ID to update"
  id: Int
  "Set entity name to this value"
  name: String
  "Set entity description to this value"
  description: String
}

"""Specify a feed version"""
input FeedVersionInput {
  "Feed version integer ID"
  id: Int
}

"""Update a stop entity"""
input StopSetInput {
  "Entity ID to update"
  id: Int
  "Feed version of entity to update"
  feed_version: FeedVersionInput
  "Set GTFS location_type to this value"
  location_type: Int
  "Set GTFS stop_code to this value"
  stop_code: String
  "Set GTFS stop_desc to this value"
  stop_desc: String
  "Set GTFS stop_id to this value"
  stop_id: String
  "Set GTFS stop_name to this value"
  stop_name: String
  "Set GTFS stop_timezone to this value"
  stop_timezone: String
  "Set GTFS stop_url to this value"
  stop_url: String
  "Set GTFS wheelchair_boarding to this value"
  wheelchair_boarding: Int
  "Set GTFS zone_id to this value"
  zone_id: String
  "Set GTFS platform_code to this value"
  platform_code: String
  "Set GTFS tts_stop_name to this value"
  tts_stop_name: String
  "Set stop geometry to this value"
  geometry: Point
  "Set stop parent station to this stop"
  parent: StopSetInput
  "Set stop level to this level"
  level: LevelSetInput
  "Set or update external reference for this stop"
  external_reference: StopExternalReferenceSetInput
}

input StopExternalReferenceSetInput {
  target_feed_onestop_id: String
  target_stop_id: String
}

"""Update a level entity"""
input LevelSetInput {
  "Entity ID to update"
  id: Int
  "Feed version of entity to update"
  feed_version: FeedVersionInput
  "Set GTFS level_id to this value"
  level_id: String
  "Set GTFS level_name to this value"
  level_name: String
  "Set GTFS level_index to this value"
  level_index: Float
  "Set level geometry to this value"
  geometry: MultiPolygon
  "Set level parent station to this stop"
  parent: StopSetInput
}

"""Update a pathway entity"""
input PathwaySetInput {
  "Entity ID to update"
  id: Int
  "Feed version of entity to update"
  feed_version: FeedVersionInput
  "Set GTFS pathway_id to this value"
  pathway_id: String
  "Set GTFS pathway_mode to this value"
  pathway_mode: Int
  "Set GTFS is_bidirectional to this value"
  is_bidirectional: Int
  "Set GTFS length to this value"
  length: Float
  "Set GTFS traversal_time to this value"
  traversal_time: Int
  "Set GTFS stair_count to this value"
  stair_count: Int
  "Set GTFS max_slope to this value"
  max_slope: Float
  "Set GTFS min_width to this value"
  min_width: Float
  "Set GTFS signposted_as to this value"
  signposted_as: String
  "Set GTFS reverse_signposted_as to this value"
  reverse_signposted_as: String
  "Set pathway origin to this stop"
  from_stop: StopSetInput
  "Set pathway destination to this stop"
  to_stop: StopSetInput
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Agency_alerts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "active", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["active"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Agency_census_geographies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOCensusGeographyFilter2githubcominterlineiotransitlandlibservermodelCensusGeographyFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Agency_places_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOAgencyPlaceFilter2githubcominterlineiotransitlandlibservermodelAgencyPlaceFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Agency_routes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalORouteFilter2githubcominterlineiotransitlandlibservermodelRouteFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Calendar_added_dates_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Calendar_removed_dates_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_CensusDataset_geographies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOCensusDatasetGeographyFilter2githubcominterlineiotransitlandlibservermodelCensusDatasetGeographyFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_CensusDataset_sources_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOCensusSourceFilter2githubcominterlineiotransitlandlibservermodelCensusSourceFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_CensusDataset_tables_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOCensusTableFilter2githubcominterlineiotransitlandlibservermodelCensusTableFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_CensusGeography_values_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "table_names", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["table_names"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "dataset", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["dataset"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg2
	return args, nil
}

func (ec *executionContext) field_CensusLayer_geographies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOCensusSourceGeographyFilter2githubcominterlineiotransitlandlibservermodelCensusSourceGeographyFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_CensusSource_geographies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOCensusSourceGeographyFilter2githubcominterlineiotransitlandlibservermodelCensusSourceGeographyFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_CensusSource_tables_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_FeedVersion_agencies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOAgencyFilter2githubcominterlineiotransitlandlibservermodelAgencyFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_booking_rules_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOBookingRuleFilter2githubcominterlineiotransitlandlibservermodelBookingRuleFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_feed_infos_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_FeedVersion_files_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_FeedVersion_location_groups_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOLocationGroupFilter2githubcominterlineiotransitlandlibservermodelLocationGroupFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_locations_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOLocationFilter2githubcominterlineiotransitlandlibservermodelLocationFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_routes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalORouteFilter2githubcominterlineiotransitlandlibservermodelRouteFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_segments_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_FeedVersion_service_levels_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOFeedVersionServiceLevelFilter2githubcominterlineiotransitlandlibservermodelFeedVersionServiceLevelFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_stops_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOStopFilter2githubcominterlineiotransitlandlibservermodelStopFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_trips_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOTripFilter2githubcominterlineiotransitlandlibservermodelTripFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_validation_reports_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOValidationReportFilter2githubcominterlineiotransitlandlibservermodelValidationReportFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Feed_feed_fetches_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOFeedFetchFilter2githubcominterlineiotransitlandlibservermodelFeedFetchFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Feed_feed_versions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOFeedVersionFilter2githubcominterlineiotransitlandlibservermodelFeedVersionFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_LocationGroup_stop_times_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOStopTimeFilter2githubcominterlineiotransitlandlibservermodelStopTimeFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_LocationGroup_stops_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Location_stop_times_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOStopTimeFilter2githubcominterlineiotransitlandlibservermodelStopTimeFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_feed_version_delete_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_feed_version_fetch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "file", ec.unmarshalOUpload2githubcom99designsgqlgengraphqlUpload)
	if err != nil {
		return nil, err
	}
	args["file"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "url", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["url"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "feed_onestop_id", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["feed_onestop_id"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_feed_version_import_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_feed_version_unimport_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_feed_version_update_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "set", ec.unmarshalNFeedVersionSetInput2githubcominterlineiotransitlandlibservermodelFeedVersionSetInput)
	if err != nil {
		return nil, err
	}
	args["set"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_level_create_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "set", ec.unmarshalNLevelSetInput2githubcominterlineiotransitlandlibservermodelLevelSetInput)
	if err != nil {
		return nil, err
	}
	args["set"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_level_delete_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_level_update_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "set", ec.unmarshalNLevelSetInput2githubcominterlineiotransitlandlibservermodelLevelSetInput)
	if err != nil {
		return nil, err
	}
	args["set"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_pathway_create_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "set", ec.unmarshalNPathwaySetInput2githubcominterlineiotransitlandlibservermodelPathwaySetInput)
	if err != nil {
		return nil, err
	}
	args["set"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_pathway_delete_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_pathway_update_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "set", ec.unmarshalNPathwaySetInput2githubcominterlineiotransitlandlibservermodelPathwaySetInput)
	if err != nil {
		return nil, err
	}
	args["set"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_stop_create_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "set", ec.unmarshalNStopSetInput2githubcominterlineiotransitlandlibservermodelStopSetInput)
	if err != nil {
		return nil, err
	}
	args["set"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_stop_delete_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "id", ec.unmarshalNInt2int)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_stop_update_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "set", ec.unmarshalNStopSetInput2githubcominterlineiotransitlandlibservermodelStopSetInput)
	if err != nil {
		return nil, err
	}
	args["set"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_validate_gtfs_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "file", ec.unmarshalOUpload2githubcom99designsgqlgengraphqlUpload)
	if err != nil {
		return nil, err
	}
	args["file"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "url", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["url"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "realtime_urls", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["realtime_urls"] = arg2
	return args, nil
}

func (ec *executionContext) field_Operator_feeds_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOFeedFilter2githubcominterlineiotransitlandlibservermodelFeedFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_agencies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOAgencyFilter2githubcominterlineiotransitlandlibservermodelAgencyFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_bikes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOGbfsBikeRequest2githubcominterlineiotransitlandlibservermodelGbfsBikeRequest)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_census_datasets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOCensusDatasetFilter2githubcominterlineiotransitlandlibservermodelCensusDatasetFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_census_values_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOCensusValueFilter2githubcominterlineiotransitlandlibservermodelCensusValueFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_directions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalNDirectionRequest2githubcominterlineiotransitlandlibservermodelDirectionRequest)
	if err != nil {
		return nil, err
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_docks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOGbfsDockRequest2githubcominterlineiotransitlandlibservermodelGbfsDockRequest)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_feed_versions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOFeedVersionFilter2githubcominterlineiotransitlandlibservermodelFeedVersionFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_feeds_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOFeedFilter2githubcominterlineiotransitlandlibservermodelFeedFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_operators_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOOperatorFilter2githubcominterlineiotransitlandlibservermodelOperatorFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_places_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "level", ec.unmarshalOPlaceAggregationLevel2githubcominterlineiotransitlandlibservermodelPlaceAggregationLevel)
	if err != nil {
		return nil, err
	}
	args["level"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOPlaceFilter2githubcominterlineiotransitlandlibservermodelPlaceFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_routes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalORouteFilter2githubcominterlineiotransitlandlibservermodelRouteFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_stops_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOStopFilter2githubcominterlineiotransitlandlibservermodelStopFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_trips_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "after", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["after"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "ids", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["ids"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOTripFilter2githubcominterlineiotransitlandlibservermodelTripFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_RouteStopPattern_trips_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Route_alerts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "active", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["active"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Route_census_geographies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOCensusGeographyFilter2githubcominterlineiotransitlandlibservermodelCensusGeographyFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Route_geometries_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Route_headways_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Route_route_stop_buffer_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "radius", ec.unmarshalOFloat2float64)
	if err != nil {
		return nil, err
	}
	args["radius"] = arg0
	return args, nil
}

func (ec *executionContext) field_Route_route_stops_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Route_segment_patterns_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOSegmentPatternFilter2githubcominterlineiotransitlandlibservermodelSegmentPatternFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Route_segments_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOSegmentFilter2githubcominterlineiotransitlandlibservermodelSegmentFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Route_stops_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOStopFilter2githubcominterlineiotransitlandlibservermodelStopFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Route_trips_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOTripFilter2githubcominterlineiotransitlandlibservermodelTripFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_alerts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "active", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["active"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_arrivals_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOStopTimeFilter2githubcominterlineiotransitlandlibservermodelStopTimeFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_census_geographies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOCensusGeographyFilter2githubcominterlineiotransitlandlibservermodelCensusGeographyFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_child_levels_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Stop_children_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Stop_departures_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOStopTimeFilter2githubcominterlineiotransitlandlibservermodelStopTimeFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_directions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "to", ec.unmarshalOWaypointInput2githubcominterlineiotransitlandlibservermodelWaypointInput)
	if err != nil {
		return nil, err
	}
	args["to"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "from", ec.unmarshalOWaypointInput2githubcominterlineiotransitlandlibservermodelWaypointInput)
	if err != nil {
		return nil, err
	}
	args["from"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "mode", ec.unmarshalOStepMode2githubcominterlineiotransitlandlibservermodelStepMode)
	if err != nil {
		return nil, err
	}
	args["mode"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "depart_at", ec.unmarshalOTime2timeTime)
	if err != nil {
		return nil, err
	}
	args["depart_at"] = arg3
	return args, nil
}

func (ec *executionContext) field_Stop_location_groups_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Stop_nearby_stops_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "radius", ec.unmarshalOFloat2float64)
	if err != nil {
		return nil, err
	}
	args["radius"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_observations_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOStopObservationFilter2githubcominterlineiotransitlandlibservermodelStopObservationFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_pathways_from_stop_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Stop_pathways_to_stop_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Stop_route_stops_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Stop_stop_times_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOStopTimeFilter2githubcominterlineiotransitlandlibservermodelStopTimeFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Trip_alerts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "active", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["active"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Trip_flex_stop_times_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOTripStopTimeFilter2githubcominterlineiotransitlandlibservermodelTripStopTimeFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Trip_frequencies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Trip_stop_times_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "where", ec.unmarshalOTripStopTimeFilter2githubcominterlineiotransitlandlibservermodelTripStopTimeFilter)
	if err != nil {
		return nil, err
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_ValidationReportDetails_agencies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_ValidationReportDetails_feed_infos_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_ValidationReportDetails_routes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_ValidationReportDetails_service_levels_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "route_id", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["route_id"] = arg1
	return args, nil
}

func (ec *executionContext) field_ValidationReportDetails_stops_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_ValidationReportErrorGroup_errors_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_ValidationReport_errors_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_ValidationReport_warnings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2int)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Agency_id(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_email(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Email)
	fc.Result = res
	return ec.marshalOEmail2githubcominterlineiotransitlandlibttEmail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Email does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_fare_url(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_fare_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyFareURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Url)
	fc.Result = res
	return ec.marshalOUrl2githubcominterlineiotransitlandlibttUrl(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_fare_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_id(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_lang(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_lang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyLang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Language)
	fc.Result = res
	return ec.marshalOLanguage2githubcominterlineiotransitlandlibttLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_lang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Language does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_name(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_phone(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_phone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyPhone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_phone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_timezone(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyTimezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Timezone)
	fc.Result = res
	return ec.marshalNTimezone2githubcominterlineiotransitlandlibttTimezone(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_timezone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timezone does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_url(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Url)
	fc.Result = res
	return ec.marshalNUrl2githubcominterlineiotransitlandlibttUrl(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_feed_version_sha1(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_feed_version_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersionSHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_feed_version_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_feed_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Agency().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_feed_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "service_window":
				return ec.fieldContext_FeedVersion_service_window(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "locations":
				return ec.fieldContext_FeedVersion_locations(ctx, field)
			case "booking_rules":
				return ec.fieldContext_FeedVersion_booking_rules(ctx, field)
			case "location_groups":
				return ec.fieldContext_FeedVersion_location_groups(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			case "validation_reports":
				return ec.fieldContext_FeedVersion_validation_reports(ctx, field)
			case "segments":
				return ec.fieldContext_FeedVersion_segments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Polygon)
	fc.Result = res
	return ec.marshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Polygon does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_search_rank(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_search_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_search_rank(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_operator(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_operator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Agency().Operator(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Operator)
	fc.Result = res
	return ec.marshalOOperator2githubcominterlineiotransitlandlibservermodelOperator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_operator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Operator_id(ctx, field)
			case "generated":
				return ec.fieldContext_Operator_generated(ctx, field)
			case "file":
				return ec.fieldContext_Operator_file(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Operator_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Operator_name(ctx, field)
			case "short_name":
				return ec.fieldContext_Operator_short_name(ctx, field)
			case "website":
				return ec.fieldContext_Operator_website(ctx, field)
			case "tags":
				return ec.fieldContext_Operator_tags(ctx, field)
			case "search_rank":
				return ec.fieldContext_Operator_search_rank(ctx, field)
			case "agencies":
				return ec.fieldContext_Operator_agencies(ctx, field)
			case "feeds":
				return ec.fieldContext_Operator_feeds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Operator", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_places(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_places(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Agency().Places(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.AgencyPlaceFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.AgencyPlace)
	fc.Result = res
	return ec.marshalOAgencyPlace2githubcominterlineiotransitlandlibservermodelAgencyPlace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_places(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "city_name":
				return ec.fieldContext_AgencyPlace_city_name(ctx, field)
			case "adm1_name":
				return ec.fieldContext_AgencyPlace_adm1_name(ctx, field)
			case "adm1_iso":
				return ec.fieldContext_AgencyPlace_adm1_iso(ctx, field)
			case "adm0_name":
				return ec.fieldContext_AgencyPlace_adm0_name(ctx, field)
			case "adm0_iso":
				return ec.fieldContext_AgencyPlace_adm0_iso(ctx, field)
			case "rank":
				return ec.fieldContext_AgencyPlace_rank(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgencyPlace", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Agency_places_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Agency_routes(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_routes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Agency().Routes(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.RouteFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandlibservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_routes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			case "segments":
				return ec.fieldContext_Route_segments(ctx, field)
			case "segment_patterns":
				return ec.fieldContext_Route_segment_patterns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Agency_routes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Agency_census_geographies(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_census_geographies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Agency().CensusGeographies(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.CensusGeographyFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusGeography)
	fc.Result = res
	return ec.marshalOCensusGeography2githubcominterlineiotransitlandlibservermodelCensusGeography(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_census_geographies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusGeography_id(ctx, field)
			case "dataset_name":
				return ec.fieldContext_CensusGeography_dataset_name(ctx, field)
			case "source_name":
				return ec.fieldContext_CensusGeography_source_name(ctx, field)
			case "layer_name":
				return ec.fieldContext_CensusGeography_layer_name(ctx, field)
			case "geoid":
				return ec.fieldContext_CensusGeography_geoid(ctx, field)
			case "name":
				return ec.fieldContext_CensusGeography_name(ctx, field)
			case "geometry_area":
				return ec.fieldContext_CensusGeography_geometry_area(ctx, field)
			case "aland":
				return ec.fieldContext_CensusGeography_aland(ctx, field)
			case "awater":
				return ec.fieldContext_CensusGeography_awater(ctx, field)
			case "adm1_name":
				return ec.fieldContext_CensusGeography_adm1_name(ctx, field)
			case "adm1_iso":
				return ec.fieldContext_CensusGeography_adm1_iso(ctx, field)
			case "adm0_name":
				return ec.fieldContext_CensusGeography_adm0_name(ctx, field)
			case "adm0_iso":
				return ec.fieldContext_CensusGeography_adm0_iso(ctx, field)
			case "geometry":
				return ec.fieldContext_CensusGeography_geometry(ctx, field)
			case "intersection_area":
				return ec.fieldContext_CensusGeography_intersection_area(ctx, field)
			case "intersection_geometry":
				return ec.fieldContext_CensusGeography_intersection_geometry(ctx, field)
			case "values":
				return ec.fieldContext_CensusGeography_values(ctx, field)
			case "layer":
				return ec.fieldContext_CensusGeography_layer(ctx, field)
			case "source":
				return ec.fieldContext_CensusGeography_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusGeography", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Agency_census_geographies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Agency_alerts(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Agency().Alerts(rctx, obj, fc.Args["active"].(*bool), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Alert)
	fc.Result = res
	return ec.marshalOAlert2githubcominterlineiotransitlandlibservermodelAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "active_period":
				return ec.fieldContext_Alert_active_period(ctx, field)
			case "cause":
				return ec.fieldContext_Alert_cause(ctx, field)
			case "effect":
				return ec.fieldContext_Alert_effect(ctx, field)
			case "header_text":
				return ec.fieldContext_Alert_header_text(ctx, field)
			case "description_text":
				return ec.fieldContext_Alert_description_text(ctx, field)
			case "tts_header_text":
				return ec.fieldContext_Alert_tts_header_text(ctx, field)
			case "tts_description_text":
				return ec.fieldContext_Alert_tts_description_text(ctx, field)
			case "url":
				return ec.fieldContext_Alert_url(ctx, field)
			case "severity_level":
				return ec.fieldContext_Alert_severity_level(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Agency_alerts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _AgencyPlace_city_name(ctx context.Context, field graphql.CollectedField, obj *model.AgencyPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgencyPlace_city_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgencyPlace_city_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgencyPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgencyPlace_adm1_name(ctx context.Context, field graphql.CollectedField, obj *model.AgencyPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgencyPlace_adm1_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm1Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgencyPlace_adm1_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgencyPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgencyPlace_adm1_iso(ctx context.Context, field graphql.CollectedField, obj *model.AgencyPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgencyPlace_adm1_iso(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm1Iso, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgencyPlace_adm1_iso(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgencyPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgencyPlace_adm0_name(ctx context.Context, field graphql.CollectedField, obj *model.AgencyPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgencyPlace_adm0_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm0Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgencyPlace_adm0_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgencyPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgencyPlace_adm0_iso(ctx context.Context, field graphql.CollectedField, obj *model.AgencyPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgencyPlace_adm0_iso(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm0Iso, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgencyPlace_adm0_iso(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgencyPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgencyPlace_rank(ctx context.Context, field graphql.CollectedField, obj *model.AgencyPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgencyPlace_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgencyPlace_rank(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgencyPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_active_period(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_active_period(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActivePeriod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RTTimeRange)
	fc.Result = res
	return ec.marshalORTTimeRange2githubcominterlineiotransitlandlibservermodelRTTimeRange(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_active_period(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "start":
				return ec.fieldContext_RTTimeRange_start(ctx, field)
			case "end":
				return ec.fieldContext_RTTimeRange_end(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTTimeRange", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_cause(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_cause(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cause, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_cause(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_effect(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_effect(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Effect, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_effect(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_header_text(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_header_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeaderText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RTTranslation)
	fc.Result = res
	return ec.marshalNRTTranslation2githubcominterlineiotransitlandlibservermodelRTTranslation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_header_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_RTTranslation_text(ctx, field)
			case "language":
				return ec.fieldContext_RTTranslation_language(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTTranslation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_description_text(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_description_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DescriptionText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RTTranslation)
	fc.Result = res
	return ec.marshalNRTTranslation2githubcominterlineiotransitlandlibservermodelRTTranslation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_description_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_RTTranslation_text(ctx, field)
			case "language":
				return ec.fieldContext_RTTranslation_language(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTTranslation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_tts_header_text(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_tts_header_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TtsHeaderText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RTTranslation)
	fc.Result = res
	return ec.marshalORTTranslation2githubcominterlineiotransitlandlibservermodelRTTranslation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_tts_header_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_RTTranslation_text(ctx, field)
			case "language":
				return ec.fieldContext_RTTranslation_language(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTTranslation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_tts_description_text(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_tts_description_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TtsDescriptionText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RTTranslation)
	fc.Result = res
	return ec.marshalORTTranslation2githubcominterlineiotransitlandlibservermodelRTTranslation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_tts_description_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_RTTranslation_text(ctx, field)
			case "language":
				return ec.fieldContext_RTTranslation_language(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTTranslation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_url(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RTTranslation)
	fc.Result = res
	return ec.marshalORTTranslation2githubcominterlineiotransitlandlibservermodelRTTranslation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_RTTranslation_text(ctx, field)
			case "language":
				return ec.fieldContext_RTTranslation_language(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTTranslation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_severity_level(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_severity_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeverityLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_severity_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_id(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_booking_rule_id(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_booking_rule_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BookingRuleID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_booking_rule_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_booking_type(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_booking_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BookingType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_booking_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_prior_notice_duration_min(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_prior_notice_duration_min(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PriorNoticeDurationMin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_prior_notice_duration_min(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_prior_notice_duration_max(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_prior_notice_duration_max(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PriorNoticeDurationMax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_prior_notice_duration_max(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_prior_notice_last_day(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_prior_notice_last_day(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PriorNoticeLastDay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_prior_notice_last_day(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_prior_notice_last_time(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_prior_notice_last_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PriorNoticeLastTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_prior_notice_last_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_prior_notice_start_day(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_prior_notice_start_day(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PriorNoticeStartDay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_prior_notice_start_day(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_prior_notice_start_time(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_prior_notice_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PriorNoticeStartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_prior_notice_start_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_prior_notice_service(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_prior_notice_service(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BookingRule().PriorNoticeService(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Calendar)
	fc.Result = res
	return ec.marshalOCalendar2githubcominterlineiotransitlandlibservermodelCalendar(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_prior_notice_service(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Calendar_id(ctx, field)
			case "service_id":
				return ec.fieldContext_Calendar_service_id(ctx, field)
			case "start_date":
				return ec.fieldContext_Calendar_start_date(ctx, field)
			case "end_date":
				return ec.fieldContext_Calendar_end_date(ctx, field)
			case "monday":
				return ec.fieldContext_Calendar_monday(ctx, field)
			case "tuesday":
				return ec.fieldContext_Calendar_tuesday(ctx, field)
			case "wednesday":
				return ec.fieldContext_Calendar_wednesday(ctx, field)
			case "thursday":
				return ec.fieldContext_Calendar_thursday(ctx, field)
			case "friday":
				return ec.fieldContext_Calendar_friday(ctx, field)
			case "saturday":
				return ec.fieldContext_Calendar_saturday(ctx, field)
			case "sunday":
				return ec.fieldContext_Calendar_sunday(ctx, field)
			case "added_dates":
				return ec.fieldContext_Calendar_added_dates(ctx, field)
			case "removed_dates":
				return ec.fieldContext_Calendar_removed_dates(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Calendar", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_message(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_pickup_message(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_pickup_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PickupMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_pickup_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_drop_off_message(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_drop_off_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DropOffMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_drop_off_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_phone_number(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_phone_number(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PhoneNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_phone_number(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_info_url(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_info_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Url)
	fc.Result = res
	return ec.marshalOUrl2githubcominterlineiotransitlandlibttUrl(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_info_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_booking_url(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_booking_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BookingURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Url)
	fc.Result = res
	return ec.marshalOUrl2githubcominterlineiotransitlandlibttUrl(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_booking_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_feed_version_sha1(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_feed_version_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersionSHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_feed_version_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_feed_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookingRule_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.BookingRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookingRule_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BookingRule().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookingRule_feed_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookingRule",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "service_window":
				return ec.fieldContext_FeedVersion_service_window(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "locations":
				return ec.fieldContext_FeedVersion_locations(ctx, field)
			case "booking_rules":
				return ec.fieldContext_FeedVersion_booking_rules(ctx, field)
			case "location_groups":
				return ec.fieldContext_FeedVersion_location_groups(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			case "validation_reports":
				return ec.fieldContext_FeedVersion_validation_reports(ctx, field)
			case "segments":
				return ec.fieldContext_FeedVersion_segments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_id(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_service_id(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_service_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_service_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_start_date(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_start_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_end_date(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_end_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_end_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_monday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_monday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Monday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_monday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_tuesday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_tuesday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tuesday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_tuesday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_wednesday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_wednesday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Wednesday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_wednesday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_thursday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_thursday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Thursday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_thursday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_friday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_friday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Friday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_friday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_saturday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_saturday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Saturday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_saturday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_sunday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_sunday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sunday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_sunday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_added_dates(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_added_dates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Calendar().AddedDates(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_added_dates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Calendar_added_dates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_removed_dates(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_removed_dates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Calendar().RemovedDates(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_removed_dates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Calendar_removed_dates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CensusDataset_id(ctx context.Context, field graphql.CollectedField, obj *model.CensusDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusDataset_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusDataset_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusDataset_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusDataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusDataset_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusDataset_description(ctx context.Context, field graphql.CollectedField, obj *model.CensusDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusDataset_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusDataset_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusDataset_url(ctx context.Context, field graphql.CollectedField, obj *model.CensusDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusDataset_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Url)
	fc.Result = res
	return ec.marshalOUrl2githubcominterlineiotransitlandlibttUrl(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusDataset_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusDataset_year_min(ctx context.Context, field graphql.CollectedField, obj *model.CensusDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusDataset_year_min(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.YearMin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusDataset_year_min(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusDataset_year_max(ctx context.Context, field graphql.CollectedField, obj *model.CensusDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusDataset_year_max(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.YearMax, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusDataset_year_max(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusDataset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusDataset_sources(ctx context.Context, field graphql.CollectedField, obj *model.CensusDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusDataset_sources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusDataset().Sources(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.CensusSourceFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusSource)
	fc.Result = res
	return ec.marshalOCensusSource2githubcominterlineiotransitlandlibservermodelCensusSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusDataset_sources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusSource_id(ctx, field)
			case "name":
				return ec.fieldContext_CensusSource_name(ctx, field)
			case "description":
				return ec.fieldContext_CensusSource_description(ctx, field)
			case "url":
				return ec.fieldContext_CensusSource_url(ctx, field)
			case "sha1":
				return ec.fieldContext_CensusSource_sha1(ctx, field)
			case "geographies":
				return ec.fieldContext_CensusSource_geographies(ctx, field)
			case "tables":
				return ec.fieldContext_CensusSource_tables(ctx, field)
			case "layers":
				return ec.fieldContext_CensusSource_layers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusSource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CensusDataset_sources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CensusDataset_geographies(ctx context.Context, field graphql.CollectedField, obj *model.CensusDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusDataset_geographies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusDataset().Geographies(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.CensusDatasetGeographyFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusGeography)
	fc.Result = res
	return ec.marshalOCensusGeography2githubcominterlineiotransitlandlibservermodelCensusGeography(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusDataset_geographies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusGeography_id(ctx, field)
			case "dataset_name":
				return ec.fieldContext_CensusGeography_dataset_name(ctx, field)
			case "source_name":
				return ec.fieldContext_CensusGeography_source_name(ctx, field)
			case "layer_name":
				return ec.fieldContext_CensusGeography_layer_name(ctx, field)
			case "geoid":
				return ec.fieldContext_CensusGeography_geoid(ctx, field)
			case "name":
				return ec.fieldContext_CensusGeography_name(ctx, field)
			case "geometry_area":
				return ec.fieldContext_CensusGeography_geometry_area(ctx, field)
			case "aland":
				return ec.fieldContext_CensusGeography_aland(ctx, field)
			case "awater":
				return ec.fieldContext_CensusGeography_awater(ctx, field)
			case "adm1_name":
				return ec.fieldContext_CensusGeography_adm1_name(ctx, field)
			case "adm1_iso":
				return ec.fieldContext_CensusGeography_adm1_iso(ctx, field)
			case "adm0_name":
				return ec.fieldContext_CensusGeography_adm0_name(ctx, field)
			case "adm0_iso":
				return ec.fieldContext_CensusGeography_adm0_iso(ctx, field)
			case "geometry":
				return ec.fieldContext_CensusGeography_geometry(ctx, field)
			case "intersection_area":
				return ec.fieldContext_CensusGeography_intersection_area(ctx, field)
			case "intersection_geometry":
				return ec.fieldContext_CensusGeography_intersection_geometry(ctx, field)
			case "values":
				return ec.fieldContext_CensusGeography_values(ctx, field)
			case "layer":
				return ec.fieldContext_CensusGeography_layer(ctx, field)
			case "source":
				return ec.fieldContext_CensusGeography_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusGeography", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CensusDataset_geographies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CensusDataset_tables(ctx context.Context, field graphql.CollectedField, obj *model.CensusDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusDataset_tables(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusDataset().Tables(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.CensusTableFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusTable)
	fc.Result = res
	return ec.marshalOCensusTable2githubcominterlineiotransitlandlibservermodelCensusTable(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusDataset_tables(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusTable_id(ctx, field)
			case "table_name":
				return ec.fieldContext_CensusTable_table_name(ctx, field)
			case "table_title":
				return ec.fieldContext_CensusTable_table_title(ctx, field)
			case "table_group":
				return ec.fieldContext_CensusTable_table_group(ctx, field)
			case "table_details":
				return ec.fieldContext_CensusTable_table_details(ctx, field)
			case "fields":
				return ec.fieldContext_CensusTable_fields(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusTable", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CensusDataset_tables_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CensusDataset_layers(ctx context.Context, field graphql.CollectedField, obj *model.CensusDataset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusDataset_layers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusDataset().Layers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusLayer)
	fc.Result = res
	return ec.marshalOCensusLayer2githubcominterlineiotransitlandlibservermodelCensusLayer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusDataset_layers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusDataset",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusLayer_id(ctx, field)
			case "name":
				return ec.fieldContext_CensusLayer_name(ctx, field)
			case "description":
				return ec.fieldContext_CensusLayer_description(ctx, field)
			case "geographies":
				return ec.fieldContext_CensusLayer_geographies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusLayer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusField_id(ctx context.Context, field graphql.CollectedField, obj *model.CensusField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusField_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusField_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusField_field_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusField_field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusField_field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusField_field_title(ctx context.Context, field graphql.CollectedField, obj *model.CensusField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusField_field_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldTitle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusField_field_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusField_column_order(ctx context.Context, field graphql.CollectedField, obj *model.CensusField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusField_column_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColumnOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusField_column_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_id(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_dataset_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_dataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DatasetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_dataset_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_source_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_source_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_source_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_layer_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_layer_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LayerName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_layer_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_geoid(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_geoid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geoid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_geoid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_geometry_area(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_geometry_area(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GeometryArea, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_geometry_area(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_aland(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_aland(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aland, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_aland(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_awater(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_awater(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Awater, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_awater(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_adm1_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_adm1_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm1Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_adm1_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_adm1_iso(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_adm1_iso(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm1Iso, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_adm1_iso(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_adm0_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_adm0_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm0Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_adm0_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_adm0_iso(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_adm0_iso(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm0Iso, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_adm0_iso(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_geometry(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.MultiPolygon)
	fc.Result = res
	return ec.marshalOMultiPolygon2githubcominterlineiotransitlandlibttMultiPolygon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MultiPolygon does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_intersection_area(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_intersection_area(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntersectionArea, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_intersection_area(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_intersection_geometry(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_intersection_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntersectionGeometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_intersection_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_values(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusGeography().Values(rctx, obj, fc.Args["table_names"].([]string), fc.Args["dataset"].(*string), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CensusValue)
	fc.Result = res
	return ec.marshalNCensusValue2githubcominterlineiotransitlandlibservermodelCensusValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dataset_name":
				return ec.fieldContext_CensusValue_dataset_name(ctx, field)
			case "source_name":
				return ec.fieldContext_CensusValue_source_name(ctx, field)
			case "table":
				return ec.fieldContext_CensusValue_table(ctx, field)
			case "values":
				return ec.fieldContext_CensusValue_values(ctx, field)
			case "geoid":
				return ec.fieldContext_CensusValue_geoid(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CensusGeography_values_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_layer(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_layer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusGeography().Layer(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CensusLayer)
	fc.Result = res
	return ec.marshalOCensusLayer2githubcominterlineiotransitlandlibservermodelCensusLayer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_layer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusLayer_id(ctx, field)
			case "name":
				return ec.fieldContext_CensusLayer_name(ctx, field)
			case "description":
				return ec.fieldContext_CensusLayer_description(ctx, field)
			case "geographies":
				return ec.fieldContext_CensusLayer_geographies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusLayer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_source(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusGeography().Source(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CensusSource)
	fc.Result = res
	return ec.marshalOCensusSource2githubcominterlineiotransitlandlibservermodelCensusSource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusSource_id(ctx, field)
			case "name":
				return ec.fieldContext_CensusSource_name(ctx, field)
			case "description":
				return ec.fieldContext_CensusSource_description(ctx, field)
			case "url":
				return ec.fieldContext_CensusSource_url(ctx, field)
			case "sha1":
				return ec.fieldContext_CensusSource_sha1(ctx, field)
			case "geographies":
				return ec.fieldContext_CensusSource_geographies(ctx, field)
			case "tables":
				return ec.fieldContext_CensusSource_tables(ctx, field)
			case "layers":
				return ec.fieldContext_CensusSource_layers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusSource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusLayer_id(ctx context.Context, field graphql.CollectedField, obj *model.CensusLayer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusLayer_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusLayer_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusLayer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusLayer_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusLayer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusLayer_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusLayer_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusLayer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusLayer_description(ctx context.Context, field graphql.CollectedField, obj *model.CensusLayer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusLayer_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusLayer_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusLayer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusLayer_geographies(ctx context.Context, field graphql.CollectedField, obj *model.CensusLayer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusLayer_geographies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusLayer().Geographies(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.CensusSourceGeographyFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusGeography)
	fc.Result = res
	return ec.marshalOCensusGeography2githubcominterlineiotransitlandlibservermodelCensusGeography(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusLayer_geographies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusLayer",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusGeography_id(ctx, field)
			case "dataset_name":
				return ec.fieldContext_CensusGeography_dataset_name(ctx, field)
			case "source_name":
				return ec.fieldContext_CensusGeography_source_name(ctx, field)
			case "layer_name":
				return ec.fieldContext_CensusGeography_layer_name(ctx, field)
			case "geoid":
				return ec.fieldContext_CensusGeography_geoid(ctx, field)
			case "name":
				return ec.fieldContext_CensusGeography_name(ctx, field)
			case "geometry_area":
				return ec.fieldContext_CensusGeography_geometry_area(ctx, field)
			case "aland":
				return ec.fieldContext_CensusGeography_aland(ctx, field)
			case "awater":
				return ec.fieldContext_CensusGeography_awater(ctx, field)
			case "adm1_name":
				return ec.fieldContext_CensusGeography_adm1_name(ctx, field)
			case "adm1_iso":
				return ec.fieldContext_CensusGeography_adm1_iso(ctx, field)
			case "adm0_name":
				return ec.fieldContext_CensusGeography_adm0_name(ctx, field)
			case "adm0_iso":
				return ec.fieldContext_CensusGeography_adm0_iso(ctx, field)
			case "geometry":
				return ec.fieldContext_CensusGeography_geometry(ctx, field)
			case "intersection_area":
				return ec.fieldContext_CensusGeography_intersection_area(ctx, field)
			case "intersection_geometry":
				return ec.fieldContext_CensusGeography_intersection_geometry(ctx, field)
			case "values":
				return ec.fieldContext_CensusGeography_values(ctx, field)
			case "layer":
				return ec.fieldContext_CensusGeography_layer(ctx, field)
			case "source":
				return ec.fieldContext_CensusGeography_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusGeography", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CensusLayer_geographies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CensusSource_id(ctx context.Context, field graphql.CollectedField, obj *model.CensusSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusSource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusSource_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusSource_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusSource_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusSource_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusSource_description(ctx context.Context, field graphql.CollectedField, obj *model.CensusSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusSource_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusSource_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusSource_url(ctx context.Context, field graphql.CollectedField, obj *model.CensusSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusSource_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Url)
	fc.Result = res
	return ec.marshalNUrl2githubcominterlineiotransitlandlibttUrl(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusSource_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusSource_sha1(ctx context.Context, field graphql.CollectedField, obj *model.CensusSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusSource_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sha1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusSource_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusSource_geographies(ctx context.Context, field graphql.CollectedField, obj *model.CensusSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusSource_geographies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusSource().Geographies(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.CensusSourceGeographyFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusGeography)
	fc.Result = res
	return ec.marshalOCensusGeography2githubcominterlineiotransitlandlibservermodelCensusGeography(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusSource_geographies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusSource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusGeography_id(ctx, field)
			case "dataset_name":
				return ec.fieldContext_CensusGeography_dataset_name(ctx, field)
			case "source_name":
				return ec.fieldContext_CensusGeography_source_name(ctx, field)
			case "layer_name":
				return ec.fieldContext_CensusGeography_layer_name(ctx, field)
			case "geoid":
				return ec.fieldContext_CensusGeography_geoid(ctx, field)
			case "name":
				return ec.fieldContext_CensusGeography_name(ctx, field)
			case "geometry_area":
				return ec.fieldContext_CensusGeography_geometry_area(ctx, field)
			case "aland":
				return ec.fieldContext_CensusGeography_aland(ctx, field)
			case "awater":
				return ec.fieldContext_CensusGeography_awater(ctx, field)
			case "adm1_name":
				return ec.fieldContext_CensusGeography_adm1_name(ctx, field)
			case "adm1_iso":
				return ec.fieldContext_CensusGeography_adm1_iso(ctx, field)
			case "adm0_name":
				return ec.fieldContext_CensusGeography_adm0_name(ctx, field)
			case "adm0_iso":
				return ec.fieldContext_CensusGeography_adm0_iso(ctx, field)
			case "geometry":
				return ec.fieldContext_CensusGeography_geometry(ctx, field)
			case "intersection_area":
				return ec.fieldContext_CensusGeography_intersection_area(ctx, field)
			case "intersection_geometry":
				return ec.fieldContext_CensusGeography_intersection_geometry(ctx, field)
			case "values":
				return ec.fieldContext_CensusGeography_values(ctx, field)
			case "layer":
				return ec.fieldContext_CensusGeography_layer(ctx, field)
			case "source":
				return ec.fieldContext_CensusGeography_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusGeography", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CensusSource_geographies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CensusSource_tables(ctx context.Context, field graphql.CollectedField, obj *model.CensusSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusSource_tables(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tables, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusTable)
	fc.Result = res
	return ec.marshalOCensusTable2githubcominterlineiotransitlandlibservermodelCensusTable(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusSource_tables(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusSource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusTable_id(ctx, field)
			case "table_name":
				return ec.fieldContext_CensusTable_table_name(ctx, field)
			case "table_title":
				return ec.fieldContext_CensusTable_table_title(ctx, field)
			case "table_group":
				return ec.fieldContext_CensusTable_table_group(ctx, field)
			case "table_details":
				return ec.fieldContext_CensusTable_table_details(ctx, field)
			case "fields":
				return ec.fieldContext_CensusTable_fields(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusTable", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CensusSource_tables_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _CensusSource_layers(ctx context.Context, field graphql.CollectedField, obj *model.CensusSource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusSource_layers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusSource().Layers(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusLayer)
	fc.Result = res
	return ec.marshalOCensusLayer2githubcominterlineiotransitlandlibservermodelCensusLayer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusSource_layers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusSource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusLayer_id(ctx, field)
			case "name":
				return ec.fieldContext_CensusLayer_name(ctx, field)
			case "description":
				return ec.fieldContext_CensusLayer_description(ctx, field)
			case "geographies":
				return ec.fieldContext_CensusLayer_geographies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusLayer", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusTable_id(ctx context.Context, field graphql.CollectedField, obj *model.CensusTable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusTable_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusTable_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusTable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusTable_table_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusTable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusTable_table_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TableName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusTable_table_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusTable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusTable_table_title(ctx context.Context, field graphql.CollectedField, obj *model.CensusTable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusTable_table_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TableTitle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusTable_table_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusTable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusTable_table_group(ctx context.Context, field graphql.CollectedField, obj *model.CensusTable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusTable_table_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TableGroup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusTable_table_group(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusTable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusTable_table_details(ctx context.Context, field graphql.CollectedField, obj *model.CensusTable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusTable_table_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TableDetails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusTable_table_details(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusTable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusTable_fields(ctx context.Context, field graphql.CollectedField, obj *model.CensusTable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusTable_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusTable().Fields(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CensusField)
	fc.Result = res
	return ec.marshalNCensusField2githubcominterlineiotransitlandlibservermodelCensusField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusTable_fields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusTable",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusField_id(ctx, field)
			case "field_name":
				return ec.fieldContext_CensusField_field_name(ctx, field)
			case "field_title":
				return ec.fieldContext_CensusField_field_title(ctx, field)
			case "column_order":
				return ec.fieldContext_CensusField_column_order(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusValue_dataset_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusValue_dataset_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DatasetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusValue_dataset_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusValue_source_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusValue_source_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusValue_source_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusValue_table(ctx context.Context, field graphql.CollectedField, obj *model.CensusValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusValue_table(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusValue().Table(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CensusTable)
	fc.Result = res
	return ec.marshalNCensusTable2githubcominterlineiotransitlandlibservermodelCensusTable(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusValue_table(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusTable_id(ctx, field)
			case "table_name":
				return ec.fieldContext_CensusTable_table_name(ctx, field)
			case "table_title":
				return ec.fieldContext_CensusTable_table_title(ctx, field)
			case "table_group":
				return ec.fieldContext_CensusTable_table_group(ctx, field)
			case "table_details":
				return ec.fieldContext_CensusTable_table_details(ctx, field)
			case "fields":
				return ec.fieldContext_CensusTable_fields(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusTable", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusValue_values(ctx context.Context, field graphql.CollectedField, obj *model.CensusValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusValue_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Map)
	fc.Result = res
	return ec.marshalNMap2githubcominterlineiotransitlandlibttMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusValue_values(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusValue_geoid(ctx context.Context, field graphql.CollectedField, obj *model.CensusValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusValue_geoid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geoid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusValue_geoid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_success(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_exception(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_exception(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exception, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_exception(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_data_source(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_data_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataSource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_data_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_origin(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_origin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Origin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalOWaypoint2githubcominterlineiotransitlandlibservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_origin(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			case "stop":
				return ec.fieldContext_Waypoint_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_destination(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_destination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalOWaypoint2githubcominterlineiotransitlandlibservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_destination(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			case "stop":
				return ec.fieldContext_Waypoint_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_duration(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2githubcominterlineiotransitlandlibservermodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Duration_duration(ctx, field)
			case "units":
				return ec.fieldContext_Duration_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Duration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_distance(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Distance)
	fc.Result = res
	return ec.marshalODistance2githubcominterlineiotransitlandlibservermodelDistance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_distance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distance":
				return ec.fieldContext_Distance_distance(ctx, field)
			case "units":
				return ec.fieldContext_Distance_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_start_time(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_start_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_end_time(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_end_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_itineraries(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_itineraries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Itineraries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Itinerary)
	fc.Result = res
	return ec.marshalOItinerary2githubcominterlineiotransitlandlibservermodelItinerary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_itineraries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Itinerary_duration(ctx, field)
			case "distance":
				return ec.fieldContext_Itinerary_distance(ctx, field)
			case "start_time":
				return ec.fieldContext_Itinerary_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_Itinerary_end_time(ctx, field)
			case "from":
				return ec.fieldContext_Itinerary_from(ctx, field)
			case "to":
				return ec.fieldContext_Itinerary_to(ctx, field)
			case "legs":
				return ec.fieldContext_Itinerary_legs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Itinerary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distance_distance(ctx context.Context, field graphql.CollectedField, obj *model.Distance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distance_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distance_distance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distance_units(ctx context.Context, field graphql.CollectedField, obj *model.Distance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distance_units(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Units, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DistanceUnit)
	fc.Result = res
	return ec.marshalNDistanceUnit2githubcominterlineiotransitlandlibservermodelDistanceUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distance_units(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DistanceUnit does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Duration_duration(ctx context.Context, field graphql.CollectedField, obj *model.Duration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Duration_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Duration_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Duration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Duration_units(ctx context.Context, field graphql.CollectedField, obj *model.Duration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Duration_units(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Units, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DurationUnit)
	fc.Result = res
	return ec.marshalNDurationUnit2githubcominterlineiotransitlandlibservermodelDurationUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Duration_units(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Duration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DurationUnit does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EntityDeleteResult_id(ctx context.Context, field graphql.CollectedField, obj *model.EntityDeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EntityDeleteResult_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EntityDeleteResult_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EntityDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_id(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_name(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_file(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_file(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.File, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_file(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_spec(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().Spec(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedSpecTypes)
	fc.Result = res
	return ec.marshalOFeedSpecTypes2githubcominterlineiotransitlandlibservermodelFeedSpecTypes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_spec(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FeedSpecTypes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_languages(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_languages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().Languages(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_languages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_tags(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Tags)
	fc.Result = res
	return ec.marshalOTags2githubcominterlineiotransitlandlibttTags(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Tags does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_authorization(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_authorization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().Authorization(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedAuthorization)
	fc.Result = res
	return ec.marshalOFeedAuthorization2githubcominterlineiotransitlandlibservermodelFeedAuthorization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_authorization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_FeedAuthorization_type(ctx, field)
			case "param_name":
				return ec.fieldContext_FeedAuthorization_param_name(ctx, field)
			case "info_url":
				return ec.fieldContext_FeedAuthorization_info_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedAuthorization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_urls(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().Urls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedUrls)
	fc.Result = res
	return ec.marshalOFeedUrls2githubcominterlineiotransitlandlibservermodelFeedUrls(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_urls(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "static_current":
				return ec.fieldContext_FeedUrls_static_current(ctx, field)
			case "static_historic":
				return ec.fieldContext_FeedUrls_static_historic(ctx, field)
			case "static_planned":
				return ec.fieldContext_FeedUrls_static_planned(ctx, field)
			case "realtime_vehicle_positions":
				return ec.fieldContext_FeedUrls_realtime_vehicle_positions(ctx, field)
			case "realtime_trip_updates":
				return ec.fieldContext_FeedUrls_realtime_trip_updates(ctx, field)
			case "realtime_alerts":
				return ec.fieldContext_FeedUrls_realtime_alerts(ctx, field)
			case "gbfs_auto_discovery":
				return ec.fieldContext_FeedUrls_gbfs_auto_discovery(ctx, field)
			case "mds_provider":
				return ec.fieldContext_FeedUrls_mds_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedUrls", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_license(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_license(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().License(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedLicense)
	fc.Result = res
	return ec.marshalOFeedLicense2githubcominterlineiotransitlandlibservermodelFeedLicense(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_license(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spdx_identifier":
				return ec.fieldContext_FeedLicense_spdx_identifier(ctx, field)
			case "url":
				return ec.fieldContext_FeedLicense_url(ctx, field)
			case "use_without_attribution":
				return ec.fieldContext_FeedLicense_use_without_attribution(ctx, field)
			case "create_derived_product":
				return ec.fieldContext_FeedLicense_create_derived_product(ctx, field)
			case "redistribution_allowed":
				return ec.fieldContext_FeedLicense_redistribution_allowed(ctx, field)
			case "commercial_use_allowed":
				return ec.fieldContext_FeedLicense_commercial_use_allowed(ctx, field)
			case "share_alike_optional":
				return ec.fieldContext_FeedLicense_share_alike_optional(ctx, field)
			case "attribution_text":
				return ec.fieldContext_FeedLicense_attribution_text(ctx, field)
			case "attribution_instructions":
				return ec.fieldContext_FeedLicense_attribution_instructions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedLicense", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_search_rank(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_search_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_search_rank(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_associated_operators(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_associated_operators(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().AssociatedOperators(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Operator)
	fc.Result = res
	return ec.marshalOOperator2githubcominterlineiotransitlandlibservermodelOperator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_associated_operators(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Operator_id(ctx, field)
			case "generated":
				return ec.fieldContext_Operator_generated(ctx, field)
			case "file":
				return ec.fieldContext_Operator_file(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Operator_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Operator_name(ctx, field)
			case "short_name":
				return ec.fieldContext_Operator_short_name(ctx, field)
			case "website":
				return ec.fieldContext_Operator_website(ctx, field)
			case "tags":
				return ec.fieldContext_Operator_tags(ctx, field)
			case "search_rank":
				return ec.fieldContext_Operator_search_rank(ctx, field)
			case "agencies":
				return ec.fieldContext_Operator_agencies(ctx, field)
			case "feeds":
				return ec.fieldContext_Operator_feeds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Operator", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_feed_state(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_feed_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().FeedState(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedState)
	fc.Result = res
	return ec.marshalOFeedState2githubcominterlineiotransitlandlibservermodelFeedState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_feed_state(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedState_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_FeedState_feed_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_feed_fetches(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_feed_fetches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().FeedFetches(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.FeedFetchFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.FeedFetch)
	fc.Result = res
	return ec.marshalOFeedFetch2githubcominterlineiotransitlandlibservermodelFeedFetch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_feed_fetches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedFetch_id(ctx, field)
			case "url_type":
				return ec.fieldContext_FeedFetch_url_type(ctx, field)
			case "url":
				return ec.fieldContext_FeedFetch_url(ctx, field)
			case "success":
				return ec.fieldContext_FeedFetch_success(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedFetch_fetched_at(ctx, field)
			case "fetch_error":
				return ec.fieldContext_FeedFetch_fetch_error(ctx, field)
			case "response_size":
				return ec.fieldContext_FeedFetch_response_size(ctx, field)
			case "response_code":
				return ec.fieldContext_FeedFetch_response_code(ctx, field)
			case "response_sha1":
				return ec.fieldContext_FeedFetch_response_sha1(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedFetch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Feed_feed_fetches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Feed_feed_versions(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_feed_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().FeedVersions(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.FeedVersionFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_feed_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "service_window":
				return ec.fieldContext_FeedVersion_service_window(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "locations":
				return ec.fieldContext_FeedVersion_locations(ctx, field)
			case "booking_rules":
				return ec.fieldContext_FeedVersion_booking_rules(ctx, field)
			case "location_groups":
				return ec.fieldContext_FeedVersion_location_groups(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			case "validation_reports":
				return ec.fieldContext_FeedVersion_validation_reports(ctx, field)
			case "segments":
				return ec.fieldContext_FeedVersion_segments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Feed_feed_versions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedAuthorization_type(ctx context.Context, field graphql.CollectedField, obj *model.FeedAuthorization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedAuthorization_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedAuthorization_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedAuthorization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedAuthorization_param_name(ctx context.Context, field graphql.CollectedField, obj *model.FeedAuthorization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedAuthorization_param_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParamName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedAuthorization_param_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedAuthorization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedAuthorization_info_url(ctx context.Context, field graphql.CollectedField, obj *model.FeedAuthorization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedAuthorization_info_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedAuthorization_info_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedAuthorization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_url_type(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_url_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_url_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_url(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_success(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_fetched_at(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_fetched_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Time)
	fc.Result = res
	return ec.marshalOTime2githubcominterlineiotransitlandlibttTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_fetched_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_fetch_error(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_fetch_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchError, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_fetch_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_response_size(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_response_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_response_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_response_code(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_response_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_response_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_response_sha1(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_response_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseSha1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_response_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_publisher_name(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_publisher_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedPublisherName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_publisher_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_publisher_url(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_publisher_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedPublisherURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Url)
	fc.Result = res
	return ec.marshalNUrl2githubcominterlineiotransitlandlibttUrl(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_publisher_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_lang(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_lang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedLang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Language)
	fc.Result = res
	return ec.marshalNLanguage2githubcominterlineiotransitlandlibttLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_lang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Language does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_default_lang(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_default_lang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultLang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Language)
	fc.Result = res
	return ec.marshalOLanguage2githubcominterlineiotransitlandlibttLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_default_lang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Language does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_start_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedStartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_start_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_end_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_end_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedEndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_end_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_contact_email(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_contact_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedContactEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Email)
	fc.Result = res
	return ec.marshalOEmail2githubcominterlineiotransitlandlibttEmail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_contact_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Email does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_contact_url(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_contact_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedContactURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Url)
	fc.Result = res
	return ec.marshalOUrl2githubcominterlineiotransitlandlibttUrl(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_contact_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_spdx_identifier(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_spdx_identifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpdxIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_spdx_identifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_url(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_use_without_attribution(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_use_without_attribution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseWithoutAttribution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_use_without_attribution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_create_derived_product(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_create_derived_product(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateDerivedProduct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_create_derived_product(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_redistribution_allowed(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_redistribution_allowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedistributionAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_redistribution_allowed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_commercial_use_allowed(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_commercial_use_allowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommercialUseAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_commercial_use_allowed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_share_alike_optional(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_share_alike_optional(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShareAlikeOptional, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_share_alike_optional(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_attribution_text(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_attribution_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AttributionText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_attribution_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_attribution_instructions(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_attribution_instructions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AttributionInstructions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_attribution_instructions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedState_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedState_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedState_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedState_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.FeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedState_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedState().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalOFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedState_feed_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedState",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "service_window":
				return ec.fieldContext_FeedVersion_service_window(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "locations":
				return ec.fieldContext_FeedVersion_locations(ctx, field)
			case "booking_rules":
				return ec.fieldContext_FeedVersion_booking_rules(ctx, field)
			case "location_groups":
				return ec.fieldContext_FeedVersion_location_groups(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			case "validation_reports":
				return ec.fieldContext_FeedVersion_validation_reports(ctx, field)
			case "segments":
				return ec.fieldContext_FeedVersion_segments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_static_current(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_static_current(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticCurrent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_static_current(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_static_historic(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_static_historic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticHistoric, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_static_historic(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_static_planned(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_static_planned(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticPlanned, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_static_planned(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_realtime_vehicle_positions(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_realtime_vehicle_positions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RealtimeVehiclePositions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_realtime_vehicle_positions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_realtime_trip_updates(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_realtime_trip_updates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RealtimeTripUpdates, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_realtime_trip_updates(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_realtime_alerts(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_realtime_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RealtimeAlerts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_realtime_alerts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_gbfs_auto_discovery(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_gbfs_auto_discovery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GbfsAutoDiscovery, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_gbfs_auto_discovery(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_mds_provider(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_mds_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MdsProvider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_mds_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_sha1(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_fetched_at(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_fetched_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_fetched_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_url(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_earliest_calendar_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EarliestCalendarDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_earliest_calendar_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_latest_calendar_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestCalendarDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_latest_calendar_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_created_by(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_created_by(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_created_by(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_updated_by(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_updated_by(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_updated_by(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_name(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_description(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_file(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_file(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.File, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_file(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_geometry(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Geometry(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Polygon)
	fc.Result = res
	return ec.marshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Polygon does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_feed(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_feed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Feed(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Feed)
	fc.Result = res
	return ec.marshalNFeed2githubcominterlineiotransitlandlibservermodelFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_feed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Feed_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "file":
				return ec.fieldContext_Feed_file(ctx, field)
			case "spec":
				return ec.fieldContext_Feed_spec(ctx, field)
			case "languages":
				return ec.fieldContext_Feed_languages(ctx, field)
			case "tags":
				return ec.fieldContext_Feed_tags(ctx, field)
			case "authorization":
				return ec.fieldContext_Feed_authorization(ctx, field)
			case "urls":
				return ec.fieldContext_Feed_urls(ctx, field)
			case "license":
				return ec.fieldContext_Feed_license(ctx, field)
			case "search_rank":
				return ec.fieldContext_Feed_search_rank(ctx, field)
			case "associated_operators":
				return ec.fieldContext_Feed_associated_operators(ctx, field)
			case "feed_state":
				return ec.fieldContext_Feed_feed_state(ctx, field)
			case "feed_fetches":
				return ec.fieldContext_Feed_feed_fetches(ctx, field)
			case "feed_versions":
				return ec.fieldContext_Feed_feed_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_feed_version_gtfs_import(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().FeedVersionGtfsImport(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersionGtfsImport)
	fc.Result = res
	return ec.marshalOFeedVersionGtfsImport2githubcominterlineiotransitlandlibservermodelFeedVersionGtfsImport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_feed_version_gtfs_import(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersionGtfsImport_id(ctx, field)
			case "in_progress":
				return ec.fieldContext_FeedVersionGtfsImport_in_progress(ctx, field)
			case "success":
				return ec.fieldContext_FeedVersionGtfsImport_success(ctx, field)
			case "schedule_removed":
				return ec.fieldContext_FeedVersionGtfsImport_schedule_removed(ctx, field)
			case "exception_log":
				return ec.fieldContext_FeedVersionGtfsImport_exception_log(ctx, field)
			case "skip_entity_error_count":
				return ec.fieldContext_FeedVersionGtfsImport_skip_entity_error_count(ctx, field)
			case "entity_count":
				return ec.fieldContext_FeedVersionGtfsImport_entity_count(ctx, field)
			case "warning_count":
				return ec.fieldContext_FeedVersionGtfsImport_warning_count(ctx, field)
			case "skip_entity_reference_count":
				return ec.fieldContext_FeedVersionGtfsImport_skip_entity_reference_count(ctx, field)
			case "skip_entity_filter_count":
				return ec.fieldContext_FeedVersionGtfsImport_skip_entity_filter_count(ctx, field)
			case "skip_entity_marked_count":
				return ec.fieldContext_FeedVersionGtfsImport_skip_entity_marked_count(ctx, field)
			case "interpolated_stop_time_count":
				return ec.fieldContext_FeedVersionGtfsImport_interpolated_stop_time_count(ctx, field)
			case "created_at":
				return ec.fieldContext_FeedVersionGtfsImport_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_FeedVersionGtfsImport_updated_at(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionGtfsImport", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_files(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Files(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedVersionFileInfo)
	fc.Result = res
	return ec.marshalNFeedVersionFileInfo2githubcominterlineiotransitlandlibservermodelFeedVersionFileInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_files(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersionFileInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersionFileInfo_name(ctx, field)
			case "rows":
				return ec.fieldContext_FeedVersionFileInfo_rows(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersionFileInfo_sha1(ctx, field)
			case "header":
				return ec.fieldContext_FeedVersionFileInfo_header(ctx, field)
			case "csv_like":
				return ec.fieldContext_FeedVersionFileInfo_csv_like(ctx, field)
			case "size":
				return ec.fieldContext_FeedVersionFileInfo_size(ctx, field)
			case "values_count":
				return ec.fieldContext_FeedVersionFileInfo_values_count(ctx, field)
			case "values_unique":
				return ec.fieldContext_FeedVersionFileInfo_values_unique(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionFileInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_files_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_service_levels(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_service_levels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().ServiceLevels(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.FeedVersionServiceLevelFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedVersionServiceLevel)
	fc.Result = res
	return ec.marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandlibservermodelFeedVersionServiceLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_service_levels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersionServiceLevel_id(ctx, field)
			case "start_date":
				return ec.fieldContext_FeedVersionServiceLevel_start_date(ctx, field)
			case "end_date":
				return ec.fieldContext_FeedVersionServiceLevel_end_date(ctx, field)
			case "monday":
				return ec.fieldContext_FeedVersionServiceLevel_monday(ctx, field)
			case "tuesday":
				return ec.fieldContext_FeedVersionServiceLevel_tuesday(ctx, field)
			case "wednesday":
				return ec.fieldContext_FeedVersionServiceLevel_wednesday(ctx, field)
			case "thursday":
				return ec.fieldContext_FeedVersionServiceLevel_thursday(ctx, field)
			case "friday":
				return ec.fieldContext_FeedVersionServiceLevel_friday(ctx, field)
			case "saturday":
				return ec.fieldContext_FeedVersionServiceLevel_saturday(ctx, field)
			case "sunday":
				return ec.fieldContext_FeedVersionServiceLevel_sunday(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionServiceLevel", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_service_levels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_service_window(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_service_window(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().ServiceWindow(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersionServiceWindow)
	fc.Result = res
	return ec.marshalOFeedVersionServiceWindow2githubcominterlineiotransitlandlibservermodelFeedVersionServiceWindow(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_service_window(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersionServiceWindow_id(ctx, field)
			case "feed_start_date":
				return ec.fieldContext_FeedVersionServiceWindow_feed_start_date(ctx, field)
			case "feed_end_date":
				return ec.fieldContext_FeedVersionServiceWindow_feed_end_date(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersionServiceWindow_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersionServiceWindow_latest_calendar_date(ctx, field)
			case "fallback_week":
				return ec.fieldContext_FeedVersionServiceWindow_fallback_week(ctx, field)
			case "default_timezone":
				return ec.fieldContext_FeedVersionServiceWindow_default_timezone(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionServiceWindow", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_agencies(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_agencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Agencies(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.AgencyFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Agency)
	fc.Result = res
	return ec.marshalNAgency2githubcominterlineiotransitlandlibservermodelAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_agencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Agency_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Agency_onestop_id(ctx, field)
			case "agency_email":
				return ec.fieldContext_Agency_agency_email(ctx, field)
			case "agency_fare_url":
				return ec.fieldContext_Agency_agency_fare_url(ctx, field)
			case "agency_id":
				return ec.fieldContext_Agency_agency_id(ctx, field)
			case "agency_lang":
				return ec.fieldContext_Agency_agency_lang(ctx, field)
			case "agency_name":
				return ec.fieldContext_Agency_agency_name(ctx, field)
			case "agency_phone":
				return ec.fieldContext_Agency_agency_phone(ctx, field)
			case "agency_timezone":
				return ec.fieldContext_Agency_agency_timezone(ctx, field)
			case "agency_url":
				return ec.fieldContext_Agency_agency_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Agency_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Agency_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Agency_feed_version(ctx, field)
			case "geometry":
				return ec.fieldContext_Agency_geometry(ctx, field)
			case "search_rank":
				return ec.fieldContext_Agency_search_rank(ctx, field)
			case "operator":
				return ec.fieldContext_Agency_operator(ctx, field)
			case "places":
				return ec.fieldContext_Agency_places(ctx, field)
			case "routes":
				return ec.fieldContext_Agency_routes(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Agency_census_geographies(ctx, field)
			case "alerts":
				return ec.fieldContext_Agency_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Agency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_agencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_routes(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_routes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Routes(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.RouteFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandlibservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_routes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			case "segments":
				return ec.fieldContext_Route_segments(ctx, field)
			case "segment_patterns":
				return ec.fieldContext_Route_segment_patterns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_routes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_stops(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Stops(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_trips(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_trips(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Trips(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.TripFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Trip)
	fc.Result = res
	return ec.marshalNTrip2githubcominterlineiotransitlandlibservermodelTrip(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_trips(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trip_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_Trip_trip_id(ctx, field)
			case "trip_headsign":
				return ec.fieldContext_Trip_trip_headsign(ctx, field)
			case "trip_short_name":
				return ec.fieldContext_Trip_trip_short_name(ctx, field)
			case "direction_id":
				return ec.fieldContext_Trip_direction_id(ctx, field)
			case "block_id":
				return ec.fieldContext_Trip_block_id(ctx, field)
			case "wheelchair_accessible":
				return ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
			case "bikes_allowed":
				return ec.fieldContext_Trip_bikes_allowed(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_Trip_stop_pattern_id(ctx, field)
			case "calendar":
				return ec.fieldContext_Trip_calendar(ctx, field)
			case "route":
				return ec.fieldContext_Trip_route(ctx, field)
			case "shape":
				return ec.fieldContext_Trip_shape(ctx, field)
			case "feed_version":
				return ec.fieldContext_Trip_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Trip_stop_times(ctx, field)
			case "flex_stop_times":
				return ec.fieldContext_Trip_flex_stop_times(ctx, field)
			case "frequencies":
				return ec.fieldContext_Trip_frequencies(ctx, field)
			case "alerts":
				return ec.fieldContext_Trip_alerts(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_Trip_schedule_relationship(ctx, field)
			case "timestamp":
				return ec.fieldContext_Trip_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trip", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_trips_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_locations(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Locations(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.LocationFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Location)
	fc.Result = res
	return ec.marshalNLocation2githubcominterlineiotransitlandlibservermodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "location_id":
				return ec.fieldContext_Location_location_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Location_stop_name(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Location_stop_desc(ctx, field)
			case "zone_id":
				return ec.fieldContext_Location_zone_id(ctx, field)
			case "stop_url":
				return ec.fieldContext_Location_stop_url(ctx, field)
			case "geometry":
				return ec.fieldContext_Location_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Location_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Location_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Location_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Location_stop_times(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_locations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_booking_rules(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_booking_rules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().BookingRules(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.BookingRuleFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.BookingRule)
	fc.Result = res
	return ec.marshalNBookingRule2githubcominterlineiotransitlandlibservermodelBookingRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_booking_rules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BookingRule_id(ctx, field)
			case "booking_rule_id":
				return ec.fieldContext_BookingRule_booking_rule_id(ctx, field)
			case "booking_type":
				return ec.fieldContext_BookingRule_booking_type(ctx, field)
			case "prior_notice_duration_min":
				return ec.fieldContext_BookingRule_prior_notice_duration_min(ctx, field)
			case "prior_notice_duration_max":
				return ec.fieldContext_BookingRule_prior_notice_duration_max(ctx, field)
			case "prior_notice_last_day":
				return ec.fieldContext_BookingRule_prior_notice_last_day(ctx, field)
			case "prior_notice_last_time":
				return ec.fieldContext_BookingRule_prior_notice_last_time(ctx, field)
			case "prior_notice_start_day":
				return ec.fieldContext_BookingRule_prior_notice_start_day(ctx, field)
			case "prior_notice_start_time":
				return ec.fieldContext_BookingRule_prior_notice_start_time(ctx, field)
			case "prior_notice_service":
				return ec.fieldContext_BookingRule_prior_notice_service(ctx, field)
			case "message":
				return ec.fieldContext_BookingRule_message(ctx, field)
			case "pickup_message":
				return ec.fieldContext_BookingRule_pickup_message(ctx, field)
			case "drop_off_message":
				return ec.fieldContext_BookingRule_drop_off_message(ctx, field)
			case "phone_number":
				return ec.fieldContext_BookingRule_phone_number(ctx, field)
			case "info_url":
				return ec.fieldContext_BookingRule_info_url(ctx, field)
			case "booking_url":
				return ec.fieldContext_BookingRule_booking_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_BookingRule_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_BookingRule_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_BookingRule_feed_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookingRule", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_booking_rules_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_location_groups(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_location_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().LocationGroups(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.LocationGroupFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.LocationGroup)
	fc.Result = res
	return ec.marshalNLocationGroup2githubcominterlineiotransitlandlibservermodelLocationGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_location_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationGroup_id(ctx, field)
			case "location_group_id":
				return ec.fieldContext_LocationGroup_location_group_id(ctx, field)
			case "location_group_name":
				return ec.fieldContext_LocationGroup_location_group_name(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_LocationGroup_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_LocationGroup_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_LocationGroup_feed_version(ctx, field)
			case "stops":
				return ec.fieldContext_LocationGroup_stops(ctx, field)
			case "stop_times":
				return ec.fieldContext_LocationGroup_stop_times(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationGroup", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_location_groups_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_feed_infos(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_feed_infos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().FeedInfos(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedInfo)
	fc.Result = res
	return ec.marshalNFeedInfo2githubcominterlineiotransitlandlibservermodelFeedInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_feed_infos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedInfo_id(ctx, field)
			case "feed_publisher_name":
				return ec.fieldContext_FeedInfo_feed_publisher_name(ctx, field)
			case "feed_publisher_url":
				return ec.fieldContext_FeedInfo_feed_publisher_url(ctx, field)
			case "feed_lang":
				return ec.fieldContext_FeedInfo_feed_lang(ctx, field)
			case "default_lang":
				return ec.fieldContext_FeedInfo_default_lang(ctx, field)
			case "feed_version":
				return ec.fieldContext_FeedInfo_feed_version(ctx, field)
			case "feed_start_date":
				return ec.fieldContext_FeedInfo_feed_start_date(ctx, field)
			case "feed_end_date":
				return ec.fieldContext_FeedInfo_feed_end_date(ctx, field)
			case "feed_contact_email":
				return ec.fieldContext_FeedInfo_feed_contact_email(ctx, field)
			case "feed_contact_url":
				return ec.fieldContext_FeedInfo_feed_contact_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_feed_infos_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_validation_reports(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_validation_reports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().ValidationReports(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.ValidationReportFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ValidationReport)
	fc.Result = res
	return ec.marshalOValidationReport2githubcominterlineiotransitlandlibservermodelValidationReport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_validation_reports(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ValidationReport_id(ctx, field)
			case "reported_at":
				return ec.fieldContext_ValidationReport_reported_at(ctx, field)
			case "reported_at_local":
				return ec.fieldContext_ValidationReport_reported_at_local(ctx, field)
			case "reported_at_local_timezone":
				return ec.fieldContext_ValidationReport_reported_at_local_timezone(ctx, field)
			case "success":
				return ec.fieldContext_ValidationReport_success(ctx, field)
			case "failure_reason":
				return ec.fieldContext_ValidationReport_failure_reason(ctx, field)
			case "includes_static":
				return ec.fieldContext_ValidationReport_includes_static(ctx, field)
			case "includes_rt":
				return ec.fieldContext_ValidationReport_includes_rt(ctx, field)
			case "validator":
				return ec.fieldContext_ValidationReport_validator(ctx, field)
			case "validator_version":
				return ec.fieldContext_ValidationReport_validator_version(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationReport_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ValidationReport_warnings(ctx, field)
			case "details":
				return ec.fieldContext_ValidationReport_details(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationReport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_validation_reports_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_segments(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_segments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Segments(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Segment)
	fc.Result = res
	return ec.marshalOSegment2githubcominterlineiotransitlandlibservermodelSegment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_segments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Segment_id(ctx, field)
			case "way_id":
				return ec.fieldContext_Segment_way_id(ctx, field)
			case "geometry":
				return ec.fieldContext_Segment_geometry(ctx, field)
			case "segment_patterns":
				return ec.fieldContext_Segment_segment_patterns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Segment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_segments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionDeleteResult_success(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionDeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionDeleteResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionDeleteResult_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFetchResult_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFetchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFetchResult_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalOFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFetchResult_feed_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFetchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "service_window":
				return ec.fieldContext_FeedVersion_service_window(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "locations":
				return ec.fieldContext_FeedVersion_locations(ctx, field)
			case "booking_rules":
				return ec.fieldContext_FeedVersion_booking_rules(ctx, field)
			case "location_groups":
				return ec.fieldContext_FeedVersion_location_groups(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			case "validation_reports":
				return ec.fieldContext_FeedVersion_validation_reports(ctx, field)
			case "segments":
				return ec.fieldContext_FeedVersion_segments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFetchResult_fetch_error(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFetchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFetchResult_fetch_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchError, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFetchResult_fetch_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFetchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFetchResult_found_sha1(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFetchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFetchResult_found_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FoundSha1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFetchResult_found_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFetchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFetchResult_found_dir_sha1(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFetchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFetchResult_found_dir_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FoundDirSha1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFetchResult_found_dir_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFetchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_rows(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_rows(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_rows(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_sha1(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_header(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_header(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Header, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_header(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_csv_like(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_csv_like(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CSVLike, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_csv_like(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_size(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_values_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_values_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValuesCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Counts)
	fc.Result = res
	return ec.marshalNCounts2githubcominterlineiotransitlandlibttCounts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_values_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Counts does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_values_unique(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_values_unique(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValuesUnique, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Counts)
	fc.Result = res
	return ec.marshalNCounts2githubcominterlineiotransitlandlibttCounts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_values_unique(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Counts does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_in_progress(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_in_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InProgress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_in_progress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_success(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_schedule_removed(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_schedule_removed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduleRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_schedule_removed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_exception_log(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_exception_log(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExceptionLog, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_exception_log(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_skip_entity_error_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_skip_entity_error_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersionGtfsImport().SkipEntityErrorCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(any)
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_skip_entity_error_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_entity_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_entity_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersionGtfsImport().EntityCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(any)
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_entity_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_warning_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_warning_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersionGtfsImport().WarningCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(any)
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_warning_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_skip_entity_reference_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_skip_entity_reference_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersionGtfsImport().SkipEntityReferenceCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(any)
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_skip_entity_reference_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_skip_entity_filter_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_skip_entity_filter_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersionGtfsImport().SkipEntityFilterCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(any)
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_skip_entity_filter_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_skip_entity_marked_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_skip_entity_marked_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersionGtfsImport().SkipEntityMarkedCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(any)
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_skip_entity_marked_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_interpolated_stop_time_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_interpolated_stop_time_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterpolatedStopTimeCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_interpolated_stop_time_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_created_at(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_created_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_updated_at(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_updated_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionImportResult_success(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionImportResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionImportResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionImportResult_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_start_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_start_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_end_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_end_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_end_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_monday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_monday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Monday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_monday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_tuesday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_tuesday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tuesday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_tuesday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_wednesday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_wednesday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Wednesday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_wednesday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_thursday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_thursday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Thursday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_thursday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_friday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_friday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Friday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_friday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_saturday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_saturday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Saturday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_saturday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_sunday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_sunday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sunday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_sunday(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceWindow_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceWindow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceWindow_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceWindow_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceWindow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceWindow_feed_start_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceWindow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceWindow_feed_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedStartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceWindow_feed_start_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceWindow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceWindow_feed_end_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceWindow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceWindow_feed_end_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedEndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceWindow_feed_end_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceWindow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceWindow_earliest_calendar_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceWindow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceWindow_earliest_calendar_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EarliestCalendarDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceWindow_earliest_calendar_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceWindow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceWindow_latest_calendar_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceWindow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceWindow_latest_calendar_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestCalendarDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceWindow_latest_calendar_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceWindow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceWindow_fallback_week(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceWindow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceWindow_fallback_week(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FallbackWeek, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceWindow_fallback_week(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceWindow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceWindow_default_timezone(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceWindow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceWindow_default_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultTimezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceWindow_default_timezone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceWindow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionUnimportResult_success(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionUnimportResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionUnimportResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionUnimportResult_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionUnimportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_arrival_time(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_arrival_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArrivalTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_arrival_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_departure_time(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_departure_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DepartureTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_departure_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_stop_sequence(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_stop_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopSequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_stop_sequence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_stop_headsign(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_stop_headsign(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopHeadsign, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_stop_headsign(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_pickup_type(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_pickup_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PickupType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_pickup_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_drop_off_type(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_drop_off_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DropOffType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_drop_off_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_timepoint(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_timepoint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timepoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_timepoint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_continuous_drop_off(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_continuous_drop_off(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContinuousDropOff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_continuous_drop_off(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_continuous_pickup(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_continuous_pickup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContinuousPickup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_continuous_pickup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_shape_dist_traveled(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_shape_dist_traveled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShapeDistTraveled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_shape_dist_traveled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_interpolated(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_interpolated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interpolated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_interpolated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_start_pickup_drop_off_window(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_start_pickup_drop_off_window(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartPickupDropOffWindow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_start_pickup_drop_off_window(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_end_pickup_drop_off_window(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_end_pickup_drop_off_window(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndPickupDropOffWindow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_end_pickup_drop_off_window(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_pickup_booking_rule(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_pickup_booking_rule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FlexStopTime().PickupBookingRule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BookingRule)
	fc.Result = res
	return ec.marshalOBookingRule2githubcominterlineiotransitlandlibservermodelBookingRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_pickup_booking_rule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BookingRule_id(ctx, field)
			case "booking_rule_id":
				return ec.fieldContext_BookingRule_booking_rule_id(ctx, field)
			case "booking_type":
				return ec.fieldContext_BookingRule_booking_type(ctx, field)
			case "prior_notice_duration_min":
				return ec.fieldContext_BookingRule_prior_notice_duration_min(ctx, field)
			case "prior_notice_duration_max":
				return ec.fieldContext_BookingRule_prior_notice_duration_max(ctx, field)
			case "prior_notice_last_day":
				return ec.fieldContext_BookingRule_prior_notice_last_day(ctx, field)
			case "prior_notice_last_time":
				return ec.fieldContext_BookingRule_prior_notice_last_time(ctx, field)
			case "prior_notice_start_day":
				return ec.fieldContext_BookingRule_prior_notice_start_day(ctx, field)
			case "prior_notice_start_time":
				return ec.fieldContext_BookingRule_prior_notice_start_time(ctx, field)
			case "prior_notice_service":
				return ec.fieldContext_BookingRule_prior_notice_service(ctx, field)
			case "message":
				return ec.fieldContext_BookingRule_message(ctx, field)
			case "pickup_message":
				return ec.fieldContext_BookingRule_pickup_message(ctx, field)
			case "drop_off_message":
				return ec.fieldContext_BookingRule_drop_off_message(ctx, field)
			case "phone_number":
				return ec.fieldContext_BookingRule_phone_number(ctx, field)
			case "info_url":
				return ec.fieldContext_BookingRule_info_url(ctx, field)
			case "booking_url":
				return ec.fieldContext_BookingRule_booking_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_BookingRule_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_BookingRule_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_BookingRule_feed_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookingRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_drop_off_booking_rule(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_drop_off_booking_rule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FlexStopTime().DropOffBookingRule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BookingRule)
	fc.Result = res
	return ec.marshalOBookingRule2githubcominterlineiotransitlandlibservermodelBookingRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_drop_off_booking_rule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BookingRule_id(ctx, field)
			case "booking_rule_id":
				return ec.fieldContext_BookingRule_booking_rule_id(ctx, field)
			case "booking_type":
				return ec.fieldContext_BookingRule_booking_type(ctx, field)
			case "prior_notice_duration_min":
				return ec.fieldContext_BookingRule_prior_notice_duration_min(ctx, field)
			case "prior_notice_duration_max":
				return ec.fieldContext_BookingRule_prior_notice_duration_max(ctx, field)
			case "prior_notice_last_day":
				return ec.fieldContext_BookingRule_prior_notice_last_day(ctx, field)
			case "prior_notice_last_time":
				return ec.fieldContext_BookingRule_prior_notice_last_time(ctx, field)
			case "prior_notice_start_day":
				return ec.fieldContext_BookingRule_prior_notice_start_day(ctx, field)
			case "prior_notice_start_time":
				return ec.fieldContext_BookingRule_prior_notice_start_time(ctx, field)
			case "prior_notice_service":
				return ec.fieldContext_BookingRule_prior_notice_service(ctx, field)
			case "message":
				return ec.fieldContext_BookingRule_message(ctx, field)
			case "pickup_message":
				return ec.fieldContext_BookingRule_pickup_message(ctx, field)
			case "drop_off_message":
				return ec.fieldContext_BookingRule_drop_off_message(ctx, field)
			case "phone_number":
				return ec.fieldContext_BookingRule_phone_number(ctx, field)
			case "info_url":
				return ec.fieldContext_BookingRule_info_url(ctx, field)
			case "booking_url":
				return ec.fieldContext_BookingRule_booking_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_BookingRule_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_BookingRule_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_BookingRule_feed_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookingRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_location(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FlexStopTime().Location(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalOLocation2githubcominterlineiotransitlandlibservermodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_location(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "location_id":
				return ec.fieldContext_Location_location_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Location_stop_name(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Location_stop_desc(ctx, field)
			case "zone_id":
				return ec.fieldContext_Location_zone_id(ctx, field)
			case "stop_url":
				return ec.fieldContext_Location_stop_url(ctx, field)
			case "geometry":
				return ec.fieldContext_Location_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Location_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Location_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Location_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Location_stop_times(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_location_group(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_location_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FlexStopTime().LocationGroup(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LocationGroup)
	fc.Result = res
	return ec.marshalOLocationGroup2githubcominterlineiotransitlandlibservermodelLocationGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_location_group(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationGroup_id(ctx, field)
			case "location_group_id":
				return ec.fieldContext_LocationGroup_location_group_id(ctx, field)
			case "location_group_name":
				return ec.fieldContext_LocationGroup_location_group_name(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_LocationGroup_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_LocationGroup_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_LocationGroup_feed_version(ctx, field)
			case "stops":
				return ec.fieldContext_LocationGroup_stops(ctx, field)
			case "stop_times":
				return ec.fieldContext_LocationGroup_stop_times(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_trip(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_trip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FlexStopTime().Trip(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Trip)
	fc.Result = res
	return ec.marshalNTrip2githubcominterlineiotransitlandlibservermodelTrip(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_trip(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trip_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_Trip_trip_id(ctx, field)
			case "trip_headsign":
				return ec.fieldContext_Trip_trip_headsign(ctx, field)
			case "trip_short_name":
				return ec.fieldContext_Trip_trip_short_name(ctx, field)
			case "direction_id":
				return ec.fieldContext_Trip_direction_id(ctx, field)
			case "block_id":
				return ec.fieldContext_Trip_block_id(ctx, field)
			case "wheelchair_accessible":
				return ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
			case "bikes_allowed":
				return ec.fieldContext_Trip_bikes_allowed(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_Trip_stop_pattern_id(ctx, field)
			case "calendar":
				return ec.fieldContext_Trip_calendar(ctx, field)
			case "route":
				return ec.fieldContext_Trip_route(ctx, field)
			case "shape":
				return ec.fieldContext_Trip_shape(ctx, field)
			case "feed_version":
				return ec.fieldContext_Trip_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Trip_stop_times(ctx, field)
			case "flex_stop_times":
				return ec.fieldContext_Trip_flex_stop_times(ctx, field)
			case "frequencies":
				return ec.fieldContext_Trip_frequencies(ctx, field)
			case "alerts":
				return ec.fieldContext_Trip_alerts(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_Trip_schedule_relationship(ctx, field)
			case "timestamp":
				return ec.fieldContext_Trip_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trip", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_arrival(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_arrival(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FlexStopTime().Arrival(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.StopTimeEvent)
	fc.Result = res
	return ec.marshalNStopTimeEvent2githubcominterlineiotransitlandlibservermodelStopTimeEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_arrival(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stop_timezone":
				return ec.fieldContext_StopTimeEvent_stop_timezone(ctx, field)
			case "estimated_utc":
				return ec.fieldContext_StopTimeEvent_estimated_utc(ctx, field)
			case "estimated_unix":
				return ec.fieldContext_StopTimeEvent_estimated_unix(ctx, field)
			case "estimated_local":
				return ec.fieldContext_StopTimeEvent_estimated_local(ctx, field)
			case "estimated_delay":
				return ec.fieldContext_StopTimeEvent_estimated_delay(ctx, field)
			case "estimated":
				return ec.fieldContext_StopTimeEvent_estimated(ctx, field)
			case "scheduled_utc":
				return ec.fieldContext_StopTimeEvent_scheduled_utc(ctx, field)
			case "scheduled_unix":
				return ec.fieldContext_StopTimeEvent_scheduled_unix(ctx, field)
			case "scheduled_local":
				return ec.fieldContext_StopTimeEvent_scheduled_local(ctx, field)
			case "scheduled":
				return ec.fieldContext_StopTimeEvent_scheduled(ctx, field)
			case "time_utc":
				return ec.fieldContext_StopTimeEvent_time_utc(ctx, field)
			case "time_unix":
				return ec.fieldContext_StopTimeEvent_time_unix(ctx, field)
			case "delay":
				return ec.fieldContext_StopTimeEvent_delay(ctx, field)
			case "uncertainty":
				return ec.fieldContext_StopTimeEvent_uncertainty(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTimeEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_departure(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_departure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FlexStopTime().Departure(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.StopTimeEvent)
	fc.Result = res
	return ec.marshalNStopTimeEvent2githubcominterlineiotransitlandlibservermodelStopTimeEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_departure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stop_timezone":
				return ec.fieldContext_StopTimeEvent_stop_timezone(ctx, field)
			case "estimated_utc":
				return ec.fieldContext_StopTimeEvent_estimated_utc(ctx, field)
			case "estimated_unix":
				return ec.fieldContext_StopTimeEvent_estimated_unix(ctx, field)
			case "estimated_local":
				return ec.fieldContext_StopTimeEvent_estimated_local(ctx, field)
			case "estimated_delay":
				return ec.fieldContext_StopTimeEvent_estimated_delay(ctx, field)
			case "estimated":
				return ec.fieldContext_StopTimeEvent_estimated(ctx, field)
			case "scheduled_utc":
				return ec.fieldContext_StopTimeEvent_scheduled_utc(ctx, field)
			case "scheduled_unix":
				return ec.fieldContext_StopTimeEvent_scheduled_unix(ctx, field)
			case "scheduled_local":
				return ec.fieldContext_StopTimeEvent_scheduled_local(ctx, field)
			case "scheduled":
				return ec.fieldContext_StopTimeEvent_scheduled(ctx, field)
			case "time_utc":
				return ec.fieldContext_StopTimeEvent_time_utc(ctx, field)
			case "time_unix":
				return ec.fieldContext_StopTimeEvent_time_unix(ctx, field)
			case "delay":
				return ec.fieldContext_StopTimeEvent_delay(ctx, field)
			case "uncertainty":
				return ec.fieldContext_StopTimeEvent_uncertainty(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTimeEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_service_date(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_service_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_service_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_date(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlexStopTime_schedule_relationship(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlexStopTime_schedule_relationship(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FlexStopTime().ScheduleRelationship(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ScheduleRelationship)
	fc.Result = res
	return ec.marshalOScheduleRelationship2githubcominterlineiotransitlandlibservermodelScheduleRelationship(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlexStopTime_schedule_relationship(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlexStopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScheduleRelationship does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Frequency_id(ctx context.Context, field graphql.CollectedField, obj *model.Frequency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Frequency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Frequency_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Frequency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Frequency_start_time(ctx context.Context, field graphql.CollectedField, obj *model.Frequency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Frequency_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Seconds)
	fc.Result = res
	return ec.marshalNSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Frequency_start_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Frequency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Frequency_end_time(ctx context.Context, field graphql.CollectedField, obj *model.Frequency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Frequency_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Seconds)
	fc.Result = res
	return ec.marshalNSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Frequency_end_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Frequency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Frequency_headway_secs(ctx context.Context, field graphql.CollectedField, obj *model.Frequency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Frequency_headway_secs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadwaySecs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Frequency_headway_secs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Frequency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Frequency_exact_times(ctx context.Context, field graphql.CollectedField, obj *model.Frequency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Frequency_exact_times(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExactTimes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Frequency_exact_times(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Frequency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsAlertTime_start(ctx context.Context, field graphql.CollectedField, obj *model.GbfsAlertTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsAlertTime_start(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsAlertTime_start(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsAlertTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsAlertTime_end(ctx context.Context, field graphql.CollectedField, obj *model.GbfsAlertTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsAlertTime_end(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.End, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsAlertTime_end(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsAlertTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsBrandAsset_brand_last_modified(ctx context.Context, field graphql.CollectedField, obj *model.GbfsBrandAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsBrandAsset_brand_last_modified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BrandLastModified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsBrandAsset_brand_last_modified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsBrandAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsBrandAsset_brand_terms_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsBrandAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsBrandAsset_brand_terms_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BrandTermsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsBrandAsset_brand_terms_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsBrandAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsBrandAsset_brand_image_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsBrandAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsBrandAsset_brand_image_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BrandImageURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsBrandAsset_brand_image_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsBrandAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsBrandAsset_brand_image_url_dark(ctx context.Context, field graphql.CollectedField, obj *model.GbfsBrandAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsBrandAsset_brand_image_url_dark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BrandImageURLDark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsBrandAsset_brand_image_url_dark(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsBrandAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsBrandAsset_color(ctx context.Context, field graphql.CollectedField, obj *model.GbfsBrandAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsBrandAsset_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsBrandAsset_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsBrandAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFeed_system_information(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFeed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFeed_system_information(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemInformation(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsSystemInformation)
	fc.Result = res
	return ec.marshalOGbfsSystemInformation2githubcominterlineiotransitlandlibservermodelGbfsSystemInformation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFeed_system_information(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFeed",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "system_id":
				return ec.fieldContext_GbfsSystemInformation_system_id(ctx, field)
			case "language":
				return ec.fieldContext_GbfsSystemInformation_language(ctx, field)
			case "name":
				return ec.fieldContext_GbfsSystemInformation_name(ctx, field)
			case "short_name":
				return ec.fieldContext_GbfsSystemInformation_short_name(ctx, field)
			case "operator":
				return ec.fieldContext_GbfsSystemInformation_operator(ctx, field)
			case "url":
				return ec.fieldContext_GbfsSystemInformation_url(ctx, field)
			case "purchase_url":
				return ec.fieldContext_GbfsSystemInformation_purchase_url(ctx, field)
			case "start_date":
				return ec.fieldContext_GbfsSystemInformation_start_date(ctx, field)
			case "phone_number":
				return ec.fieldContext_GbfsSystemInformation_phone_number(ctx, field)
			case "email":
				return ec.fieldContext_GbfsSystemInformation_email(ctx, field)
			case "feed_contact_email":
				return ec.fieldContext_GbfsSystemInformation_feed_contact_email(ctx, field)
			case "timezone":
				return ec.fieldContext_GbfsSystemInformation_timezone(ctx, field)
			case "license_url":
				return ec.fieldContext_GbfsSystemInformation_license_url(ctx, field)
			case "terms_url":
				return ec.fieldContext_GbfsSystemInformation_terms_url(ctx, field)
			case "terms_last_updated":
				return ec.fieldContext_GbfsSystemInformation_terms_last_updated(ctx, field)
			case "privacy_url":
				return ec.fieldContext_GbfsSystemInformation_privacy_url(ctx, field)
			case "privacy_last_updated":
				return ec.fieldContext_GbfsSystemInformation_privacy_last_updated(ctx, field)
			case "brand_assets":
				return ec.fieldContext_GbfsSystemInformation_brand_assets(ctx, field)
			case "rental_apps":
				return ec.fieldContext_GbfsSystemInformation_rental_apps(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemInformation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFeed_station_information(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFeed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFeed_station_information(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StationInformation(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsStationInformation)
	fc.Result = res
	return ec.marshalOGbfsStationInformation2githubcominterlineiotransitlandlibservermodelGbfsStationInformation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFeed_station_information(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFeed",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "station_id":
				return ec.fieldContext_GbfsStationInformation_station_id(ctx, field)
			case "name":
				return ec.fieldContext_GbfsStationInformation_name(ctx, field)
			case "short_name":
				return ec.fieldContext_GbfsStationInformation_short_name(ctx, field)
			case "lat":
				return ec.fieldContext_GbfsStationInformation_lat(ctx, field)
			case "lon":
				return ec.fieldContext_GbfsStationInformation_lon(ctx, field)
			case "address":
				return ec.fieldContext_GbfsStationInformation_address(ctx, field)
			case "cross_street":
				return ec.fieldContext_GbfsStationInformation_cross_street(ctx, field)
			case "post_code":
				return ec.fieldContext_GbfsStationInformation_post_code(ctx, field)
			case "rental_methods":
				return ec.fieldContext_GbfsStationInformation_rental_methods(ctx, field)
			case "is_virtual_station":
				return ec.fieldContext_GbfsStationInformation_is_virtual_station(ctx, field)
			case "station_area":
				return ec.fieldContext_GbfsStationInformation_station_area(ctx, field)
			case "parking_type":
				return ec.fieldContext_GbfsStationInformation_parking_type(ctx, field)
			case "parking_hoop":
				return ec.fieldContext_GbfsStationInformation_parking_hoop(ctx, field)
			case "contact_phone":
				return ec.fieldContext_GbfsStationInformation_contact_phone(ctx, field)
			case "capacity":
				return ec.fieldContext_GbfsStationInformation_capacity(ctx, field)
			case "is_valet_station":
				return ec.fieldContext_GbfsStationInformation_is_valet_station(ctx, field)
			case "is_charging_station":
				return ec.fieldContext_GbfsStationInformation_is_charging_station(ctx, field)
			case "feed":
				return ec.fieldContext_GbfsStationInformation_feed(ctx, field)
			case "region":
				return ec.fieldContext_GbfsStationInformation_region(ctx, field)
			case "status":
				return ec.fieldContext_GbfsStationInformation_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsStationInformation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFeed_rental_hours(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFeed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFeed_rental_hours(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RentalHours(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsSystemHour)
	fc.Result = res
	return ec.marshalOGbfsSystemHour2githubcominterlineiotransitlandlibservermodelGbfsSystemHour(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFeed_rental_hours(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFeed",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user_types":
				return ec.fieldContext_GbfsSystemHour_user_types(ctx, field)
			case "days":
				return ec.fieldContext_GbfsSystemHour_days(ctx, field)
			case "start_time":
				return ec.fieldContext_GbfsSystemHour_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_GbfsSystemHour_end_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemHour", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFeed_calendars(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFeed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFeed_calendars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Calendars(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsSystemCalendar)
	fc.Result = res
	return ec.marshalOGbfsSystemCalendar2githubcominterlineiotransitlandlibservermodelGbfsSystemCalendar(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFeed_calendars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFeed",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "start_month":
				return ec.fieldContext_GbfsSystemCalendar_start_month(ctx, field)
			case "start_day":
				return ec.fieldContext_GbfsSystemCalendar_start_day(ctx, field)
			case "start_year":
				return ec.fieldContext_GbfsSystemCalendar_start_year(ctx, field)
			case "end_month":
				return ec.fieldContext_GbfsSystemCalendar_end_month(ctx, field)
			case "end_day":
				return ec.fieldContext_GbfsSystemCalendar_end_day(ctx, field)
			case "end_year":
				return ec.fieldContext_GbfsSystemCalendar_end_year(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemCalendar", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFeed_alerts(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFeed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFeed_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alerts(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsSystemAlert)
	fc.Result = res
	return ec.marshalOGbfsSystemAlert2githubcominterlineiotransitlandlibservermodelGbfsSystemAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFeed_alerts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFeed",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alert_id":
				return ec.fieldContext_GbfsSystemAlert_alert_id(ctx, field)
			case "type":
				return ec.fieldContext_GbfsSystemAlert_type(ctx, field)
			case "url":
				return ec.fieldContext_GbfsSystemAlert_url(ctx, field)
			case "summary":
				return ec.fieldContext_GbfsSystemAlert_summary(ctx, field)
			case "description":
				return ec.fieldContext_GbfsSystemAlert_description(ctx, field)
			case "last_updated":
				return ec.fieldContext_GbfsSystemAlert_last_updated(ctx, field)
			case "times":
				return ec.fieldContext_GbfsSystemAlert_times(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemAlert", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_bike_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_bike_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BikeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_bike_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_lat(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_lat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_lat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_lon(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_lon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_lon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_is_reserved(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_is_reserved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsReserved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_is_reserved(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_is_disabled(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_is_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_is_disabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_last_reported(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_last_reported(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastReported, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_last_reported(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_current_range_meters(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_current_range_meters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRangeMeters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_current_range_meters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_current_fuel_percent(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_current_fuel_percent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentFuelPercent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_current_fuel_percent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_vehicle_equipment(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_vehicle_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleEquipment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Strings)
	fc.Result = res
	return ec.marshalOStrings2githubcominterlineiotransitlandlibttStrings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_vehicle_equipment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Strings does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_available_until(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_available_until(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailableUntil, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_available_until(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_station(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_station(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Station(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsStationInformation)
	fc.Result = res
	return ec.marshalOGbfsStationInformation2githubcominterlineiotransitlandlibservermodelGbfsStationInformation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_station(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "station_id":
				return ec.fieldContext_GbfsStationInformation_station_id(ctx, field)
			case "name":
				return ec.fieldContext_GbfsStationInformation_name(ctx, field)
			case "short_name":
				return ec.fieldContext_GbfsStationInformation_short_name(ctx, field)
			case "lat":
				return ec.fieldContext_GbfsStationInformation_lat(ctx, field)
			case "lon":
				return ec.fieldContext_GbfsStationInformation_lon(ctx, field)
			case "address":
				return ec.fieldContext_GbfsStationInformation_address(ctx, field)
			case "cross_street":
				return ec.fieldContext_GbfsStationInformation_cross_street(ctx, field)
			case "post_code":
				return ec.fieldContext_GbfsStationInformation_post_code(ctx, field)
			case "rental_methods":
				return ec.fieldContext_GbfsStationInformation_rental_methods(ctx, field)
			case "is_virtual_station":
				return ec.fieldContext_GbfsStationInformation_is_virtual_station(ctx, field)
			case "station_area":
				return ec.fieldContext_GbfsStationInformation_station_area(ctx, field)
			case "parking_type":
				return ec.fieldContext_GbfsStationInformation_parking_type(ctx, field)
			case "parking_hoop":
				return ec.fieldContext_GbfsStationInformation_parking_hoop(ctx, field)
			case "contact_phone":
				return ec.fieldContext_GbfsStationInformation_contact_phone(ctx, field)
			case "capacity":
				return ec.fieldContext_GbfsStationInformation_capacity(ctx, field)
			case "is_valet_station":
				return ec.fieldContext_GbfsStationInformation_is_valet_station(ctx, field)
			case "is_charging_station":
				return ec.fieldContext_GbfsStationInformation_is_charging_station(ctx, field)
			case "feed":
				return ec.fieldContext_GbfsStationInformation_feed(ctx, field)
			case "region":
				return ec.fieldContext_GbfsStationInformation_region(ctx, field)
			case "status":
				return ec.fieldContext_GbfsStationInformation_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsStationInformation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_home_station(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_home_station(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeStation(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsStationInformation)
	fc.Result = res
	return ec.marshalOGbfsStationInformation2githubcominterlineiotransitlandlibservermodelGbfsStationInformation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_home_station(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "station_id":
				return ec.fieldContext_GbfsStationInformation_station_id(ctx, field)
			case "name":
				return ec.fieldContext_GbfsStationInformation_name(ctx, field)
			case "short_name":
				return ec.fieldContext_GbfsStationInformation_short_name(ctx, field)
			case "lat":
				return ec.fieldContext_GbfsStationInformation_lat(ctx, field)
			case "lon":
				return ec.fieldContext_GbfsStationInformation_lon(ctx, field)
			case "address":
				return ec.fieldContext_GbfsStationInformation_address(ctx, field)
			case "cross_street":
				return ec.fieldContext_GbfsStationInformation_cross_street(ctx, field)
			case "post_code":
				return ec.fieldContext_GbfsStationInformation_post_code(ctx, field)
			case "rental_methods":
				return ec.fieldContext_GbfsStationInformation_rental_methods(ctx, field)
			case "is_virtual_station":
				return ec.fieldContext_GbfsStationInformation_is_virtual_station(ctx, field)
			case "station_area":
				return ec.fieldContext_GbfsStationInformation_station_area(ctx, field)
			case "parking_type":
				return ec.fieldContext_GbfsStationInformation_parking_type(ctx, field)
			case "parking_hoop":
				return ec.fieldContext_GbfsStationInformation_parking_hoop(ctx, field)
			case "contact_phone":
				return ec.fieldContext_GbfsStationInformation_contact_phone(ctx, field)
			case "capacity":
				return ec.fieldContext_GbfsStationInformation_capacity(ctx, field)
			case "is_valet_station":
				return ec.fieldContext_GbfsStationInformation_is_valet_station(ctx, field)
			case "is_charging_station":
				return ec.fieldContext_GbfsStationInformation_is_charging_station(ctx, field)
			case "feed":
				return ec.fieldContext_GbfsStationInformation_feed(ctx, field)
			case "region":
				return ec.fieldContext_GbfsStationInformation_region(ctx, field)
			case "status":
				return ec.fieldContext_GbfsStationInformation_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsStationInformation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_pricing_plan(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_pricing_plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PricingPlan(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsSystemPricingPlan)
	fc.Result = res
	return ec.marshalOGbfsSystemPricingPlan2githubcominterlineiotransitlandlibservermodelGbfsSystemPricingPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_pricing_plan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "plan_id":
				return ec.fieldContext_GbfsSystemPricingPlan_plan_id(ctx, field)
			case "url":
				return ec.fieldContext_GbfsSystemPricingPlan_url(ctx, field)
			case "name":
				return ec.fieldContext_GbfsSystemPricingPlan_name(ctx, field)
			case "currency":
				return ec.fieldContext_GbfsSystemPricingPlan_currency(ctx, field)
			case "price":
				return ec.fieldContext_GbfsSystemPricingPlan_price(ctx, field)
			case "is_taxable":
				return ec.fieldContext_GbfsSystemPricingPlan_is_taxable(ctx, field)
			case "description":
				return ec.fieldContext_GbfsSystemPricingPlan_description(ctx, field)
			case "surge_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_surge_pricing(ctx, field)
			case "per_km_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_per_km_pricing(ctx, field)
			case "per_min_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_per_min_pricing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemPricingPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_vehicle_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_vehicle_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsVehicleType)
	fc.Result = res
	return ec.marshalOGbfsVehicleType2githubcominterlineiotransitlandlibservermodelGbfsVehicleType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_vehicle_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "vehicle_type_id":
				return ec.fieldContext_GbfsVehicleType_vehicle_type_id(ctx, field)
			case "form_factor":
				return ec.fieldContext_GbfsVehicleType_form_factor(ctx, field)
			case "rider_capacity":
				return ec.fieldContext_GbfsVehicleType_rider_capacity(ctx, field)
			case "cargo_volume_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_volume_capacity(ctx, field)
			case "cargo_load_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_load_capacity(ctx, field)
			case "propulsion_type":
				return ec.fieldContext_GbfsVehicleType_propulsion_type(ctx, field)
			case "eco_label":
				return ec.fieldContext_GbfsVehicleType_eco_label(ctx, field)
			case "country_code":
				return ec.fieldContext_GbfsVehicleType_country_code(ctx, field)
			case "eco_sticker":
				return ec.fieldContext_GbfsVehicleType_eco_sticker(ctx, field)
			case "max_range_meters":
				return ec.fieldContext_GbfsVehicleType_max_range_meters(ctx, field)
			case "name":
				return ec.fieldContext_GbfsVehicleType_name(ctx, field)
			case "vehicle_accessories":
				return ec.fieldContext_GbfsVehicleType_vehicle_accessories(ctx, field)
			case "gco_2_km":
				return ec.fieldContext_GbfsVehicleType_gco_2_km(ctx, field)
			case "vehicle_image":
				return ec.fieldContext_GbfsVehicleType_vehicle_image(ctx, field)
			case "make":
				return ec.fieldContext_GbfsVehicleType_make(ctx, field)
			case "model":
				return ec.fieldContext_GbfsVehicleType_model(ctx, field)
			case "color":
				return ec.fieldContext_GbfsVehicleType_color(ctx, field)
			case "wheel_count":
				return ec.fieldContext_GbfsVehicleType_wheel_count(ctx, field)
			case "max_permitted_speed":
				return ec.fieldContext_GbfsVehicleType_max_permitted_speed(ctx, field)
			case "rated_power":
				return ec.fieldContext_GbfsVehicleType_rated_power(ctx, field)
			case "default_reserve_time":
				return ec.fieldContext_GbfsVehicleType_default_reserve_time(ctx, field)
			case "return_constraint":
				return ec.fieldContext_GbfsVehicleType_return_constraint(ctx, field)
			case "default_pricing_plan":
				return ec.fieldContext_GbfsVehicleType_default_pricing_plan(ctx, field)
			case "pricing_plans":
				return ec.fieldContext_GbfsVehicleType_pricing_plans(ctx, field)
			case "rental_uris":
				return ec.fieldContext_GbfsVehicleType_rental_uris(ctx, field)
			case "vehicle_assets":
				return ec.fieldContext_GbfsVehicleType_vehicle_assets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_rental_uris(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_rental_uris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RentalUris(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsRentalUris)
	fc.Result = res
	return ec.marshalOGbfsRentalUris2githubcominterlineiotransitlandlibservermodelGbfsRentalUris(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_rental_uris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "android":
				return ec.fieldContext_GbfsRentalUris_android(ctx, field)
			case "ios":
				return ec.fieldContext_GbfsRentalUris_ios(ctx, field)
			case "web":
				return ec.fieldContext_GbfsRentalUris_web(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsRentalUris", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_feed(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_feed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Feed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsFeed)
	fc.Result = res
	return ec.marshalOGbfsFeed2githubcominterlineiotransitlandlibservermodelGbfsFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_feed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "system_information":
				return ec.fieldContext_GbfsFeed_system_information(ctx, field)
			case "station_information":
				return ec.fieldContext_GbfsFeed_station_information(ctx, field)
			case "rental_hours":
				return ec.fieldContext_GbfsFeed_rental_hours(ctx, field)
			case "calendars":
				return ec.fieldContext_GbfsFeed_calendars(ctx, field)
			case "alerts":
				return ec.fieldContext_GbfsFeed_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsFeed", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceFeature_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceFeature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceFeature_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceFeature_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceFeature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceFeature_geometry(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceFeature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceFeature_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceFeature_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceFeature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceProperty_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceProperty_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceProperty_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceProperty_start(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceProperty_start(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceProperty_start(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceProperty_end(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceProperty_end(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.End, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceProperty_end(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceProperty_rules(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceProperty_rules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rules(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsGeofenceRule)
	fc.Result = res
	return ec.marshalOGbfsGeofenceRule2githubcominterlineiotransitlandlibservermodelGbfsGeofenceRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceProperty_rules(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceProperty",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ride_allowed":
				return ec.fieldContext_GbfsGeofenceRule_ride_allowed(ctx, field)
			case "ride_through_allowed":
				return ec.fieldContext_GbfsGeofenceRule_ride_through_allowed(ctx, field)
			case "maximum_speed_kph":
				return ec.fieldContext_GbfsGeofenceRule_maximum_speed_kph(ctx, field)
			case "station_parking":
				return ec.fieldContext_GbfsGeofenceRule_station_parking(ctx, field)
			case "vehicle_type":
				return ec.fieldContext_GbfsGeofenceRule_vehicle_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsGeofenceRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceRule_ride_allowed(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceRule_ride_allowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RideAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceRule_ride_allowed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceRule_ride_through_allowed(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceRule_ride_through_allowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RideThroughAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceRule_ride_through_allowed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceRule_maximum_speed_kph(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceRule_maximum_speed_kph(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaximumSpeedKph, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceRule_maximum_speed_kph(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceRule_station_parking(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceRule_station_parking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StationParking, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceRule_station_parking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceRule_vehicle_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceRule_vehicle_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsVehicleType)
	fc.Result = res
	return ec.marshalOGbfsVehicleType2githubcominterlineiotransitlandlibservermodelGbfsVehicleType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceRule_vehicle_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceRule",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "vehicle_type_id":
				return ec.fieldContext_GbfsVehicleType_vehicle_type_id(ctx, field)
			case "form_factor":
				return ec.fieldContext_GbfsVehicleType_form_factor(ctx, field)
			case "rider_capacity":
				return ec.fieldContext_GbfsVehicleType_rider_capacity(ctx, field)
			case "cargo_volume_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_volume_capacity(ctx, field)
			case "cargo_load_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_load_capacity(ctx, field)
			case "propulsion_type":
				return ec.fieldContext_GbfsVehicleType_propulsion_type(ctx, field)
			case "eco_label":
				return ec.fieldContext_GbfsVehicleType_eco_label(ctx, field)
			case "country_code":
				return ec.fieldContext_GbfsVehicleType_country_code(ctx, field)
			case "eco_sticker":
				return ec.fieldContext_GbfsVehicleType_eco_sticker(ctx, field)
			case "max_range_meters":
				return ec.fieldContext_GbfsVehicleType_max_range_meters(ctx, field)
			case "name":
				return ec.fieldContext_GbfsVehicleType_name(ctx, field)
			case "vehicle_accessories":
				return ec.fieldContext_GbfsVehicleType_vehicle_accessories(ctx, field)
			case "gco_2_km":
				return ec.fieldContext_GbfsVehicleType_gco_2_km(ctx, field)
			case "vehicle_image":
				return ec.fieldContext_GbfsVehicleType_vehicle_image(ctx, field)
			case "make":
				return ec.fieldContext_GbfsVehicleType_make(ctx, field)
			case "model":
				return ec.fieldContext_GbfsVehicleType_model(ctx, field)
			case "color":
				return ec.fieldContext_GbfsVehicleType_color(ctx, field)
			case "wheel_count":
				return ec.fieldContext_GbfsVehicleType_wheel_count(ctx, field)
			case "max_permitted_speed":
				return ec.fieldContext_GbfsVehicleType_max_permitted_speed(ctx, field)
			case "rated_power":
				return ec.fieldContext_GbfsVehicleType_rated_power(ctx, field)
			case "default_reserve_time":
				return ec.fieldContext_GbfsVehicleType_default_reserve_time(ctx, field)
			case "return_constraint":
				return ec.fieldContext_GbfsVehicleType_return_constraint(ctx, field)
			case "default_pricing_plan":
				return ec.fieldContext_GbfsVehicleType_default_pricing_plan(ctx, field)
			case "pricing_plans":
				return ec.fieldContext_GbfsVehicleType_pricing_plans(ctx, field)
			case "rental_uris":
				return ec.fieldContext_GbfsVehicleType_rental_uris(ctx, field)
			case "vehicle_assets":
				return ec.fieldContext_GbfsVehicleType_vehicle_assets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceZone_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceZone_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceZone_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceZone_features(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceZone_features(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Features(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsGeofenceFeature)
	fc.Result = res
	return ec.marshalOGbfsGeofenceFeature2githubcominterlineiotransitlandlibservermodelGbfsGeofenceFeature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceZone_features(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceZone",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_GbfsGeofenceFeature_type(ctx, field)
			case "geometry":
				return ec.fieldContext_GbfsGeofenceFeature_geometry(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsGeofenceFeature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsPlanPrice_start(ctx context.Context, field graphql.CollectedField, obj *model.GbfsPlanPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsPlanPrice_start(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsPlanPrice_start(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsPlanPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsPlanPrice_rate(ctx context.Context, field graphql.CollectedField, obj *model.GbfsPlanPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsPlanPrice_rate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsPlanPrice_rate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsPlanPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsPlanPrice_interval(ctx context.Context, field graphql.CollectedField, obj *model.GbfsPlanPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsPlanPrice_interval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsPlanPrice_interval(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsPlanPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsPlanPrice_end(ctx context.Context, field graphql.CollectedField, obj *model.GbfsPlanPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsPlanPrice_end(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.End, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsPlanPrice_end(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsPlanPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalApp_store_uri(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalApp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalApp_store_uri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StoreURI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalApp_store_uri(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalApp",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalApp_discovery_uri(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalApp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalApp_discovery_uri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiscoveryURI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalApp_discovery_uri(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalApp",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalApps_ios(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalApps) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalApps_ios(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ios(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsRentalApp)
	fc.Result = res
	return ec.marshalOGbfsRentalApp2githubcominterlineiotransitlandlibservermodelGbfsRentalApp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalApps_ios(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalApps",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "store_uri":
				return ec.fieldContext_GbfsRentalApp_store_uri(ctx, field)
			case "discovery_uri":
				return ec.fieldContext_GbfsRentalApp_discovery_uri(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsRentalApp", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalApps_android(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalApps) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalApps_android(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Android(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsRentalApp)
	fc.Result = res
	return ec.marshalOGbfsRentalApp2githubcominterlineiotransitlandlibservermodelGbfsRentalApp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalApps_android(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalApps",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "store_uri":
				return ec.fieldContext_GbfsRentalApp_store_uri(ctx, field)
			case "discovery_uri":
				return ec.fieldContext_GbfsRentalApp_discovery_uri(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsRentalApp", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalUris_android(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalUris) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalUris_android(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Android, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalUris_android(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalUris",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalUris_ios(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalUris) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalUris_ios(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IOS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalUris_ios(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalUris",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalUris_web(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalUris) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalUris_web(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Web, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalUris_web(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalUris",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_station_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_station_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_station_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_short_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_short_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_short_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_lat(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_lat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_lat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_lon(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_lon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_lon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_address(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_address(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_cross_street(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_cross_street(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CrossStreet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_cross_street(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_post_code(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_post_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_post_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_rental_methods(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_rental_methods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RentalMethods, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Strings)
	fc.Result = res
	return ec.marshalOStrings2githubcominterlineiotransitlandlibttStrings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_rental_methods(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Strings does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_is_virtual_station(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_is_virtual_station(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsVirtualStation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_is_virtual_station(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_station_area(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_station_area(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StationArea, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_station_area(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_parking_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_parking_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParkingType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_parking_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_parking_hoop(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_parking_hoop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParkingHoop, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_parking_hoop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_contact_phone(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_contact_phone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContactPhone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_contact_phone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_capacity(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_capacity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_is_valet_station(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_is_valet_station(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsValetStation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_is_valet_station(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_is_charging_station(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_is_charging_station(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsChargingStation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_is_charging_station(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_feed(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_feed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Feed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsFeed)
	fc.Result = res
	return ec.marshalOGbfsFeed2githubcominterlineiotransitlandlibservermodelGbfsFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_feed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "system_information":
				return ec.fieldContext_GbfsFeed_system_information(ctx, field)
			case "station_information":
				return ec.fieldContext_GbfsFeed_station_information(ctx, field)
			case "rental_hours":
				return ec.fieldContext_GbfsFeed_rental_hours(ctx, field)
			case "calendars":
				return ec.fieldContext_GbfsFeed_calendars(ctx, field)
			case "alerts":
				return ec.fieldContext_GbfsFeed_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsFeed", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_region(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_region(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Region(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsSystemRegion)
	fc.Result = res
	return ec.marshalOGbfsSystemRegion2githubcominterlineiotransitlandlibservermodelGbfsSystemRegion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_region(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "region_id":
				return ec.fieldContext_GbfsSystemRegion_region_id(ctx, field)
			case "name":
				return ec.fieldContext_GbfsSystemRegion_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemRegion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_status(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsStationStatus)
	fc.Result = res
	return ec.marshalOGbfsStationStatus2githubcominterlineiotransitlandlibservermodelGbfsStationStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "station_id":
				return ec.fieldContext_GbfsStationStatus_station_id(ctx, field)
			case "num_bikes_available":
				return ec.fieldContext_GbfsStationStatus_num_bikes_available(ctx, field)
			case "num_bikes_disabled":
				return ec.fieldContext_GbfsStationStatus_num_bikes_disabled(ctx, field)
			case "num_docks_available":
				return ec.fieldContext_GbfsStationStatus_num_docks_available(ctx, field)
			case "num_docks_disabled":
				return ec.fieldContext_GbfsStationStatus_num_docks_disabled(ctx, field)
			case "is_returning":
				return ec.fieldContext_GbfsStationStatus_is_returning(ctx, field)
			case "is_renting":
				return ec.fieldContext_GbfsStationStatus_is_renting(ctx, field)
			case "is_installed":
				return ec.fieldContext_GbfsStationStatus_is_installed(ctx, field)
			case "last_reported":
				return ec.fieldContext_GbfsStationStatus_last_reported(ctx, field)
			case "vehicle_types_available":
				return ec.fieldContext_GbfsStationStatus_vehicle_types_available(ctx, field)
			case "vehicle_docks_available":
				return ec.fieldContext_GbfsStationStatus_vehicle_docks_available(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsStationStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_station_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_station_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_station_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_num_bikes_available(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_num_bikes_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumBikesAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_num_bikes_available(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_num_bikes_disabled(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_num_bikes_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumBikesDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_num_bikes_disabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_num_docks_available(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_num_docks_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumDocksAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_num_docks_available(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_num_docks_disabled(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_num_docks_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumDocksDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_num_docks_disabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_is_returning(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_is_returning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsReturning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_is_returning(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_is_renting(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_is_renting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRenting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_is_renting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_is_installed(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_is_installed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsInstalled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_is_installed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_last_reported(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_last_reported(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastReported, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_last_reported(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_vehicle_types_available(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_vehicle_types_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleTypesAvailable(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsVehicleTypeAvailable)
	fc.Result = res
	return ec.marshalOGbfsVehicleTypeAvailable2githubcominterlineiotransitlandlibservermodelGbfsVehicleTypeAvailable(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_vehicle_types_available(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "num_bikes_disabled":
				return ec.fieldContext_GbfsVehicleTypeAvailable_num_bikes_disabled(ctx, field)
			case "num_docks_available":
				return ec.fieldContext_GbfsVehicleTypeAvailable_num_docks_available(ctx, field)
			case "count":
				return ec.fieldContext_GbfsVehicleTypeAvailable_count(ctx, field)
			case "vehicle_type":
				return ec.fieldContext_GbfsVehicleTypeAvailable_vehicle_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleTypeAvailable", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_vehicle_docks_available(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_vehicle_docks_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleDocksAvailable(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsVehicleDockAvailable)
	fc.Result = res
	return ec.marshalOGbfsVehicleDockAvailable2githubcominterlineiotransitlandlibservermodelGbfsVehicleDockAvailable(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_vehicle_docks_available(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_GbfsVehicleDockAvailable_count(ctx, field)
			case "vehicle_types":
				return ec.fieldContext_GbfsVehicleDockAvailable_vehicle_types(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleDockAvailable", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_alert_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_alert_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_alert_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_summary(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_summary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Summary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_summary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_description(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_last_updated(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_last_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_last_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_times(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_times(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Times(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsAlertTime)
	fc.Result = res
	return ec.marshalOGbfsAlertTime2githubcominterlineiotransitlandlibservermodelGbfsAlertTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_times(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "start":
				return ec.fieldContext_GbfsAlertTime_start(ctx, field)
			case "end":
				return ec.fieldContext_GbfsAlertTime_end(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsAlertTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemCalendar_start_month(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemCalendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemCalendar_start_month(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartMonth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemCalendar_start_month(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemCalendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemCalendar_start_day(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemCalendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemCalendar_start_day(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemCalendar_start_day(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemCalendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemCalendar_start_year(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemCalendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemCalendar_start_year(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartYear, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemCalendar_start_year(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemCalendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemCalendar_end_month(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemCalendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemCalendar_end_month(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndMonth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemCalendar_end_month(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemCalendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemCalendar_end_day(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemCalendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemCalendar_end_day(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemCalendar_end_day(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemCalendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemCalendar_end_year(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemCalendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemCalendar_end_year(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndYear, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemCalendar_end_year(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemCalendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemHour_user_types(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemHour) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemHour_user_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Strings)
	fc.Result = res
	return ec.marshalOStrings2githubcominterlineiotransitlandlibttStrings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemHour_user_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemHour",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Strings does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemHour_days(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemHour) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemHour_days(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Days, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Strings)
	fc.Result = res
	return ec.marshalOStrings2githubcominterlineiotransitlandlibttStrings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemHour_days(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemHour",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Strings does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemHour_start_time(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemHour) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemHour_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemHour_start_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemHour",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemHour_end_time(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemHour) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemHour_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemHour_end_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemHour",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_system_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_system_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_system_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_language(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_language(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_language(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_short_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_short_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_short_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_operator(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_operator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Operator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_operator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_purchase_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_purchase_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PurchaseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_purchase_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_start_date(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_start_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_phone_number(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_phone_number(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PhoneNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_phone_number(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_email(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_feed_contact_email(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_feed_contact_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedContactEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_feed_contact_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_timezone(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_timezone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_license_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_license_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LicenseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_license_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_terms_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_terms_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TermsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_terms_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_terms_last_updated(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_terms_last_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TermsLastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_terms_last_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_privacy_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_privacy_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivacyURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_privacy_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_privacy_last_updated(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_privacy_last_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivacyLastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_privacy_last_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_brand_assets(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_brand_assets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BrandAssets(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsBrandAsset)
	fc.Result = res
	return ec.marshalOGbfsBrandAsset2githubcominterlineiotransitlandlibservermodelGbfsBrandAsset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_brand_assets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "brand_last_modified":
				return ec.fieldContext_GbfsBrandAsset_brand_last_modified(ctx, field)
			case "brand_terms_url":
				return ec.fieldContext_GbfsBrandAsset_brand_terms_url(ctx, field)
			case "brand_image_url":
				return ec.fieldContext_GbfsBrandAsset_brand_image_url(ctx, field)
			case "brand_image_url_dark":
				return ec.fieldContext_GbfsBrandAsset_brand_image_url_dark(ctx, field)
			case "color":
				return ec.fieldContext_GbfsBrandAsset_color(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsBrandAsset", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_rental_apps(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_rental_apps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RentalApps(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsRentalApps)
	fc.Result = res
	return ec.marshalOGbfsRentalApps2githubcominterlineiotransitlandlibservermodelGbfsRentalApps(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_rental_apps(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ios":
				return ec.fieldContext_GbfsRentalApps_ios(ctx, field)
			case "android":
				return ec.fieldContext_GbfsRentalApps_android(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsRentalApps", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_plan_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_plan_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_plan_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_currency(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_currency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_currency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_price(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_price(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_price(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_is_taxable(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_is_taxable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsTaxable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_is_taxable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_description(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_surge_pricing(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_surge_pricing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SurgePricing, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_surge_pricing(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_per_km_pricing(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_per_km_pricing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerKmPricing(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsPlanPrice)
	fc.Result = res
	return ec.marshalOGbfsPlanPrice2githubcominterlineiotransitlandlibservermodelGbfsPlanPrice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_per_km_pricing(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "start":
				return ec.fieldContext_GbfsPlanPrice_start(ctx, field)
			case "rate":
				return ec.fieldContext_GbfsPlanPrice_rate(ctx, field)
			case "interval":
				return ec.fieldContext_GbfsPlanPrice_interval(ctx, field)
			case "end":
				return ec.fieldContext_GbfsPlanPrice_end(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsPlanPrice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_per_min_pricing(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_per_min_pricing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerMinPricing(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsPlanPrice)
	fc.Result = res
	return ec.marshalOGbfsPlanPrice2githubcominterlineiotransitlandlibservermodelGbfsPlanPrice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_per_min_pricing(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "start":
				return ec.fieldContext_GbfsPlanPrice_start(ctx, field)
			case "rate":
				return ec.fieldContext_GbfsPlanPrice_rate(ctx, field)
			case "interval":
				return ec.fieldContext_GbfsPlanPrice_interval(ctx, field)
			case "end":
				return ec.fieldContext_GbfsPlanPrice_end(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsPlanPrice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemRegion_region_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemRegion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemRegion_region_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemRegion_region_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemRegion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemRegion_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemRegion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemRegion_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemRegion_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemRegion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemVersion_version(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemVersion_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemVersion_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemVersion_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemVersion_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemVersion_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleAssets_icon_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleAssets) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleAssets_icon_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleAssets_icon_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleAssets",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleAssets_icon_url_dark(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleAssets) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleAssets_icon_url_dark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURLDark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleAssets_icon_url_dark(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleAssets",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleAssets_icon_last_modified(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleAssets) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleAssets_icon_last_modified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconLastModified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleAssets_icon_last_modified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleAssets",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleDockAvailable_count(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleDockAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleDockAvailable_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleDockAvailable_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleDockAvailable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleDockAvailable_vehicle_types(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleDockAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleDockAvailable_vehicle_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsVehicleType)
	fc.Result = res
	return ec.marshalOGbfsVehicleType2githubcominterlineiotransitlandlibservermodelGbfsVehicleType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleDockAvailable_vehicle_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleDockAvailable",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "vehicle_type_id":
				return ec.fieldContext_GbfsVehicleType_vehicle_type_id(ctx, field)
			case "form_factor":
				return ec.fieldContext_GbfsVehicleType_form_factor(ctx, field)
			case "rider_capacity":
				return ec.fieldContext_GbfsVehicleType_rider_capacity(ctx, field)
			case "cargo_volume_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_volume_capacity(ctx, field)
			case "cargo_load_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_load_capacity(ctx, field)
			case "propulsion_type":
				return ec.fieldContext_GbfsVehicleType_propulsion_type(ctx, field)
			case "eco_label":
				return ec.fieldContext_GbfsVehicleType_eco_label(ctx, field)
			case "country_code":
				return ec.fieldContext_GbfsVehicleType_country_code(ctx, field)
			case "eco_sticker":
				return ec.fieldContext_GbfsVehicleType_eco_sticker(ctx, field)
			case "max_range_meters":
				return ec.fieldContext_GbfsVehicleType_max_range_meters(ctx, field)
			case "name":
				return ec.fieldContext_GbfsVehicleType_name(ctx, field)
			case "vehicle_accessories":
				return ec.fieldContext_GbfsVehicleType_vehicle_accessories(ctx, field)
			case "gco_2_km":
				return ec.fieldContext_GbfsVehicleType_gco_2_km(ctx, field)
			case "vehicle_image":
				return ec.fieldContext_GbfsVehicleType_vehicle_image(ctx, field)
			case "make":
				return ec.fieldContext_GbfsVehicleType_make(ctx, field)
			case "model":
				return ec.fieldContext_GbfsVehicleType_model(ctx, field)
			case "color":
				return ec.fieldContext_GbfsVehicleType_color(ctx, field)
			case "wheel_count":
				return ec.fieldContext_GbfsVehicleType_wheel_count(ctx, field)
			case "max_permitted_speed":
				return ec.fieldContext_GbfsVehicleType_max_permitted_speed(ctx, field)
			case "rated_power":
				return ec.fieldContext_GbfsVehicleType_rated_power(ctx, field)
			case "default_reserve_time":
				return ec.fieldContext_GbfsVehicleType_default_reserve_time(ctx, field)
			case "return_constraint":
				return ec.fieldContext_GbfsVehicleType_return_constraint(ctx, field)
			case "default_pricing_plan":
				return ec.fieldContext_GbfsVehicleType_default_pricing_plan(ctx, field)
			case "pricing_plans":
				return ec.fieldContext_GbfsVehicleType_pricing_plans(ctx, field)
			case "rental_uris":
				return ec.fieldContext_GbfsVehicleType_rental_uris(ctx, field)
			case "vehicle_assets":
				return ec.fieldContext_GbfsVehicleType_vehicle_assets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_vehicle_type_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_vehicle_type_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleTypeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_vehicle_type_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_form_factor(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_form_factor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FormFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_form_factor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_rider_capacity(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_rider_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RiderCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_rider_capacity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_cargo_volume_capacity(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_cargo_volume_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CargoVolumeCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_cargo_volume_capacity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_cargo_load_capacity(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_cargo_load_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CargoLoadCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_cargo_load_capacity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_propulsion_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_propulsion_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PropulsionType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_propulsion_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_eco_label(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_eco_label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EcoLabel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_eco_label(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_country_code(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_country_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CountryCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_country_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_eco_sticker(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_eco_sticker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EcoSticker, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_eco_sticker(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_max_range_meters(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_max_range_meters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxRangeMeters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_max_range_meters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_vehicle_accessories(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_vehicle_accessories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleAccessories, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Strings)
	fc.Result = res
	return ec.marshalOStrings2githubcominterlineiotransitlandlibttStrings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_vehicle_accessories(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Strings does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_gco_2_km(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_gco_2_km(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCO2Km, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_gco_2_km(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_vehicle_image(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_vehicle_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_vehicle_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_make(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_make(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Make, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_make(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_model(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_model(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_color(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_wheel_count(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_wheel_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WheelCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_wheel_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_max_permitted_speed(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_max_permitted_speed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxPermittedSpeed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_max_permitted_speed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_rated_power(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_rated_power(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RatedPower, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_rated_power(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_default_reserve_time(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_default_reserve_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultReserveTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_default_reserve_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_return_constraint(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_return_constraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReturnConstraint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_return_constraint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_default_pricing_plan(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_default_pricing_plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultPricingPlan(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsSystemPricingPlan)
	fc.Result = res
	return ec.marshalOGbfsSystemPricingPlan2githubcominterlineiotransitlandlibservermodelGbfsSystemPricingPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_default_pricing_plan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "plan_id":
				return ec.fieldContext_GbfsSystemPricingPlan_plan_id(ctx, field)
			case "url":
				return ec.fieldContext_GbfsSystemPricingPlan_url(ctx, field)
			case "name":
				return ec.fieldContext_GbfsSystemPricingPlan_name(ctx, field)
			case "currency":
				return ec.fieldContext_GbfsSystemPricingPlan_currency(ctx, field)
			case "price":
				return ec.fieldContext_GbfsSystemPricingPlan_price(ctx, field)
			case "is_taxable":
				return ec.fieldContext_GbfsSystemPricingPlan_is_taxable(ctx, field)
			case "description":
				return ec.fieldContext_GbfsSystemPricingPlan_description(ctx, field)
			case "surge_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_surge_pricing(ctx, field)
			case "per_km_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_per_km_pricing(ctx, field)
			case "per_min_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_per_min_pricing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemPricingPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_pricing_plans(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_pricing_plans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PricingPlans(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsSystemPricingPlan)
	fc.Result = res
	return ec.marshalOGbfsSystemPricingPlan2githubcominterlineiotransitlandlibservermodelGbfsSystemPricingPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_pricing_plans(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "plan_id":
				return ec.fieldContext_GbfsSystemPricingPlan_plan_id(ctx, field)
			case "url":
				return ec.fieldContext_GbfsSystemPricingPlan_url(ctx, field)
			case "name":
				return ec.fieldContext_GbfsSystemPricingPlan_name(ctx, field)
			case "currency":
				return ec.fieldContext_GbfsSystemPricingPlan_currency(ctx, field)
			case "price":
				return ec.fieldContext_GbfsSystemPricingPlan_price(ctx, field)
			case "is_taxable":
				return ec.fieldContext_GbfsSystemPricingPlan_is_taxable(ctx, field)
			case "description":
				return ec.fieldContext_GbfsSystemPricingPlan_description(ctx, field)
			case "surge_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_surge_pricing(ctx, field)
			case "per_km_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_per_km_pricing(ctx, field)
			case "per_min_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_per_min_pricing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemPricingPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_rental_uris(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_rental_uris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RentalUris(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsRentalUris)
	fc.Result = res
	return ec.marshalOGbfsRentalUris2githubcominterlineiotransitlandlibservermodelGbfsRentalUris(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_rental_uris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "android":
				return ec.fieldContext_GbfsRentalUris_android(ctx, field)
			case "ios":
				return ec.fieldContext_GbfsRentalUris_ios(ctx, field)
			case "web":
				return ec.fieldContext_GbfsRentalUris_web(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsRentalUris", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_vehicle_assets(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_vehicle_assets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleAssets(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsVehicleAssets)
	fc.Result = res
	return ec.marshalOGbfsVehicleAssets2githubcominterlineiotransitlandlibservermodelGbfsVehicleAssets(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_vehicle_assets(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "icon_url":
				return ec.fieldContext_GbfsVehicleAssets_icon_url(ctx, field)
			case "icon_url_dark":
				return ec.fieldContext_GbfsVehicleAssets_icon_url_dark(ctx, field)
			case "icon_last_modified":
				return ec.fieldContext_GbfsVehicleAssets_icon_last_modified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleAssets", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleTypeAvailable_num_bikes_disabled(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleTypeAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleTypeAvailable_num_bikes_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumBikesDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleTypeAvailable_num_bikes_disabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleTypeAvailable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleTypeAvailable_num_docks_available(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleTypeAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleTypeAvailable_num_docks_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumDocksAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleTypeAvailable_num_docks_available(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleTypeAvailable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleTypeAvailable_count(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleTypeAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleTypeAvailable_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleTypeAvailable_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleTypeAvailable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleTypeAvailable_vehicle_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleTypeAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleTypeAvailable_vehicle_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsVehicleType)
	fc.Result = res
	return ec.marshalOGbfsVehicleType2githubcominterlineiotransitlandlibservermodelGbfsVehicleType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleTypeAvailable_vehicle_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleTypeAvailable",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "vehicle_type_id":
				return ec.fieldContext_GbfsVehicleType_vehicle_type_id(ctx, field)
			case "form_factor":
				return ec.fieldContext_GbfsVehicleType_form_factor(ctx, field)
			case "rider_capacity":
				return ec.fieldContext_GbfsVehicleType_rider_capacity(ctx, field)
			case "cargo_volume_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_volume_capacity(ctx, field)
			case "cargo_load_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_load_capacity(ctx, field)
			case "propulsion_type":
				return ec.fieldContext_GbfsVehicleType_propulsion_type(ctx, field)
			case "eco_label":
				return ec.fieldContext_GbfsVehicleType_eco_label(ctx, field)
			case "country_code":
				return ec.fieldContext_GbfsVehicleType_country_code(ctx, field)
			case "eco_sticker":
				return ec.fieldContext_GbfsVehicleType_eco_sticker(ctx, field)
			case "max_range_meters":
				return ec.fieldContext_GbfsVehicleType_max_range_meters(ctx, field)
			case "name":
				return ec.fieldContext_GbfsVehicleType_name(ctx, field)
			case "vehicle_accessories":
				return ec.fieldContext_GbfsVehicleType_vehicle_accessories(ctx, field)
			case "gco_2_km":
				return ec.fieldContext_GbfsVehicleType_gco_2_km(ctx, field)
			case "vehicle_image":
				return ec.fieldContext_GbfsVehicleType_vehicle_image(ctx, field)
			case "make":
				return ec.fieldContext_GbfsVehicleType_make(ctx, field)
			case "model":
				return ec.fieldContext_GbfsVehicleType_model(ctx, field)
			case "color":
				return ec.fieldContext_GbfsVehicleType_color(ctx, field)
			case "wheel_count":
				return ec.fieldContext_GbfsVehicleType_wheel_count(ctx, field)
			case "max_permitted_speed":
				return ec.fieldContext_GbfsVehicleType_max_permitted_speed(ctx, field)
			case "rated_power":
				return ec.fieldContext_GbfsVehicleType_rated_power(ctx, field)
			case "default_reserve_time":
				return ec.fieldContext_GbfsVehicleType_default_reserve_time(ctx, field)
			case "return_constraint":
				return ec.fieldContext_GbfsVehicleType_return_constraint(ctx, field)
			case "default_pricing_plan":
				return ec.fieldContext_GbfsVehicleType_default_pricing_plan(ctx, field)
			case "pricing_plans":
				return ec.fieldContext_GbfsVehicleType_pricing_plans(ctx, field)
			case "rental_uris":
				return ec.fieldContext_GbfsVehicleType_rental_uris(ctx, field)
			case "vehicle_assets":
				return ec.fieldContext_GbfsVehicleType_vehicle_assets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_duration(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalNDuration2githubcominterlineiotransitlandlibservermodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Duration_duration(ctx, field)
			case "units":
				return ec.fieldContext_Duration_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Duration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_distance(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Distance)
	fc.Result = res
	return ec.marshalNDistance2githubcominterlineiotransitlandlibservermodelDistance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_distance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distance":
				return ec.fieldContext_Distance_distance(ctx, field)
			case "units":
				return ec.fieldContext_Distance_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_start_time(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_start_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_end_time(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_end_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_from(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_from(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.From, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalNWaypoint2githubcominterlineiotransitlandlibservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_from(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			case "stop":
				return ec.fieldContext_Waypoint_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_to(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_to(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.To, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalNWaypoint2githubcominterlineiotransitlandlibservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_to(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			case "stop":
				return ec.fieldContext_Waypoint_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_legs(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_legs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Leg)
	fc.Result = res
	return ec.marshalOLeg2githubcominterlineiotransitlandlibservermodelLeg(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_legs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Leg_duration(ctx, field)
			case "distance":
				return ec.fieldContext_Leg_distance(ctx, field)
			case "start_time":
				return ec.fieldContext_Leg_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_Leg_end_time(ctx, field)
			case "from":
				return ec.fieldContext_Leg_from(ctx, field)
			case "to":
				return ec.fieldContext_Leg_to(ctx, field)
			case "mode":
				return ec.fieldContext_Leg_mode(ctx, field)
			case "steps":
				return ec.fieldContext_Leg_steps(ctx, field)
			case "stops":
				return ec.fieldContext_Leg_stops(ctx, field)
			case "geometry":
				return ec.fieldContext_Leg_geometry(ctx, field)
			case "trip":
				return ec.fieldContext_Leg_trip(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Leg", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_duration(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalNDuration2githubcominterlineiotransitlandlibservermodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Duration_duration(ctx, field)
			case "units":
				return ec.fieldContext_Duration_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Duration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_distance(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Distance)
	fc.Result = res
	return ec.marshalNDistance2githubcominterlineiotransitlandlibservermodelDistance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_distance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distance":
				return ec.fieldContext_Distance_distance(ctx, field)
			case "units":
				return ec.fieldContext_Distance_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_start_time(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_start_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_end_time(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_end_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_from(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_from(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.From, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalOWaypoint2githubcominterlineiotransitlandlibservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_from(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			case "stop":
				return ec.fieldContext_Waypoint_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_to(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_to(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.To, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalOWaypoint2githubcominterlineiotransitlandlibservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_to(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			case "stop":
				return ec.fieldContext_Waypoint_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_mode(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_mode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StepMode)
	fc.Result = res
	return ec.marshalOStepMode2githubcominterlineiotransitlandlibservermodelStepMode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_mode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StepMode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_steps(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_steps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Steps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Step)
	fc.Result = res
	return ec.marshalOStep2githubcominterlineiotransitlandlibservermodelStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_steps(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Step_duration(ctx, field)
			case "distance":
				return ec.fieldContext_Step_distance(ctx, field)
			case "start_time":
				return ec.fieldContext_Step_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_Step_end_time(ctx, field)
			case "to":
				return ec.fieldContext_Step_to(ctx, field)
			case "mode":
				return ec.fieldContext_Step_mode(ctx, field)
			case "instruction":
				return ec.fieldContext_Step_instruction(ctx, field)
			case "geometry_offset":
				return ec.fieldContext_Step_geometry_offset(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Step", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_stops(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stops, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.WaypointDeparture)
	fc.Result = res
	return ec.marshalOWaypointDeparture2githubcominterlineiotransitlandlibservermodelWaypointDeparture(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_stops(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_WaypointDeparture_lon(ctx, field)
			case "lat":
				return ec.fieldContext_WaypointDeparture_lat(ctx, field)
			case "departure":
				return ec.fieldContext_WaypointDeparture_departure(ctx, field)
			case "stop_id":
				return ec.fieldContext_WaypointDeparture_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_WaypointDeparture_stop_name(ctx, field)
			case "stop_code":
				return ec.fieldContext_WaypointDeparture_stop_code(ctx, field)
			case "stop_onestop_id":
				return ec.fieldContext_WaypointDeparture_stop_onestop_id(ctx, field)
			case "stop_index":
				return ec.fieldContext_WaypointDeparture_stop_index(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_WaypointDeparture_stop_sequence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaypointDeparture", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.LineString)
	fc.Result = res
	return ec.marshalNLineString2githubcominterlineiotransitlandlibttLineString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LineString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_trip(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_trip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Trip, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.LegTrip)
	fc.Result = res
	return ec.marshalOLegTrip2githubcominterlineiotransitlandlibservermodelLegTrip(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_trip(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "trip_id":
				return ec.fieldContext_LegTrip_trip_id(ctx, field)
			case "trip_short_name":
				return ec.fieldContext_LegTrip_trip_short_name(ctx, field)
			case "headsign":
				return ec.fieldContext_LegTrip_headsign(ctx, field)
			case "feed_id":
				return ec.fieldContext_LegTrip_feed_id(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_LegTrip_feed_version_sha1(ctx, field)
			case "route":
				return ec.fieldContext_LegTrip_route(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LegTrip", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegRoute_route_id(ctx context.Context, field graphql.CollectedField, obj *model.LegRoute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegRoute_route_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegRoute_route_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegRoute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegRoute_route_short_name(ctx context.Context, field graphql.CollectedField, obj *model.LegRoute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegRoute_route_short_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegRoute_route_short_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegRoute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegRoute_route_long_name(ctx context.Context, field graphql.CollectedField, obj *model.LegRoute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegRoute_route_long_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteLongName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegRoute_route_long_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegRoute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegRoute_route_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.LegRoute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegRoute_route_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegRoute_route_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegRoute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegRoute_route_type(ctx context.Context, field graphql.CollectedField, obj *model.LegRoute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegRoute_route_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegRoute_route_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegRoute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegRoute_route_color(ctx context.Context, field graphql.CollectedField, obj *model.LegRoute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegRoute_route_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteColor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegRoute_route_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegRoute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegRoute_route_text_color(ctx context.Context, field graphql.CollectedField, obj *model.LegRoute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegRoute_route_text_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteTextColor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegRoute_route_text_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegRoute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegRoute_agency(ctx context.Context, field graphql.CollectedField, obj *model.LegRoute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegRoute_agency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Agency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.LegRouteAgency)
	fc.Result = res
	return ec.marshalNLegRouteAgency2githubcominterlineiotransitlandlibservermodelLegRouteAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegRoute_agency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegRoute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agency_id":
				return ec.fieldContext_LegRouteAgency_agency_id(ctx, field)
			case "agency_name":
				return ec.fieldContext_LegRouteAgency_agency_name(ctx, field)
			case "agency_onestop_id":
				return ec.fieldContext_LegRouteAgency_agency_onestop_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LegRouteAgency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegRouteAgency_agency_id(ctx context.Context, field graphql.CollectedField, obj *model.LegRouteAgency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegRouteAgency_agency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegRouteAgency_agency_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegRouteAgency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegRouteAgency_agency_name(ctx context.Context, field graphql.CollectedField, obj *model.LegRouteAgency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegRouteAgency_agency_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegRouteAgency_agency_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegRouteAgency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegRouteAgency_agency_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.LegRouteAgency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegRouteAgency_agency_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegRouteAgency_agency_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegRouteAgency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegTrip_trip_id(ctx context.Context, field graphql.CollectedField, obj *model.LegTrip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegTrip_trip_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegTrip_trip_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegTrip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegTrip_trip_short_name(ctx context.Context, field graphql.CollectedField, obj *model.LegTrip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegTrip_trip_short_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegTrip_trip_short_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegTrip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegTrip_headsign(ctx context.Context, field graphql.CollectedField, obj *model.LegTrip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegTrip_headsign(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headsign, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegTrip_headsign(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegTrip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegTrip_feed_id(ctx context.Context, field graphql.CollectedField, obj *model.LegTrip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegTrip_feed_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegTrip_feed_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegTrip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegTrip_feed_version_sha1(ctx context.Context, field graphql.CollectedField, obj *model.LegTrip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegTrip_feed_version_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersionSha1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegTrip_feed_version_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegTrip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LegTrip_route(ctx context.Context, field graphql.CollectedField, obj *model.LegTrip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LegTrip_route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Route, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.LegRoute)
	fc.Result = res
	return ec.marshalNLegRoute2githubcominterlineiotransitlandlibservermodelLegRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LegTrip_route(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LegTrip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "route_id":
				return ec.fieldContext_LegRoute_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_LegRoute_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_LegRoute_route_long_name(ctx, field)
			case "route_onestop_id":
				return ec.fieldContext_LegRoute_route_onestop_id(ctx, field)
			case "route_type":
				return ec.fieldContext_LegRoute_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_LegRoute_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_LegRoute_route_text_color(ctx, field)
			case "agency":
				return ec.fieldContext_LegRoute_agency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LegRoute", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Level_id(ctx context.Context, field graphql.CollectedField, obj *model.Level) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Level_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Level_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Level",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Level_level_id(ctx context.Context, field graphql.CollectedField, obj *model.Level) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Level_level_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LevelID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Level_level_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Level",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Level_level_index(ctx context.Context, field graphql.CollectedField, obj *model.Level) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Level_level_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LevelIndex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalNFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Level_level_index(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Level",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Level_level_name(ctx context.Context, field graphql.CollectedField, obj *model.Level) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Level_level_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LevelName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Level_level_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Level",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Level_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Level) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Level_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.MultiPolygon)
	fc.Result = res
	return ec.marshalNMultiPolygon2githubcominterlineiotransitlandlibttMultiPolygon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Level_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Level",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MultiPolygon does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Level_stops(ctx context.Context, field graphql.CollectedField, obj *model.Level) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Level_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Level().Stops(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalOStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Level_stops(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Level",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_id(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_location_id(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_location_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_location_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_stop_name(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_stop_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_stop_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_stop_desc(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_stop_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopDesc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_stop_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_zone_id(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_zone_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZoneID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_zone_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_stop_url(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_stop_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Url)
	fc.Result = res
	return ec.marshalOUrl2githubcominterlineiotransitlandlibttUrl(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_stop_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Geometry)
	fc.Result = res
	return ec.marshalNGeometry2githubcominterlineiotransitlandlibttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_feed_version_sha1(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_feed_version_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersionSHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_feed_version_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_feed_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Location().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_feed_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "service_window":
				return ec.fieldContext_FeedVersion_service_window(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "locations":
				return ec.fieldContext_FeedVersion_locations(ctx, field)
			case "booking_rules":
				return ec.fieldContext_FeedVersion_booking_rules(ctx, field)
			case "location_groups":
				return ec.fieldContext_FeedVersion_location_groups(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			case "validation_reports":
				return ec.fieldContext_FeedVersion_validation_reports(ctx, field)
			case "segments":
				return ec.fieldContext_FeedVersion_segments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_stop_times(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_stop_times(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Location().StopTimes(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopTimeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StopTime)
	fc.Result = res
	return ec.marshalNFlexStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_stop_times(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arrival_time":
				return ec.fieldContext_FlexStopTime_arrival_time(ctx, field)
			case "departure_time":
				return ec.fieldContext_FlexStopTime_departure_time(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_FlexStopTime_stop_sequence(ctx, field)
			case "stop_headsign":
				return ec.fieldContext_FlexStopTime_stop_headsign(ctx, field)
			case "pickup_type":
				return ec.fieldContext_FlexStopTime_pickup_type(ctx, field)
			case "drop_off_type":
				return ec.fieldContext_FlexStopTime_drop_off_type(ctx, field)
			case "timepoint":
				return ec.fieldContext_FlexStopTime_timepoint(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_FlexStopTime_continuous_drop_off(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_FlexStopTime_continuous_pickup(ctx, field)
			case "shape_dist_traveled":
				return ec.fieldContext_FlexStopTime_shape_dist_traveled(ctx, field)
			case "interpolated":
				return ec.fieldContext_FlexStopTime_interpolated(ctx, field)
			case "start_pickup_drop_off_window":
				return ec.fieldContext_FlexStopTime_start_pickup_drop_off_window(ctx, field)
			case "end_pickup_drop_off_window":
				return ec.fieldContext_FlexStopTime_end_pickup_drop_off_window(ctx, field)
			case "pickup_booking_rule":
				return ec.fieldContext_FlexStopTime_pickup_booking_rule(ctx, field)
			case "drop_off_booking_rule":
				return ec.fieldContext_FlexStopTime_drop_off_booking_rule(ctx, field)
			case "location":
				return ec.fieldContext_FlexStopTime_location(ctx, field)
			case "location_group":
				return ec.fieldContext_FlexStopTime_location_group(ctx, field)
			case "trip":
				return ec.fieldContext_FlexStopTime_trip(ctx, field)
			case "arrival":
				return ec.fieldContext_FlexStopTime_arrival(ctx, field)
			case "departure":
				return ec.fieldContext_FlexStopTime_departure(ctx, field)
			case "service_date":
				return ec.fieldContext_FlexStopTime_service_date(ctx, field)
			case "date":
				return ec.fieldContext_FlexStopTime_date(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_FlexStopTime_schedule_relationship(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FlexStopTime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Location_stop_times_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _LocationGroup_id(ctx context.Context, field graphql.CollectedField, obj *model.LocationGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationGroup_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationGroup_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationGroup_location_group_id(ctx context.Context, field graphql.CollectedField, obj *model.LocationGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationGroup_location_group_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationGroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationGroup_location_group_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationGroup_location_group_name(ctx context.Context, field graphql.CollectedField, obj *model.LocationGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationGroup_location_group_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationGroupName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationGroup_location_group_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationGroup_feed_version_sha1(ctx context.Context, field graphql.CollectedField, obj *model.LocationGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationGroup_feed_version_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersionSHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationGroup_feed_version_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationGroup_feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.LocationGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationGroup_feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationGroup_feed_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationGroup_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.LocationGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationGroup_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LocationGroup().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationGroup_feed_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationGroup",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "service_window":
				return ec.fieldContext_FeedVersion_service_window(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "locations":
				return ec.fieldContext_FeedVersion_locations(ctx, field)
			case "booking_rules":
				return ec.fieldContext_FeedVersion_booking_rules(ctx, field)
			case "location_groups":
				return ec.fieldContext_FeedVersion_location_groups(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			case "validation_reports":
				return ec.fieldContext_FeedVersion_validation_reports(ctx, field)
			case "segments":
				return ec.fieldContext_FeedVersion_segments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationGroup_stops(ctx context.Context, field graphql.CollectedField, obj *model.LocationGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationGroup_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LocationGroup().Stops(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationGroup_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationGroup",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_LocationGroup_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _LocationGroup_stop_times(ctx context.Context, field graphql.CollectedField, obj *model.LocationGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationGroup_stop_times(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LocationGroup().StopTimes(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopTimeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StopTime)
	fc.Result = res
	return ec.marshalNFlexStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationGroup_stop_times(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationGroup",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arrival_time":
				return ec.fieldContext_FlexStopTime_arrival_time(ctx, field)
			case "departure_time":
				return ec.fieldContext_FlexStopTime_departure_time(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_FlexStopTime_stop_sequence(ctx, field)
			case "stop_headsign":
				return ec.fieldContext_FlexStopTime_stop_headsign(ctx, field)
			case "pickup_type":
				return ec.fieldContext_FlexStopTime_pickup_type(ctx, field)
			case "drop_off_type":
				return ec.fieldContext_FlexStopTime_drop_off_type(ctx, field)
			case "timepoint":
				return ec.fieldContext_FlexStopTime_timepoint(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_FlexStopTime_continuous_drop_off(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_FlexStopTime_continuous_pickup(ctx, field)
			case "shape_dist_traveled":
				return ec.fieldContext_FlexStopTime_shape_dist_traveled(ctx, field)
			case "interpolated":
				return ec.fieldContext_FlexStopTime_interpolated(ctx, field)
			case "start_pickup_drop_off_window":
				return ec.fieldContext_FlexStopTime_start_pickup_drop_off_window(ctx, field)
			case "end_pickup_drop_off_window":
				return ec.fieldContext_FlexStopTime_end_pickup_drop_off_window(ctx, field)
			case "pickup_booking_rule":
				return ec.fieldContext_FlexStopTime_pickup_booking_rule(ctx, field)
			case "drop_off_booking_rule":
				return ec.fieldContext_FlexStopTime_drop_off_booking_rule(ctx, field)
			case "location":
				return ec.fieldContext_FlexStopTime_location(ctx, field)
			case "location_group":
				return ec.fieldContext_FlexStopTime_location_group(ctx, field)
			case "trip":
				return ec.fieldContext_FlexStopTime_trip(ctx, field)
			case "arrival":
				return ec.fieldContext_FlexStopTime_arrival(ctx, field)
			case "departure":
				return ec.fieldContext_FlexStopTime_departure(ctx, field)
			case "service_date":
				return ec.fieldContext_FlexStopTime_service_date(ctx, field)
			case "date":
				return ec.fieldContext_FlexStopTime_date(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_FlexStopTime_schedule_relationship(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FlexStopTime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_LocationGroup_stop_times_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _LocationGroupStop_id(ctx context.Context, field graphql.CollectedField, obj *model.LocationGroupStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationGroupStop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationGroupStop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationGroupStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationGroupStop_location_group(ctx context.Context, field graphql.CollectedField, obj *model.LocationGroupStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationGroupStop_location_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LocationGroupStop().LocationGroup(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.LocationGroup)
	fc.Result = res
	return ec.marshalNLocationGroup2githubcominterlineiotransitlandlibservermodelLocationGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationGroupStop_location_group(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationGroupStop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationGroup_id(ctx, field)
			case "location_group_id":
				return ec.fieldContext_LocationGroup_location_group_id(ctx, field)
			case "location_group_name":
				return ec.fieldContext_LocationGroup_location_group_name(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_LocationGroup_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_LocationGroup_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_LocationGroup_feed_version(ctx, field)
			case "stops":
				return ec.fieldContext_LocationGroup_stops(ctx, field)
			case "stop_times":
				return ec.fieldContext_LocationGroup_stop_times(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationGroupStop_stop(ctx context.Context, field graphql.CollectedField, obj *model.LocationGroupStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationGroupStop_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LocationGroupStop().Stop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationGroupStop_stop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationGroupStop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Me_id(ctx context.Context, field graphql.CollectedField, obj *model.Me) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Me_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Me_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Me",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Me_name(ctx context.Context, field graphql.CollectedField, obj *model.Me) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Me_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Me_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Me",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Me_email(ctx context.Context, field graphql.CollectedField, obj *model.Me) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Me_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Me_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Me",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Me_roles(ctx context.Context, field graphql.CollectedField, obj *model.Me) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Me_roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Roles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Me_roles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Me",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Me_external_data(ctx context.Context, field graphql.CollectedField, obj *model.Me) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Me_external_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Map)
	fc.Result = res
	return ec.marshalNMap2githubcominterlineiotransitlandlibttMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Me_external_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Me",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_validate_gtfs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_validate_gtfs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ValidateGtfs(rctx, fc.Args["file"].(*graphql.Upload), fc.Args["url"].(*string), fc.Args["realtime_urls"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ValidationReport)
	fc.Result = res
	return ec.marshalOValidationReport2githubcominterlineiotransitlandlibservermodelValidationReport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_validate_gtfs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ValidationReport_id(ctx, field)
			case "reported_at":
				return ec.fieldContext_ValidationReport_reported_at(ctx, field)
			case "reported_at_local":
				return ec.fieldContext_ValidationReport_reported_at_local(ctx, field)
			case "reported_at_local_timezone":
				return ec.fieldContext_ValidationReport_reported_at_local_timezone(ctx, field)
			case "success":
				return ec.fieldContext_ValidationReport_success(ctx, field)
			case "failure_reason":
				return ec.fieldContext_ValidationReport_failure_reason(ctx, field)
			case "includes_static":
				return ec.fieldContext_ValidationReport_includes_static(ctx, field)
			case "includes_rt":
				return ec.fieldContext_ValidationReport_includes_rt(ctx, field)
			case "validator":
				return ec.fieldContext_ValidationReport_validator(ctx, field)
			case "validator_version":
				return ec.fieldContext_ValidationReport_validator_version(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationReport_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ValidationReport_warnings(ctx, field)
			case "details":
				return ec.fieldContext_ValidationReport_details(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationReport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_validate_gtfs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_feed_version_update(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_feed_version_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FeedVersionUpdate(rctx, fc.Args["set"].(model.FeedVersionSetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalOFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_feed_version_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "service_window":
				return ec.fieldContext_FeedVersion_service_window(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "locations":
				return ec.fieldContext_FeedVersion_locations(ctx, field)
			case "booking_rules":
				return ec.fieldContext_FeedVersion_booking_rules(ctx, field)
			case "location_groups":
				return ec.fieldContext_FeedVersion_location_groups(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			case "validation_reports":
				return ec.fieldContext_FeedVersion_validation_reports(ctx, field)
			case "segments":
				return ec.fieldContext_FeedVersion_segments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_feed_version_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_feed_version_fetch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_feed_version_fetch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FeedVersionFetch(rctx, fc.Args["file"].(*graphql.Upload), fc.Args["url"].(*string), fc.Args["feed_onestop_id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersionFetchResult)
	fc.Result = res
	return ec.marshalOFeedVersionFetchResult2githubcominterlineiotransitlandlibservermodelFeedVersionFetchResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_feed_version_fetch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "feed_version":
				return ec.fieldContext_FeedVersionFetchResult_feed_version(ctx, field)
			case "fetch_error":
				return ec.fieldContext_FeedVersionFetchResult_fetch_error(ctx, field)
			case "found_sha1":
				return ec.fieldContext_FeedVersionFetchResult_found_sha1(ctx, field)
			case "found_dir_sha1":
				return ec.fieldContext_FeedVersionFetchResult_found_dir_sha1(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionFetchResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_feed_version_fetch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_feed_version_import(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_feed_version_import(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FeedVersionImport(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersionImportResult)
	fc.Result = res
	return ec.marshalNFeedVersionImportResult2githubcominterlineiotransitlandlibservermodelFeedVersionImportResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_feed_version_import(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_FeedVersionImportResult_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionImportResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_feed_version_import_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_feed_version_unimport(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_feed_version_unimport(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FeedVersionUnimport(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersionUnimportResult)
	fc.Result = res
	return ec.marshalNFeedVersionUnimportResult2githubcominterlineiotransitlandlibservermodelFeedVersionUnimportResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_feed_version_unimport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_FeedVersionUnimportResult_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionUnimportResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_feed_version_unimport_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_feed_version_delete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_feed_version_delete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FeedVersionDelete(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersionDeleteResult)
	fc.Result = res
	return ec.marshalNFeedVersionDeleteResult2githubcominterlineiotransitlandlibservermodelFeedVersionDeleteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_feed_version_delete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_FeedVersionDeleteResult_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_feed_version_delete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_stop_create(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_stop_create(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().StopCreate(rctx, fc.Args["set"].(model.StopSetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_stop_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_stop_create_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_stop_update(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_stop_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().StopUpdate(rctx, fc.Args["set"].(model.StopSetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_stop_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_stop_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_stop_delete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_stop_delete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().StopDelete(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EntityDeleteResult)
	fc.Result = res
	return ec.marshalNEntityDeleteResult2githubcominterlineiotransitlandlibservermodelEntityDeleteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_stop_delete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EntityDeleteResult_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EntityDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_stop_delete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_level_create(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_level_create(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().LevelCreate(rctx, fc.Args["set"].(model.LevelSetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Level)
	fc.Result = res
	return ec.marshalNLevel2githubcominterlineiotransitlandlibservermodelLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_level_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Level_id(ctx, field)
			case "level_id":
				return ec.fieldContext_Level_level_id(ctx, field)
			case "level_index":
				return ec.fieldContext_Level_level_index(ctx, field)
			case "level_name":
				return ec.fieldContext_Level_level_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Level_geometry(ctx, field)
			case "stops":
				return ec.fieldContext_Level_stops(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Level", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_level_create_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_level_update(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_level_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().LevelUpdate(rctx, fc.Args["set"].(model.LevelSetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Level)
	fc.Result = res
	return ec.marshalNLevel2githubcominterlineiotransitlandlibservermodelLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_level_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Level_id(ctx, field)
			case "level_id":
				return ec.fieldContext_Level_level_id(ctx, field)
			case "level_index":
				return ec.fieldContext_Level_level_index(ctx, field)
			case "level_name":
				return ec.fieldContext_Level_level_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Level_geometry(ctx, field)
			case "stops":
				return ec.fieldContext_Level_stops(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Level", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_level_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_level_delete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_level_delete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().LevelDelete(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EntityDeleteResult)
	fc.Result = res
	return ec.marshalNEntityDeleteResult2githubcominterlineiotransitlandlibservermodelEntityDeleteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_level_delete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EntityDeleteResult_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EntityDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_level_delete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_pathway_create(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_pathway_create(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PathwayCreate(rctx, fc.Args["set"].(model.PathwaySetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Pathway)
	fc.Result = res
	return ec.marshalNPathway2githubcominterlineiotransitlandlibservermodelPathway(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_pathway_create(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Pathway_id(ctx, field)
			case "pathway_id":
				return ec.fieldContext_Pathway_pathway_id(ctx, field)
			case "pathway_mode":
				return ec.fieldContext_Pathway_pathway_mode(ctx, field)
			case "is_bidirectional":
				return ec.fieldContext_Pathway_is_bidirectional(ctx, field)
			case "length":
				return ec.fieldContext_Pathway_length(ctx, field)
			case "traversal_time":
				return ec.fieldContext_Pathway_traversal_time(ctx, field)
			case "stair_count":
				return ec.fieldContext_Pathway_stair_count(ctx, field)
			case "max_slope":
				return ec.fieldContext_Pathway_max_slope(ctx, field)
			case "min_width":
				return ec.fieldContext_Pathway_min_width(ctx, field)
			case "signposted_as":
				return ec.fieldContext_Pathway_signposted_as(ctx, field)
			case "reverse_signposted_as":
				return ec.fieldContext_Pathway_reverse_signposted_as(ctx, field)
			case "from_stop":
				return ec.fieldContext_Pathway_from_stop(ctx, field)
			case "to_stop":
				return ec.fieldContext_Pathway_to_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pathway", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_pathway_create_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_pathway_update(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_pathway_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PathwayUpdate(rctx, fc.Args["set"].(model.PathwaySetInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Pathway)
	fc.Result = res
	return ec.marshalNPathway2githubcominterlineiotransitlandlibservermodelPathway(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_pathway_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Pathway_id(ctx, field)
			case "pathway_id":
				return ec.fieldContext_Pathway_pathway_id(ctx, field)
			case "pathway_mode":
				return ec.fieldContext_Pathway_pathway_mode(ctx, field)
			case "is_bidirectional":
				return ec.fieldContext_Pathway_is_bidirectional(ctx, field)
			case "length":
				return ec.fieldContext_Pathway_length(ctx, field)
			case "traversal_time":
				return ec.fieldContext_Pathway_traversal_time(ctx, field)
			case "stair_count":
				return ec.fieldContext_Pathway_stair_count(ctx, field)
			case "max_slope":
				return ec.fieldContext_Pathway_max_slope(ctx, field)
			case "min_width":
				return ec.fieldContext_Pathway_min_width(ctx, field)
			case "signposted_as":
				return ec.fieldContext_Pathway_signposted_as(ctx, field)
			case "reverse_signposted_as":
				return ec.fieldContext_Pathway_reverse_signposted_as(ctx, field)
			case "from_stop":
				return ec.fieldContext_Pathway_from_stop(ctx, field)
			case "to_stop":
				return ec.fieldContext_Pathway_to_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pathway", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_pathway_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_pathway_delete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_pathway_delete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PathwayDelete(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EntityDeleteResult)
	fc.Result = res
	return ec.marshalNEntityDeleteResult2githubcominterlineiotransitlandlibservermodelEntityDeleteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_pathway_delete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_EntityDeleteResult_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EntityDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_pathway_delete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Operator_id(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_generated(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_generated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Generated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_generated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_file(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_file(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.File, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_file(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_name(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_short_name(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_short_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_short_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_website(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_website(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Website, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_website(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_tags(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Tags)
	fc.Result = res
	return ec.marshalOTags2githubcominterlineiotransitlandlibttTags(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Tags does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_search_rank(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_search_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_search_rank(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_agencies(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_agencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Operator().Agencies(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Agency)
	fc.Result = res
	return ec.marshalOAgency2githubcominterlineiotransitlandlibservermodelAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_agencies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Agency_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Agency_onestop_id(ctx, field)
			case "agency_email":
				return ec.fieldContext_Agency_agency_email(ctx, field)
			case "agency_fare_url":
				return ec.fieldContext_Agency_agency_fare_url(ctx, field)
			case "agency_id":
				return ec.fieldContext_Agency_agency_id(ctx, field)
			case "agency_lang":
				return ec.fieldContext_Agency_agency_lang(ctx, field)
			case "agency_name":
				return ec.fieldContext_Agency_agency_name(ctx, field)
			case "agency_phone":
				return ec.fieldContext_Agency_agency_phone(ctx, field)
			case "agency_timezone":
				return ec.fieldContext_Agency_agency_timezone(ctx, field)
			case "agency_url":
				return ec.fieldContext_Agency_agency_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Agency_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Agency_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Agency_feed_version(ctx, field)
			case "geometry":
				return ec.fieldContext_Agency_geometry(ctx, field)
			case "search_rank":
				return ec.fieldContext_Agency_search_rank(ctx, field)
			case "operator":
				return ec.fieldContext_Agency_operator(ctx, field)
			case "places":
				return ec.fieldContext_Agency_places(ctx, field)
			case "routes":
				return ec.fieldContext_Agency_routes(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Agency_census_geographies(ctx, field)
			case "alerts":
				return ec.fieldContext_Agency_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Agency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_feeds(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_feeds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Operator().Feeds(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.FeedFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Feed)
	fc.Result = res
	return ec.marshalOFeed2githubcominterlineiotransitlandlibservermodelFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_feeds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Feed_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "file":
				return ec.fieldContext_Feed_file(ctx, field)
			case "spec":
				return ec.fieldContext_Feed_spec(ctx, field)
			case "languages":
				return ec.fieldContext_Feed_languages(ctx, field)
			case "tags":
				return ec.fieldContext_Feed_tags(ctx, field)
			case "authorization":
				return ec.fieldContext_Feed_authorization(ctx, field)
			case "urls":
				return ec.fieldContext_Feed_urls(ctx, field)
			case "license":
				return ec.fieldContext_Feed_license(ctx, field)
			case "search_rank":
				return ec.fieldContext_Feed_search_rank(ctx, field)
			case "associated_operators":
				return ec.fieldContext_Feed_associated_operators(ctx, field)
			case "feed_state":
				return ec.fieldContext_Feed_feed_state(ctx, field)
			case "feed_fetches":
				return ec.fieldContext_Feed_feed_fetches(ctx, field)
			case "feed_versions":
				return ec.fieldContext_Feed_feed_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Operator_feeds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_id(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_pathway_id(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_pathway_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PathwayID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_pathway_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_pathway_mode(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_pathway_mode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PathwayMode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_pathway_mode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_is_bidirectional(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_is_bidirectional(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsBidirectional, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_is_bidirectional(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_length(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_length(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Length, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_length(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_traversal_time(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_traversal_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TraversalTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_traversal_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_stair_count(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_stair_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StairCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_stair_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_max_slope(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_max_slope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxSlope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_max_slope(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_min_width(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_min_width(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinWidth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_min_width(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_signposted_as(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_signposted_as(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignpostedAs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_signposted_as(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_reverse_signposted_as(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_reverse_signposted_as(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReverseSignpostedAs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_reverse_signposted_as(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_from_stop(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_from_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pathway().FromStop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_from_stop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_to_stop(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_to_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pathway().ToStop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_to_stop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Place_adm0_name(ctx context.Context, field graphql.CollectedField, obj *model.Place) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Place_adm0_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm0Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Place_adm0_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Place",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Place_adm1_name(ctx context.Context, field graphql.CollectedField, obj *model.Place) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Place_adm1_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm1Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Place_adm1_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Place",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Place_city_name(ctx context.Context, field graphql.CollectedField, obj *model.Place) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Place_city_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Place_city_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Place",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Place_count(ctx context.Context, field graphql.CollectedField, obj *model.Place) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Place_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Place().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Place_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Place",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Place_operators(ctx context.Context, field graphql.CollectedField, obj *model.Place) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Place_operators(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Place().Operators(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Operator)
	fc.Result = res
	return ec.marshalOOperator2githubcominterlineiotransitlandlibservermodelOperator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Place_operators(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Place",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Operator_id(ctx, field)
			case "generated":
				return ec.fieldContext_Operator_generated(ctx, field)
			case "file":
				return ec.fieldContext_Operator_file(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Operator_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Operator_name(ctx, field)
			case "short_name":
				return ec.fieldContext_Operator_short_name(ctx, field)
			case "website":
				return ec.fieldContext_Operator_website(ctx, field)
			case "tags":
				return ec.fieldContext_Operator_tags(ctx, field)
			case "search_rank":
				return ec.fieldContext_Operator_search_rank(ctx, field)
			case "agencies":
				return ec.fieldContext_Operator_agencies(ctx, field)
			case "feeds":
				return ec.fieldContext_Operator_feeds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Operator", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_feeds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_feeds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Feeds(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.FeedFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Feed)
	fc.Result = res
	return ec.marshalNFeed2githubcominterlineiotransitlandlibservermodelFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_feeds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Feed_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "file":
				return ec.fieldContext_Feed_file(ctx, field)
			case "spec":
				return ec.fieldContext_Feed_spec(ctx, field)
			case "languages":
				return ec.fieldContext_Feed_languages(ctx, field)
			case "tags":
				return ec.fieldContext_Feed_tags(ctx, field)
			case "authorization":
				return ec.fieldContext_Feed_authorization(ctx, field)
			case "urls":
				return ec.fieldContext_Feed_urls(ctx, field)
			case "license":
				return ec.fieldContext_Feed_license(ctx, field)
			case "search_rank":
				return ec.fieldContext_Feed_search_rank(ctx, field)
			case "associated_operators":
				return ec.fieldContext_Feed_associated_operators(ctx, field)
			case "feed_state":
				return ec.fieldContext_Feed_feed_state(ctx, field)
			case "feed_fetches":
				return ec.fieldContext_Feed_feed_fetches(ctx, field)
			case "feed_versions":
				return ec.fieldContext_Feed_feed_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_feeds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_operators(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_operators(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Operators(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.OperatorFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Operator)
	fc.Result = res
	return ec.marshalNOperator2githubcominterlineiotransitlandlibservermodelOperator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_operators(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Operator_id(ctx, field)
			case "generated":
				return ec.fieldContext_Operator_generated(ctx, field)
			case "file":
				return ec.fieldContext_Operator_file(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Operator_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Operator_name(ctx, field)
			case "short_name":
				return ec.fieldContext_Operator_short_name(ctx, field)
			case "website":
				return ec.fieldContext_Operator_website(ctx, field)
			case "tags":
				return ec.fieldContext_Operator_tags(ctx, field)
			case "search_rank":
				return ec.fieldContext_Operator_search_rank(ctx, field)
			case "agencies":
				return ec.fieldContext_Operator_agencies(ctx, field)
			case "feeds":
				return ec.fieldContext_Operator_feeds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Operator", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_operators_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_feed_versions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_feed_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FeedVersions(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.FeedVersionFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_feed_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "service_window":
				return ec.fieldContext_FeedVersion_service_window(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "locations":
				return ec.fieldContext_FeedVersion_locations(ctx, field)
			case "booking_rules":
				return ec.fieldContext_FeedVersion_booking_rules(ctx, field)
			case "location_groups":
				return ec.fieldContext_FeedVersion_location_groups(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			case "validation_reports":
				return ec.fieldContext_FeedVersion_validation_reports(ctx, field)
			case "segments":
				return ec.fieldContext_FeedVersion_segments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_feed_versions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_agencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_agencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Agencies(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.AgencyFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Agency)
	fc.Result = res
	return ec.marshalNAgency2githubcominterlineiotransitlandlibservermodelAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_agencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Agency_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Agency_onestop_id(ctx, field)
			case "agency_email":
				return ec.fieldContext_Agency_agency_email(ctx, field)
			case "agency_fare_url":
				return ec.fieldContext_Agency_agency_fare_url(ctx, field)
			case "agency_id":
				return ec.fieldContext_Agency_agency_id(ctx, field)
			case "agency_lang":
				return ec.fieldContext_Agency_agency_lang(ctx, field)
			case "agency_name":
				return ec.fieldContext_Agency_agency_name(ctx, field)
			case "agency_phone":
				return ec.fieldContext_Agency_agency_phone(ctx, field)
			case "agency_timezone":
				return ec.fieldContext_Agency_agency_timezone(ctx, field)
			case "agency_url":
				return ec.fieldContext_Agency_agency_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Agency_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Agency_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Agency_feed_version(ctx, field)
			case "geometry":
				return ec.fieldContext_Agency_geometry(ctx, field)
			case "search_rank":
				return ec.fieldContext_Agency_search_rank(ctx, field)
			case "operator":
				return ec.fieldContext_Agency_operator(ctx, field)
			case "places":
				return ec.fieldContext_Agency_places(ctx, field)
			case "routes":
				return ec.fieldContext_Agency_routes(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Agency_census_geographies(ctx, field)
			case "alerts":
				return ec.fieldContext_Agency_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Agency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_agencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_routes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_routes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Routes(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.RouteFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandlibservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_routes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			case "segments":
				return ec.fieldContext_Route_segments(ctx, field)
			case "segment_patterns":
				return ec.fieldContext_Route_segment_patterns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_routes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_stops(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Stops(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.StopFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_trips(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_trips(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Trips(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.TripFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Trip)
	fc.Result = res
	return ec.marshalNTrip2githubcominterlineiotransitlandlibservermodelTrip(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_trips(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trip_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_Trip_trip_id(ctx, field)
			case "trip_headsign":
				return ec.fieldContext_Trip_trip_headsign(ctx, field)
			case "trip_short_name":
				return ec.fieldContext_Trip_trip_short_name(ctx, field)
			case "direction_id":
				return ec.fieldContext_Trip_direction_id(ctx, field)
			case "block_id":
				return ec.fieldContext_Trip_block_id(ctx, field)
			case "wheelchair_accessible":
				return ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
			case "bikes_allowed":
				return ec.fieldContext_Trip_bikes_allowed(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_Trip_stop_pattern_id(ctx, field)
			case "calendar":
				return ec.fieldContext_Trip_calendar(ctx, field)
			case "route":
				return ec.fieldContext_Trip_route(ctx, field)
			case "shape":
				return ec.fieldContext_Trip_shape(ctx, field)
			case "feed_version":
				return ec.fieldContext_Trip_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Trip_stop_times(ctx, field)
			case "flex_stop_times":
				return ec.fieldContext_Trip_flex_stop_times(ctx, field)
			case "frequencies":
				return ec.fieldContext_Trip_frequencies(ctx, field)
			case "alerts":
				return ec.fieldContext_Trip_alerts(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_Trip_schedule_relationship(ctx, field)
			case "timestamp":
				return ec.fieldContext_Trip_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trip", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_trips_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_places(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_places(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Places(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["level"].(*model.PlaceAggregationLevel), fc.Args["where"].(*model.PlaceFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Place)
	fc.Result = res
	return ec.marshalOPlace2githubcominterlineiotransitlandlibservermodelPlace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_places(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adm0_name":
				return ec.fieldContext_Place_adm0_name(ctx, field)
			case "adm1_name":
				return ec.fieldContext_Place_adm1_name(ctx, field)
			case "city_name":
				return ec.fieldContext_Place_city_name(ctx, field)
			case "count":
				return ec.fieldContext_Place_count(ctx, field)
			case "operators":
				return ec.fieldContext_Place_operators(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Place", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_places_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_directions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_directions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Directions(rctx, fc.Args["where"].(model.DirectionRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Directions)
	fc.Result = res
	return ec.marshalNDirections2githubcominterlineiotransitlandlibservermodelDirections(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_directions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_Directions_success(ctx, field)
			case "exception":
				return ec.fieldContext_Directions_exception(ctx, field)
			case "data_source":
				return ec.fieldContext_Directions_data_source(ctx, field)
			case "origin":
				return ec.fieldContext_Directions_origin(ctx, field)
			case "destination":
				return ec.fieldContext_Directions_destination(ctx, field)
			case "duration":
				return ec.fieldContext_Directions_duration(ctx, field)
			case "distance":
				return ec.fieldContext_Directions_distance(ctx, field)
			case "start_time":
				return ec.fieldContext_Directions_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_Directions_end_time(ctx, field)
			case "itineraries":
				return ec.fieldContext_Directions_itineraries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Directions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_directions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_bikes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bikes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Bikes(rctx, fc.Args["limit"].(*int), fc.Args["where"].(*model.GbfsBikeRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsFreeBikeStatus)
	fc.Result = res
	return ec.marshalOGbfsFreeBikeStatus2githubcominterlineiotransitlandlibservermodelGbfsFreeBikeStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bikes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bike_id":
				return ec.fieldContext_GbfsFreeBikeStatus_bike_id(ctx, field)
			case "lat":
				return ec.fieldContext_GbfsFreeBikeStatus_lat(ctx, field)
			case "lon":
				return ec.fieldContext_GbfsFreeBikeStatus_lon(ctx, field)
			case "is_reserved":
				return ec.fieldContext_GbfsFreeBikeStatus_is_reserved(ctx, field)
			case "is_disabled":
				return ec.fieldContext_GbfsFreeBikeStatus_is_disabled(ctx, field)
			case "last_reported":
				return ec.fieldContext_GbfsFreeBikeStatus_last_reported(ctx, field)
			case "current_range_meters":
				return ec.fieldContext_GbfsFreeBikeStatus_current_range_meters(ctx, field)
			case "current_fuel_percent":
				return ec.fieldContext_GbfsFreeBikeStatus_current_fuel_percent(ctx, field)
			case "vehicle_equipment":
				return ec.fieldContext_GbfsFreeBikeStatus_vehicle_equipment(ctx, field)
			case "available_until":
				return ec.fieldContext_GbfsFreeBikeStatus_available_until(ctx, field)
			case "station":
				return ec.fieldContext_GbfsFreeBikeStatus_station(ctx, field)
			case "home_station":
				return ec.fieldContext_GbfsFreeBikeStatus_home_station(ctx, field)
			case "pricing_plan":
				return ec.fieldContext_GbfsFreeBikeStatus_pricing_plan(ctx, field)
			case "vehicle_type":
				return ec.fieldContext_GbfsFreeBikeStatus_vehicle_type(ctx, field)
			case "rental_uris":
				return ec.fieldContext_GbfsFreeBikeStatus_rental_uris(ctx, field)
			case "feed":
				return ec.fieldContext_GbfsFreeBikeStatus_feed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsFreeBikeStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bikes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_docks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_docks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Docks(rctx, fc.Args["limit"].(*int), fc.Args["where"].(*model.GbfsDockRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsStationInformation)
	fc.Result = res
	return ec.marshalOGbfsStationInformation2githubcominterlineiotransitlandlibservermodelGbfsStationInformation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_docks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "station_id":
				return ec.fieldContext_GbfsStationInformation_station_id(ctx, field)
			case "name":
				return ec.fieldContext_GbfsStationInformation_name(ctx, field)
			case "short_name":
				return ec.fieldContext_GbfsStationInformation_short_name(ctx, field)
			case "lat":
				return ec.fieldContext_GbfsStationInformation_lat(ctx, field)
			case "lon":
				return ec.fieldContext_GbfsStationInformation_lon(ctx, field)
			case "address":
				return ec.fieldContext_GbfsStationInformation_address(ctx, field)
			case "cross_street":
				return ec.fieldContext_GbfsStationInformation_cross_street(ctx, field)
			case "post_code":
				return ec.fieldContext_GbfsStationInformation_post_code(ctx, field)
			case "rental_methods":
				return ec.fieldContext_GbfsStationInformation_rental_methods(ctx, field)
			case "is_virtual_station":
				return ec.fieldContext_GbfsStationInformation_is_virtual_station(ctx, field)
			case "station_area":
				return ec.fieldContext_GbfsStationInformation_station_area(ctx, field)
			case "parking_type":
				return ec.fieldContext_GbfsStationInformation_parking_type(ctx, field)
			case "parking_hoop":
				return ec.fieldContext_GbfsStationInformation_parking_hoop(ctx, field)
			case "contact_phone":
				return ec.fieldContext_GbfsStationInformation_contact_phone(ctx, field)
			case "capacity":
				return ec.fieldContext_GbfsStationInformation_capacity(ctx, field)
			case "is_valet_station":
				return ec.fieldContext_GbfsStationInformation_is_valet_station(ctx, field)
			case "is_charging_station":
				return ec.fieldContext_GbfsStationInformation_is_charging_station(ctx, field)
			case "feed":
				return ec.fieldContext_GbfsStationInformation_feed(ctx, field)
			case "region":
				return ec.fieldContext_GbfsStationInformation_region(ctx, field)
			case "status":
				return ec.fieldContext_GbfsStationInformation_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsStationInformation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_docks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Me(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Me)
	fc.Result = res
	return ec.marshalNMe2githubcominterlineiotransitlandlibservermodelMe(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Me_id(ctx, field)
			case "name":
				return ec.fieldContext_Me_name(ctx, field)
			case "email":
				return ec.fieldContext_Me_email(ctx, field)
			case "roles":
				return ec.fieldContext_Me_roles(ctx, field)
			case "external_data":
				return ec.fieldContext_Me_external_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Me", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_census_datasets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_census_datasets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CensusDatasets(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.CensusDatasetFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusDataset)
	fc.Result = res
	return ec.marshalOCensusDataset2githubcominterlineiotransitlandlibservermodelCensusDataset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_census_datasets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusDataset_id(ctx, field)
			case "name":
				return ec.fieldContext_CensusDataset_name(ctx, field)
			case "description":
				return ec.fieldContext_CensusDataset_description(ctx, field)
			case "url":
				return ec.fieldContext_CensusDataset_url(ctx, field)
			case "year_min":
				return ec.fieldContext_CensusDataset_year_min(ctx, field)
			case "year_max":
				return ec.fieldContext_CensusDataset_year_max(ctx, field)
			case "sources":
				return ec.fieldContext_CensusDataset_sources(ctx, field)
			case "geographies":
				return ec.fieldContext_CensusDataset_geographies(ctx, field)
			case "tables":
				return ec.fieldContext_CensusDataset_tables(ctx, field)
			case "layers":
				return ec.fieldContext_CensusDataset_layers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusDataset", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_census_datasets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_census_values(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_census_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CensusValues(rctx, fc.Args["limit"].(*int), fc.Args["where"].(*model.CensusValueFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CensusValue)
	fc.Result = res
	return ec.marshalNCensusValue2githubcominterlineiotransitlandlibservermodelCensusValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_census_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dataset_name":
				return ec.fieldContext_CensusValue_dataset_name(ctx, field)
			case "source_name":
				return ec.fieldContext_CensusValue_source_name(ctx, field)
			case "table":
				return ec.fieldContext_CensusValue_table(ctx, field)
			case "values":
				return ec.fieldContext_CensusValue_values(ctx, field)
			case "geoid":
				return ec.fieldContext_CensusValue_geoid(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_census_values_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTimeRange_start(ctx context.Context, field graphql.CollectedField, obj *model.RTTimeRange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTimeRange_start(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTimeRange_start(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTimeRange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTimeRange_end(ctx context.Context, field graphql.CollectedField, obj *model.RTTimeRange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTimeRange_end(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.End, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTimeRange_end(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTimeRange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTranslation_text(ctx context.Context, field graphql.CollectedField, obj *model.RTTranslation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTranslation_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTranslation_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTranslation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTranslation_language(ctx context.Context, field graphql.CollectedField, obj *model.RTTranslation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTranslation_language(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTranslation_language(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTranslation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTripDescriptor_trip_id(ctx context.Context, field graphql.CollectedField, obj *model.RTTripDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTripDescriptor_trip_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTripDescriptor_trip_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTripDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTripDescriptor_route_id(ctx context.Context, field graphql.CollectedField, obj *model.RTTripDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTripDescriptor_route_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTripDescriptor_route_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTripDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTripDescriptor_direction_id(ctx context.Context, field graphql.CollectedField, obj *model.RTTripDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTripDescriptor_direction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DirectionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTripDescriptor_direction_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTripDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTripDescriptor_start_time(ctx context.Context, field graphql.CollectedField, obj *model.RTTripDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTripDescriptor_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTripDescriptor_start_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTripDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTripDescriptor_start_date(ctx context.Context, field graphql.CollectedField, obj *model.RTTripDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTripDescriptor_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTripDescriptor_start_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTripDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTripDescriptor_schedule_relationship(ctx context.Context, field graphql.CollectedField, obj *model.RTTripDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTripDescriptor_schedule_relationship(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduleRelationship, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTripDescriptor_schedule_relationship(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTripDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTVehicleDescriptor_id(ctx context.Context, field graphql.CollectedField, obj *model.RTVehicleDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTVehicleDescriptor_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTVehicleDescriptor_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTVehicleDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTVehicleDescriptor_label(ctx context.Context, field graphql.CollectedField, obj *model.RTVehicleDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTVehicleDescriptor_label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTVehicleDescriptor_label(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTVehicleDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTVehicleDescriptor_license_plate(ctx context.Context, field graphql.CollectedField, obj *model.RTVehicleDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTVehicleDescriptor_license_plate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LicensePlate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTVehicleDescriptor_license_plate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTVehicleDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_id(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_id(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_short_name(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_short_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_short_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_long_name(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_long_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteLongName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_long_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_type(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_color(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteColor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Color)
	fc.Result = res
	return ec.marshalOColor2githubcominterlineiotransitlandlibttColor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_text_color(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_text_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteTextColor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Color)
	fc.Result = res
	return ec.marshalOColor2githubcominterlineiotransitlandlibttColor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_text_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_sort_order(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_sort_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteSortOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_sort_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_url(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Url)
	fc.Result = res
	return ec.marshalOUrl2githubcominterlineiotransitlandlibttUrl(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_desc(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteDesc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_continuous_pickup(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_continuous_pickup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContinuousPickup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_continuous_pickup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_continuous_drop_off(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_continuous_drop_off(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContinuousDropOff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_continuous_drop_off(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Geometry(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_agency(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_agency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Agency(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Agency)
	fc.Result = res
	return ec.marshalNAgency2githubcominterlineiotransitlandlibservermodelAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_agency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Agency_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Agency_onestop_id(ctx, field)
			case "agency_email":
				return ec.fieldContext_Agency_agency_email(ctx, field)
			case "agency_fare_url":
				return ec.fieldContext_Agency_agency_fare_url(ctx, field)
			case "agency_id":
				return ec.fieldContext_Agency_agency_id(ctx, field)
			case "agency_lang":
				return ec.fieldContext_Agency_agency_lang(ctx, field)
			case "agency_name":
				return ec.fieldContext_Agency_agency_name(ctx, field)
			case "agency_phone":
				return ec.fieldContext_Agency_agency_phone(ctx, field)
			case "agency_timezone":
				return ec.fieldContext_Agency_agency_timezone(ctx, field)
			case "agency_url":
				return ec.fieldContext_Agency_agency_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Agency_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Agency_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Agency_feed_version(ctx, field)
			case "geometry":
				return ec.fieldContext_Agency_geometry(ctx, field)
			case "search_rank":
				return ec.fieldContext_Agency_search_rank(ctx, field)
			case "operator":
				return ec.fieldContext_Agency_operator(ctx, field)
			case "places":
				return ec.fieldContext_Agency_places(ctx, field)
			case "routes":
				return ec.fieldContext_Agency_routes(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Agency_census_geographies(ctx, field)
			case "alerts":
				return ec.fieldContext_Agency_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Agency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_feed_version_sha1(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_feed_version_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersionSHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_feed_version_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_feed_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_feed_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "service_window":
				return ec.fieldContext_FeedVersion_service_window(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "locations":
				return ec.fieldContext_FeedVersion_locations(ctx, field)
			case "booking_rules":
				return ec.fieldContext_FeedVersion_booking_rules(ctx, field)
			case "location_groups":
				return ec.fieldContext_FeedVersion_location_groups(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			case "validation_reports":
				return ec.fieldContext_FeedVersion_validation_reports(ctx, field)
			case "segments":
				return ec.fieldContext_FeedVersion_segments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_search_rank(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_search_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_search_rank(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_attribute(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_attribute(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().RouteAttribute(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouteAttribute)
	fc.Result = res
	return ec.marshalORouteAttribute2githubcominterlineiotransitlandlibservermodelRouteAttribute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_attribute(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "category":
				return ec.fieldContext_RouteAttribute_category(ctx, field)
			case "subcategory":
				return ec.fieldContext_RouteAttribute_subcategory(ctx, field)
			case "running_way":
				return ec.fieldContext_RouteAttribute_running_way(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteAttribute", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_trips(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_trips(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Trips(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.TripFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Trip)
	fc.Result = res
	return ec.marshalNTrip2githubcominterlineiotransitlandlibservermodelTrip(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_trips(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trip_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_Trip_trip_id(ctx, field)
			case "trip_headsign":
				return ec.fieldContext_Trip_trip_headsign(ctx, field)
			case "trip_short_name":
				return ec.fieldContext_Trip_trip_short_name(ctx, field)
			case "direction_id":
				return ec.fieldContext_Trip_direction_id(ctx, field)
			case "block_id":
				return ec.fieldContext_Trip_block_id(ctx, field)
			case "wheelchair_accessible":
				return ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
			case "bikes_allowed":
				return ec.fieldContext_Trip_bikes_allowed(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_Trip_stop_pattern_id(ctx, field)
			case "calendar":
				return ec.fieldContext_Trip_calendar(ctx, field)
			case "route":
				return ec.fieldContext_Trip_route(ctx, field)
			case "shape":
				return ec.fieldContext_Trip_shape(ctx, field)
			case "feed_version":
				return ec.fieldContext_Trip_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Trip_stop_times(ctx, field)
			case "flex_stop_times":
				return ec.fieldContext_Trip_flex_stop_times(ctx, field)
			case "frequencies":
				return ec.fieldContext_Trip_frequencies(ctx, field)
			case "alerts":
				return ec.fieldContext_Trip_alerts(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_Trip_schedule_relationship(ctx, field)
			case "timestamp":
				return ec.fieldContext_Trip_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trip", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_trips_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Route_stops(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Stops(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_stops(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().RouteStops(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RouteStop)
	fc.Result = res
	return ec.marshalNRouteStop2githubcominterlineiotransitlandlibservermodelRouteStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RouteStop_id(ctx, field)
			case "stop_id":
				return ec.fieldContext_RouteStop_stop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_RouteStop_route_id(ctx, field)
			case "agency_id":
				return ec.fieldContext_RouteStop_agency_id(ctx, field)
			case "route":
				return ec.fieldContext_RouteStop_route(ctx, field)
			case "stop":
				return ec.fieldContext_RouteStop_stop(ctx, field)
			case "agency":
				return ec.fieldContext_RouteStop_agency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteStop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_route_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Route_headways(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_headways(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Headways(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RouteHeadway)
	fc.Result = res
	return ec.marshalNRouteHeadway2githubcominterlineiotransitlandlibservermodelRouteHeadway(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_headways(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stop":
				return ec.fieldContext_RouteHeadway_stop(ctx, field)
			case "dow_category":
				return ec.fieldContext_RouteHeadway_dow_category(ctx, field)
			case "direction_id":
				return ec.fieldContext_RouteHeadway_direction_id(ctx, field)
			case "headway_secs":
				return ec.fieldContext_RouteHeadway_headway_secs(ctx, field)
			case "service_date":
				return ec.fieldContext_RouteHeadway_service_date(ctx, field)
			case "stop_trip_count":
				return ec.fieldContext_RouteHeadway_stop_trip_count(ctx, field)
			case "departures":
				return ec.fieldContext_RouteHeadway_departures(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteHeadway", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_headways_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Route_geometries(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_geometries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Geometries(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RouteGeometry)
	fc.Result = res
	return ec.marshalNRouteGeometry2githubcominterlineiotransitlandlibservermodelRouteGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_geometries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "generated":
				return ec.fieldContext_RouteGeometry_generated(ctx, field)
			case "geometry":
				return ec.fieldContext_RouteGeometry_geometry(ctx, field)
			case "combined_geometry":
				return ec.fieldContext_RouteGeometry_combined_geometry(ctx, field)
			case "length":
				return ec.fieldContext_RouteGeometry_length(ctx, field)
			case "max_segment_length":
				return ec.fieldContext_RouteGeometry_max_segment_length(ctx, field)
			case "first_point_max_distance":
				return ec.fieldContext_RouteGeometry_first_point_max_distance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteGeometry", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_geometries_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Route_census_geographies(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_census_geographies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().CensusGeographies(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.CensusGeographyFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusGeography)
	fc.Result = res
	return ec.marshalOCensusGeography2githubcominterlineiotransitlandlibservermodelCensusGeography(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_census_geographies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusGeography_id(ctx, field)
			case "dataset_name":
				return ec.fieldContext_CensusGeography_dataset_name(ctx, field)
			case "source_name":
				return ec.fieldContext_CensusGeography_source_name(ctx, field)
			case "layer_name":
				return ec.fieldContext_CensusGeography_layer_name(ctx, field)
			case "geoid":
				return ec.fieldContext_CensusGeography_geoid(ctx, field)
			case "name":
				return ec.fieldContext_CensusGeography_name(ctx, field)
			case "geometry_area":
				return ec.fieldContext_CensusGeography_geometry_area(ctx, field)
			case "aland":
				return ec.fieldContext_CensusGeography_aland(ctx, field)
			case "awater":
				return ec.fieldContext_CensusGeography_awater(ctx, field)
			case "adm1_name":
				return ec.fieldContext_CensusGeography_adm1_name(ctx, field)
			case "adm1_iso":
				return ec.fieldContext_CensusGeography_adm1_iso(ctx, field)
			case "adm0_name":
				return ec.fieldContext_CensusGeography_adm0_name(ctx, field)
			case "adm0_iso":
				return ec.fieldContext_CensusGeography_adm0_iso(ctx, field)
			case "geometry":
				return ec.fieldContext_CensusGeography_geometry(ctx, field)
			case "intersection_area":
				return ec.fieldContext_CensusGeography_intersection_area(ctx, field)
			case "intersection_geometry":
				return ec.fieldContext_CensusGeography_intersection_geometry(ctx, field)
			case "values":
				return ec.fieldContext_CensusGeography_values(ctx, field)
			case "layer":
				return ec.fieldContext_CensusGeography_layer(ctx, field)
			case "source":
				return ec.fieldContext_CensusGeography_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusGeography", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_census_geographies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_stop_buffer(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_stop_buffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().RouteStopBuffer(rctx, obj, fc.Args["radius"].(*float64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RouteStopBuffer)
	fc.Result = res
	return ec.marshalNRouteStopBuffer2githubcominterlineiotransitlandlibservermodelRouteStopBuffer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_stop_buffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stop_buffer":
				return ec.fieldContext_RouteStopBuffer_stop_buffer(ctx, field)
			case "stop_points":
				return ec.fieldContext_RouteStopBuffer_stop_points(ctx, field)
			case "stop_convexhull":
				return ec.fieldContext_RouteStopBuffer_stop_convexhull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteStopBuffer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_route_stop_buffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Route_patterns(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_patterns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Patterns(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RouteStopPattern)
	fc.Result = res
	return ec.marshalORouteStopPattern2githubcominterlineiotransitlandlibservermodelRouteStopPattern(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_patterns(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stop_pattern_id":
				return ec.fieldContext_RouteStopPattern_stop_pattern_id(ctx, field)
			case "direction_id":
				return ec.fieldContext_RouteStopPattern_direction_id(ctx, field)
			case "count":
				return ec.fieldContext_RouteStopPattern_count(ctx, field)
			case "trips":
				return ec.fieldContext_RouteStopPattern_trips(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteStopPattern", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_alerts(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Alerts(rctx, obj, fc.Args["active"].(*bool), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Alert)
	fc.Result = res
	return ec.marshalOAlert2githubcominterlineiotransitlandlibservermodelAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "active_period":
				return ec.fieldContext_Alert_active_period(ctx, field)
			case "cause":
				return ec.fieldContext_Alert_cause(ctx, field)
			case "effect":
				return ec.fieldContext_Alert_effect(ctx, field)
			case "header_text":
				return ec.fieldContext_Alert_header_text(ctx, field)
			case "description_text":
				return ec.fieldContext_Alert_description_text(ctx, field)
			case "tts_header_text":
				return ec.fieldContext_Alert_tts_header_text(ctx, field)
			case "tts_description_text":
				return ec.fieldContext_Alert_tts_description_text(ctx, field)
			case "url":
				return ec.fieldContext_Alert_url(ctx, field)
			case "severity_level":
				return ec.fieldContext_Alert_severity_level(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_alerts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Route_segments(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_segments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Segments(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.SegmentFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Segment)
	fc.Result = res
	return ec.marshalOSegment2githubcominterlineiotransitlandlibservermodelSegment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_segments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Segment_id(ctx, field)
			case "way_id":
				return ec.fieldContext_Segment_way_id(ctx, field)
			case "geometry":
				return ec.fieldContext_Segment_geometry(ctx, field)
			case "segment_patterns":
				return ec.fieldContext_Segment_segment_patterns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Segment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_segments_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Route_segment_patterns(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_segment_patterns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().SegmentPatterns(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.SegmentPatternFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.SegmentPattern)
	fc.Result = res
	return ec.marshalOSegmentPattern2githubcominterlineiotransitlandlibservermodelSegmentPattern(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_segment_patterns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SegmentPattern_id(ctx, field)
			case "route":
				return ec.fieldContext_SegmentPattern_route(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_SegmentPattern_stop_pattern_id(ctx, field)
			case "segment":
				return ec.fieldContext_SegmentPattern_segment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SegmentPattern", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_segment_patterns_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _RouteAttribute_category(ctx context.Context, field graphql.CollectedField, obj *model.RouteAttribute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteAttribute_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteAttribute_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteAttribute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteAttribute_subcategory(ctx context.Context, field graphql.CollectedField, obj *model.RouteAttribute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteAttribute_subcategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subcategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteAttribute_subcategory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteAttribute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteAttribute_running_way(ctx context.Context, field graphql.CollectedField, obj *model.RouteAttribute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteAttribute_running_way(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunningWay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteAttribute_running_way(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteAttribute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteGeometry_generated(ctx context.Context, field graphql.CollectedField, obj *model.RouteGeometry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteGeometry_generated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Generated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteGeometry_generated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteGeometry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteGeometry_geometry(ctx context.Context, field graphql.CollectedField, obj *model.RouteGeometry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteGeometry_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.LineString)
	fc.Result = res
	return ec.marshalOLineString2githubcominterlineiotransitlandlibttLineString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteGeometry_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteGeometry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LineString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteGeometry_combined_geometry(ctx context.Context, field graphql.CollectedField, obj *model.RouteGeometry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteGeometry_combined_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CombinedGeometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteGeometry_combined_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteGeometry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteGeometry_length(ctx context.Context, field graphql.CollectedField, obj *model.RouteGeometry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteGeometry_length(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Length, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteGeometry_length(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteGeometry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteGeometry_max_segment_length(ctx context.Context, field graphql.CollectedField, obj *model.RouteGeometry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteGeometry_max_segment_length(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxSegmentLength, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteGeometry_max_segment_length(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteGeometry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteGeometry_first_point_max_distance(ctx context.Context, field graphql.CollectedField, obj *model.RouteGeometry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteGeometry_first_point_max_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstPointMaxDistance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteGeometry_first_point_max_distance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteGeometry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_stop(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RouteHeadway().Stop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_stop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_dow_category(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_dow_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DowCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_dow_category(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_direction_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_direction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DirectionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_direction_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_headway_secs(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_headway_secs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadwaySecs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_headway_secs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_service_date(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_service_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_service_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_stop_trip_count(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_stop_trip_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopTripCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_stop_trip_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_departures(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_departures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RouteHeadway().Departures(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_departures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_stop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_route_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_route_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_route_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_agency_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_agency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_agency_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_route(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RouteStop().Route(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandlibservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_route(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			case "segments":
				return ec.fieldContext_Route_segments(ctx, field)
			case "segment_patterns":
				return ec.fieldContext_Route_segment_patterns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_stop(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RouteStop().Stop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_stop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_agency(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_agency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RouteStop().Agency(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Agency)
	fc.Result = res
	return ec.marshalNAgency2githubcominterlineiotransitlandlibservermodelAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_agency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Agency_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Agency_onestop_id(ctx, field)
			case "agency_email":
				return ec.fieldContext_Agency_agency_email(ctx, field)
			case "agency_fare_url":
				return ec.fieldContext_Agency_agency_fare_url(ctx, field)
			case "agency_id":
				return ec.fieldContext_Agency_agency_id(ctx, field)
			case "agency_lang":
				return ec.fieldContext_Agency_agency_lang(ctx, field)
			case "agency_name":
				return ec.fieldContext_Agency_agency_name(ctx, field)
			case "agency_phone":
				return ec.fieldContext_Agency_agency_phone(ctx, field)
			case "agency_timezone":
				return ec.fieldContext_Agency_agency_timezone(ctx, field)
			case "agency_url":
				return ec.fieldContext_Agency_agency_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Agency_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Agency_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Agency_feed_version(ctx, field)
			case "geometry":
				return ec.fieldContext_Agency_geometry(ctx, field)
			case "search_rank":
				return ec.fieldContext_Agency_search_rank(ctx, field)
			case "operator":
				return ec.fieldContext_Agency_operator(ctx, field)
			case "places":
				return ec.fieldContext_Agency_places(ctx, field)
			case "routes":
				return ec.fieldContext_Agency_routes(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Agency_census_geographies(ctx, field)
			case "alerts":
				return ec.fieldContext_Agency_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Agency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopBuffer_stop_buffer(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopBuffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopBuffer_stop_buffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopBuffer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopBuffer_stop_buffer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopBuffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopBuffer_stop_points(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopBuffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopBuffer_stop_points(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopPoints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopBuffer_stop_points(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopBuffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopBuffer_stop_convexhull(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopBuffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopBuffer_stop_convexhull(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopConvexhull, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Polygon)
	fc.Result = res
	return ec.marshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopBuffer_stop_convexhull(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopBuffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Polygon does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopPattern_stop_pattern_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopPattern) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopPattern_stop_pattern_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopPatternID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopPattern_stop_pattern_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopPattern",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopPattern_direction_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopPattern) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopPattern_direction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DirectionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopPattern_direction_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopPattern",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopPattern_count(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopPattern) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopPattern_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopPattern_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopPattern",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopPattern_trips(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopPattern) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopPattern_trips(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RouteStopPattern().Trips(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Trip)
	fc.Result = res
	return ec.marshalOTrip2githubcominterlineiotransitlandlibservermodelTrip(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopPattern_trips(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopPattern",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trip_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_Trip_trip_id(ctx, field)
			case "trip_headsign":
				return ec.fieldContext_Trip_trip_headsign(ctx, field)
			case "trip_short_name":
				return ec.fieldContext_Trip_trip_short_name(ctx, field)
			case "direction_id":
				return ec.fieldContext_Trip_direction_id(ctx, field)
			case "block_id":
				return ec.fieldContext_Trip_block_id(ctx, field)
			case "wheelchair_accessible":
				return ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
			case "bikes_allowed":
				return ec.fieldContext_Trip_bikes_allowed(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_Trip_stop_pattern_id(ctx, field)
			case "calendar":
				return ec.fieldContext_Trip_calendar(ctx, field)
			case "route":
				return ec.fieldContext_Trip_route(ctx, field)
			case "shape":
				return ec.fieldContext_Trip_shape(ctx, field)
			case "feed_version":
				return ec.fieldContext_Trip_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Trip_stop_times(ctx, field)
			case "flex_stop_times":
				return ec.fieldContext_Trip_flex_stop_times(ctx, field)
			case "frequencies":
				return ec.fieldContext_Trip_frequencies(ctx, field)
			case "alerts":
				return ec.fieldContext_Trip_alerts(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_Trip_schedule_relationship(ctx, field)
			case "timestamp":
				return ec.fieldContext_Trip_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trip", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RouteStopPattern_trips_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Segment_id(ctx context.Context, field graphql.CollectedField, obj *model.Segment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Segment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Segment_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Segment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Segment_way_id(ctx context.Context, field graphql.CollectedField, obj *model.Segment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Segment_way_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WayID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Segment_way_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Segment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Segment_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Segment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Segment_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.LineString)
	fc.Result = res
	return ec.marshalNLineString2githubcominterlineiotransitlandlibttLineString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Segment_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Segment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LineString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Segment_segment_patterns(ctx context.Context, field graphql.CollectedField, obj *model.Segment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Segment_segment_patterns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Segment().SegmentPatterns(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.SegmentPattern)
	fc.Result = res
	return ec.marshalOSegmentPattern2githubcominterlineiotransitlandlibservermodelSegmentPattern(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Segment_segment_patterns(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Segment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_SegmentPattern_id(ctx, field)
			case "route":
				return ec.fieldContext_SegmentPattern_route(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_SegmentPattern_stop_pattern_id(ctx, field)
			case "segment":
				return ec.fieldContext_SegmentPattern_segment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SegmentPattern", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SegmentPattern_id(ctx context.Context, field graphql.CollectedField, obj *model.SegmentPattern) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SegmentPattern_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SegmentPattern_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SegmentPattern",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SegmentPattern_route(ctx context.Context, field graphql.CollectedField, obj *model.SegmentPattern) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SegmentPattern_route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SegmentPattern().Route(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandlibservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SegmentPattern_route(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SegmentPattern",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			case "segments":
				return ec.fieldContext_Route_segments(ctx, field)
			case "segment_patterns":
				return ec.fieldContext_Route_segment_patterns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SegmentPattern_stop_pattern_id(ctx context.Context, field graphql.CollectedField, obj *model.SegmentPattern) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SegmentPattern_stop_pattern_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopPatternID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SegmentPattern_stop_pattern_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SegmentPattern",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SegmentPattern_segment(ctx context.Context, field graphql.CollectedField, obj *model.SegmentPattern) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SegmentPattern_segment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SegmentPattern().Segment(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Segment)
	fc.Result = res
	return ec.marshalNSegment2githubcominterlineiotransitlandlibservermodelSegment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SegmentPattern_segment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SegmentPattern",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Segment_id(ctx, field)
			case "way_id":
				return ec.fieldContext_Segment_way_id(ctx, field)
			case "geometry":
				return ec.fieldContext_Segment_geometry(ctx, field)
			case "segment_patterns":
				return ec.fieldContext_Segment_segment_patterns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Segment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shape_id(ctx context.Context, field graphql.CollectedField, obj *model.Shape) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shape_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shape_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shape",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shape_shape_id(ctx context.Context, field graphql.CollectedField, obj *model.Shape) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shape_shape_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShapeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shape_shape_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shape",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shape_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Shape) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shape_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.LineString)
	fc.Result = res
	return ec.marshalNLineString2githubcominterlineiotransitlandlibttLineString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shape_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shape",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LineString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shape_generated(ctx context.Context, field graphql.CollectedField, obj *model.Shape) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shape_generated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Generated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shape_generated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shape",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_duration(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalNDuration2githubcominterlineiotransitlandlibservermodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Duration_duration(ctx, field)
			case "units":
				return ec.fieldContext_Duration_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Duration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_distance(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Distance)
	fc.Result = res
	return ec.marshalNDistance2githubcominterlineiotransitlandlibservermodelDistance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_distance(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distance":
				return ec.fieldContext_Distance_distance(ctx, field)
			case "units":
				return ec.fieldContext_Distance_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_start_time(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_start_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_end_time(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_end_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_to(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_to(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.To, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalOWaypoint2githubcominterlineiotransitlandlibservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_to(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			case "stop":
				return ec.fieldContext_Waypoint_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_mode(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_mode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.StepMode)
	fc.Result = res
	return ec.marshalNStepMode2githubcominterlineiotransitlandlibservermodelStepMode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_mode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StepMode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_instruction(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_instruction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Instruction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_instruction(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_geometry_offset(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_geometry_offset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GeometryOffset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_geometry_offset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_id(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_location_type(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_location_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_location_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_code(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_desc(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopDesc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_desc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_name(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_timezone(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopTimezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Timezone)
	fc.Result = res
	return ec.marshalOTimezone2githubcominterlineiotransitlandlibttTimezone(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_timezone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Timezone does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_url(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Url)
	fc.Result = res
	return ec.marshalOUrl2githubcominterlineiotransitlandlibttUrl(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Url does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_wheelchair_boarding(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WheelchairBoarding, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_wheelchair_boarding(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_zone_id(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_zone_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZoneID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_zone_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_platform_code(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_platform_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlatformCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_platform_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_tts_stop_name(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_tts_stop_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TtsStopName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_tts_stop_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Point)
	fc.Result = res
	return ec.marshalNPoint2githubcominterlineiotransitlandlibttPoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Point does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_feed_version_sha1(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_feed_version_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersionSHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_feed_version_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_feed_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_feed_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "service_window":
				return ec.fieldContext_FeedVersion_service_window(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "locations":
				return ec.fieldContext_FeedVersion_locations(ctx, field)
			case "booking_rules":
				return ec.fieldContext_FeedVersion_booking_rules(ctx, field)
			case "location_groups":
				return ec.fieldContext_FeedVersion_location_groups(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			case "validation_reports":
				return ec.fieldContext_FeedVersion_validation_reports(ctx, field)
			case "segments":
				return ec.fieldContext_FeedVersion_segments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_location_groups(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_location_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().LocationGroups(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.LocationGroup)
	fc.Result = res
	return ec.marshalNLocationGroup2githubcominterlineiotransitlandlibservermodelLocationGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_location_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationGroup_id(ctx, field)
			case "location_group_id":
				return ec.fieldContext_LocationGroup_location_group_id(ctx, field)
			case "location_group_name":
				return ec.fieldContext_LocationGroup_location_group_name(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_LocationGroup_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_LocationGroup_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_LocationGroup_feed_version(ctx, field)
			case "stops":
				return ec.fieldContext_LocationGroup_stops(ctx, field)
			case "stop_times":
				return ec.fieldContext_LocationGroup_stop_times(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationGroup", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_location_groups_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_level(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Level(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Level)
	fc.Result = res
	return ec.marshalOLevel2githubcominterlineiotransitlandlibservermodelLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Level_id(ctx, field)
			case "level_id":
				return ec.fieldContext_Level_level_id(ctx, field)
			case "level_index":
				return ec.fieldContext_Level_level_index(ctx, field)
			case "level_name":
				return ec.fieldContext_Level_level_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Level_geometry(ctx, field)
			case "stops":
				return ec.fieldContext_Level_stops(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Level", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_parent(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_parent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Parent(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalOStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_parent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_external_reference(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_external_reference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().ExternalReference(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StopExternalReference)
	fc.Result = res
	return ec.marshalOStopExternalReference2githubcominterlineiotransitlandlibservermodelStopExternalReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_external_reference(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_StopExternalReference_id(ctx, field)
			case "target_feed_onestop_id":
				return ec.fieldContext_StopExternalReference_target_feed_onestop_id(ctx, field)
			case "target_stop_id":
				return ec.fieldContext_StopExternalReference_target_stop_id(ctx, field)
			case "inactive":
				return ec.fieldContext_StopExternalReference_inactive(ctx, field)
			case "target_active_stop":
				return ec.fieldContext_StopExternalReference_target_active_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopExternalReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_observations(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_observations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Observations(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopObservationFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.StopObservation)
	fc.Result = res
	return ec.marshalOStopObservation2githubcominterlineiotransitlandlibservermodelStopObservation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_observations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "schedule_relationship":
				return ec.fieldContext_StopObservation_schedule_relationship(ctx, field)
			case "trip_start_date":
				return ec.fieldContext_StopObservation_trip_start_date(ctx, field)
			case "trip_start_time":
				return ec.fieldContext_StopObservation_trip_start_time(ctx, field)
			case "from_stop_id":
				return ec.fieldContext_StopObservation_from_stop_id(ctx, field)
			case "to_stop_id":
				return ec.fieldContext_StopObservation_to_stop_id(ctx, field)
			case "agency_id":
				return ec.fieldContext_StopObservation_agency_id(ctx, field)
			case "route_id":
				return ec.fieldContext_StopObservation_route_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_StopObservation_trip_id(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_StopObservation_stop_sequence(ctx, field)
			case "source":
				return ec.fieldContext_StopObservation_source(ctx, field)
			case "scheduled_arrival_time":
				return ec.fieldContext_StopObservation_scheduled_arrival_time(ctx, field)
			case "scheduled_departure_time":
				return ec.fieldContext_StopObservation_scheduled_departure_time(ctx, field)
			case "observed_arrival_time":
				return ec.fieldContext_StopObservation_observed_arrival_time(ctx, field)
			case "observed_departure_time":
				return ec.fieldContext_StopObservation_observed_departure_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopObservation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_observations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_children(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Children(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalOStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_children(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_children_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_route_stops(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_route_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().RouteStops(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RouteStop)
	fc.Result = res
	return ec.marshalNRouteStop2githubcominterlineiotransitlandlibservermodelRouteStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_route_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RouteStop_id(ctx, field)
			case "stop_id":
				return ec.fieldContext_RouteStop_stop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_RouteStop_route_id(ctx, field)
			case "agency_id":
				return ec.fieldContext_RouteStop_agency_id(ctx, field)
			case "route":
				return ec.fieldContext_RouteStop_route(ctx, field)
			case "stop":
				return ec.fieldContext_RouteStop_stop(ctx, field)
			case "agency":
				return ec.fieldContext_RouteStop_agency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteStop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_route_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_child_levels(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_child_levels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().ChildLevels(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Level)
	fc.Result = res
	return ec.marshalNLevel2githubcominterlineiotransitlandlibservermodelLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_child_levels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Level_id(ctx, field)
			case "level_id":
				return ec.fieldContext_Level_level_id(ctx, field)
			case "level_index":
				return ec.fieldContext_Level_level_index(ctx, field)
			case "level_name":
				return ec.fieldContext_Level_level_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Level_geometry(ctx, field)
			case "stops":
				return ec.fieldContext_Level_stops(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Level", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_child_levels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_pathways_from_stop(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_pathways_from_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().PathwaysFromStop(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Pathway)
	fc.Result = res
	return ec.marshalNPathway2githubcominterlineiotransitlandlibservermodelPathway(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_pathways_from_stop(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Pathway_id(ctx, field)
			case "pathway_id":
				return ec.fieldContext_Pathway_pathway_id(ctx, field)
			case "pathway_mode":
				return ec.fieldContext_Pathway_pathway_mode(ctx, field)
			case "is_bidirectional":
				return ec.fieldContext_Pathway_is_bidirectional(ctx, field)
			case "length":
				return ec.fieldContext_Pathway_length(ctx, field)
			case "traversal_time":
				return ec.fieldContext_Pathway_traversal_time(ctx, field)
			case "stair_count":
				return ec.fieldContext_Pathway_stair_count(ctx, field)
			case "max_slope":
				return ec.fieldContext_Pathway_max_slope(ctx, field)
			case "min_width":
				return ec.fieldContext_Pathway_min_width(ctx, field)
			case "signposted_as":
				return ec.fieldContext_Pathway_signposted_as(ctx, field)
			case "reverse_signposted_as":
				return ec.fieldContext_Pathway_reverse_signposted_as(ctx, field)
			case "from_stop":
				return ec.fieldContext_Pathway_from_stop(ctx, field)
			case "to_stop":
				return ec.fieldContext_Pathway_to_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pathway", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_pathways_from_stop_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_pathways_to_stop(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_pathways_to_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().PathwaysToStop(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Pathway)
	fc.Result = res
	return ec.marshalNPathway2githubcominterlineiotransitlandlibservermodelPathway(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_pathways_to_stop(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Pathway_id(ctx, field)
			case "pathway_id":
				return ec.fieldContext_Pathway_pathway_id(ctx, field)
			case "pathway_mode":
				return ec.fieldContext_Pathway_pathway_mode(ctx, field)
			case "is_bidirectional":
				return ec.fieldContext_Pathway_is_bidirectional(ctx, field)
			case "length":
				return ec.fieldContext_Pathway_length(ctx, field)
			case "traversal_time":
				return ec.fieldContext_Pathway_traversal_time(ctx, field)
			case "stair_count":
				return ec.fieldContext_Pathway_stair_count(ctx, field)
			case "max_slope":
				return ec.fieldContext_Pathway_max_slope(ctx, field)
			case "min_width":
				return ec.fieldContext_Pathway_min_width(ctx, field)
			case "signposted_as":
				return ec.fieldContext_Pathway_signposted_as(ctx, field)
			case "reverse_signposted_as":
				return ec.fieldContext_Pathway_reverse_signposted_as(ctx, field)
			case "from_stop":
				return ec.fieldContext_Pathway_from_stop(ctx, field)
			case "to_stop":
				return ec.fieldContext_Pathway_to_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pathway", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_pathways_to_stop_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_times(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_times(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().StopTimes(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopTimeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StopTime)
	fc.Result = res
	return ec.marshalNStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_times(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arrival_time":
				return ec.fieldContext_StopTime_arrival_time(ctx, field)
			case "departure_time":
				return ec.fieldContext_StopTime_departure_time(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_StopTime_stop_sequence(ctx, field)
			case "stop_headsign":
				return ec.fieldContext_StopTime_stop_headsign(ctx, field)
			case "pickup_type":
				return ec.fieldContext_StopTime_pickup_type(ctx, field)
			case "drop_off_type":
				return ec.fieldContext_StopTime_drop_off_type(ctx, field)
			case "timepoint":
				return ec.fieldContext_StopTime_timepoint(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_StopTime_continuous_drop_off(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_StopTime_continuous_pickup(ctx, field)
			case "shape_dist_traveled":
				return ec.fieldContext_StopTime_shape_dist_traveled(ctx, field)
			case "interpolated":
				return ec.fieldContext_StopTime_interpolated(ctx, field)
			case "start_pickup_drop_off_window":
				return ec.fieldContext_StopTime_start_pickup_drop_off_window(ctx, field)
			case "end_pickup_drop_off_window":
				return ec.fieldContext_StopTime_end_pickup_drop_off_window(ctx, field)
			case "pickup_booking_rule":
				return ec.fieldContext_StopTime_pickup_booking_rule(ctx, field)
			case "drop_off_booking_rule":
				return ec.fieldContext_StopTime_drop_off_booking_rule(ctx, field)
			case "stop":
				return ec.fieldContext_StopTime_stop(ctx, field)
			case "trip":
				return ec.fieldContext_StopTime_trip(ctx, field)
			case "arrival":
				return ec.fieldContext_StopTime_arrival(ctx, field)
			case "departure":
				return ec.fieldContext_StopTime_departure(ctx, field)
			case "service_date":
				return ec.fieldContext_StopTime_service_date(ctx, field)
			case "date":
				return ec.fieldContext_StopTime_date(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_StopTime_schedule_relationship(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_stop_times_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_departures(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_departures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Departures(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopTimeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StopTime)
	fc.Result = res
	return ec.marshalNStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_departures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arrival_time":
				return ec.fieldContext_StopTime_arrival_time(ctx, field)
			case "departure_time":
				return ec.fieldContext_StopTime_departure_time(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_StopTime_stop_sequence(ctx, field)
			case "stop_headsign":
				return ec.fieldContext_StopTime_stop_headsign(ctx, field)
			case "pickup_type":
				return ec.fieldContext_StopTime_pickup_type(ctx, field)
			case "drop_off_type":
				return ec.fieldContext_StopTime_drop_off_type(ctx, field)
			case "timepoint":
				return ec.fieldContext_StopTime_timepoint(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_StopTime_continuous_drop_off(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_StopTime_continuous_pickup(ctx, field)
			case "shape_dist_traveled":
				return ec.fieldContext_StopTime_shape_dist_traveled(ctx, field)
			case "interpolated":
				return ec.fieldContext_StopTime_interpolated(ctx, field)
			case "start_pickup_drop_off_window":
				return ec.fieldContext_StopTime_start_pickup_drop_off_window(ctx, field)
			case "end_pickup_drop_off_window":
				return ec.fieldContext_StopTime_end_pickup_drop_off_window(ctx, field)
			case "pickup_booking_rule":
				return ec.fieldContext_StopTime_pickup_booking_rule(ctx, field)
			case "drop_off_booking_rule":
				return ec.fieldContext_StopTime_drop_off_booking_rule(ctx, field)
			case "stop":
				return ec.fieldContext_StopTime_stop(ctx, field)
			case "trip":
				return ec.fieldContext_StopTime_trip(ctx, field)
			case "arrival":
				return ec.fieldContext_StopTime_arrival(ctx, field)
			case "departure":
				return ec.fieldContext_StopTime_departure(ctx, field)
			case "service_date":
				return ec.fieldContext_StopTime_service_date(ctx, field)
			case "date":
				return ec.fieldContext_StopTime_date(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_StopTime_schedule_relationship(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_departures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_arrivals(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_arrivals(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Arrivals(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopTimeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StopTime)
	fc.Result = res
	return ec.marshalNStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_arrivals(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arrival_time":
				return ec.fieldContext_StopTime_arrival_time(ctx, field)
			case "departure_time":
				return ec.fieldContext_StopTime_departure_time(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_StopTime_stop_sequence(ctx, field)
			case "stop_headsign":
				return ec.fieldContext_StopTime_stop_headsign(ctx, field)
			case "pickup_type":
				return ec.fieldContext_StopTime_pickup_type(ctx, field)
			case "drop_off_type":
				return ec.fieldContext_StopTime_drop_off_type(ctx, field)
			case "timepoint":
				return ec.fieldContext_StopTime_timepoint(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_StopTime_continuous_drop_off(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_StopTime_continuous_pickup(ctx, field)
			case "shape_dist_traveled":
				return ec.fieldContext_StopTime_shape_dist_traveled(ctx, field)
			case "interpolated":
				return ec.fieldContext_StopTime_interpolated(ctx, field)
			case "start_pickup_drop_off_window":
				return ec.fieldContext_StopTime_start_pickup_drop_off_window(ctx, field)
			case "end_pickup_drop_off_window":
				return ec.fieldContext_StopTime_end_pickup_drop_off_window(ctx, field)
			case "pickup_booking_rule":
				return ec.fieldContext_StopTime_pickup_booking_rule(ctx, field)
			case "drop_off_booking_rule":
				return ec.fieldContext_StopTime_drop_off_booking_rule(ctx, field)
			case "stop":
				return ec.fieldContext_StopTime_stop(ctx, field)
			case "trip":
				return ec.fieldContext_StopTime_trip(ctx, field)
			case "arrival":
				return ec.fieldContext_StopTime_arrival(ctx, field)
			case "departure":
				return ec.fieldContext_StopTime_departure(ctx, field)
			case "service_date":
				return ec.fieldContext_StopTime_service_date(ctx, field)
			case "date":
				return ec.fieldContext_StopTime_date(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_StopTime_schedule_relationship(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_arrivals_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_search_rank(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_search_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_search_rank(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_place(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_place(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Place(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StopPlace)
	fc.Result = res
	return ec.marshalOStopPlace2githubcominterlineiotransitlandlibservermodelStopPlace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_place(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adm1_name":
				return ec.fieldContext_StopPlace_adm1_name(ctx, field)
			case "adm1_iso":
				return ec.fieldContext_StopPlace_adm1_iso(ctx, field)
			case "adm0_name":
				return ec.fieldContext_StopPlace_adm0_name(ctx, field)
			case "adm0_iso":
				return ec.fieldContext_StopPlace_adm0_iso(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopPlace", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_census_geographies(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_census_geographies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().CensusGeographies(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.CensusGeographyFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusGeography)
	fc.Result = res
	return ec.marshalOCensusGeography2githubcominterlineiotransitlandlibservermodelCensusGeography(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_census_geographies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusGeography_id(ctx, field)
			case "dataset_name":
				return ec.fieldContext_CensusGeography_dataset_name(ctx, field)
			case "source_name":
				return ec.fieldContext_CensusGeography_source_name(ctx, field)
			case "layer_name":
				return ec.fieldContext_CensusGeography_layer_name(ctx, field)
			case "geoid":
				return ec.fieldContext_CensusGeography_geoid(ctx, field)
			case "name":
				return ec.fieldContext_CensusGeography_name(ctx, field)
			case "geometry_area":
				return ec.fieldContext_CensusGeography_geometry_area(ctx, field)
			case "aland":
				return ec.fieldContext_CensusGeography_aland(ctx, field)
			case "awater":
				return ec.fieldContext_CensusGeography_awater(ctx, field)
			case "adm1_name":
				return ec.fieldContext_CensusGeography_adm1_name(ctx, field)
			case "adm1_iso":
				return ec.fieldContext_CensusGeography_adm1_iso(ctx, field)
			case "adm0_name":
				return ec.fieldContext_CensusGeography_adm0_name(ctx, field)
			case "adm0_iso":
				return ec.fieldContext_CensusGeography_adm0_iso(ctx, field)
			case "geometry":
				return ec.fieldContext_CensusGeography_geometry(ctx, field)
			case "intersection_area":
				return ec.fieldContext_CensusGeography_intersection_area(ctx, field)
			case "intersection_geometry":
				return ec.fieldContext_CensusGeography_intersection_geometry(ctx, field)
			case "values":
				return ec.fieldContext_CensusGeography_values(ctx, field)
			case "layer":
				return ec.fieldContext_CensusGeography_layer(ctx, field)
			case "source":
				return ec.fieldContext_CensusGeography_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusGeography", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_census_geographies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_directions(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_directions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Directions(rctx, obj, fc.Args["to"].(*model.WaypointInput), fc.Args["from"].(*model.WaypointInput), fc.Args["mode"].(*model.StepMode), fc.Args["depart_at"].(*time.Time))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Directions)
	fc.Result = res
	return ec.marshalNDirections2githubcominterlineiotransitlandlibservermodelDirections(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_directions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_Directions_success(ctx, field)
			case "exception":
				return ec.fieldContext_Directions_exception(ctx, field)
			case "data_source":
				return ec.fieldContext_Directions_data_source(ctx, field)
			case "origin":
				return ec.fieldContext_Directions_origin(ctx, field)
			case "destination":
				return ec.fieldContext_Directions_destination(ctx, field)
			case "duration":
				return ec.fieldContext_Directions_duration(ctx, field)
			case "distance":
				return ec.fieldContext_Directions_distance(ctx, field)
			case "start_time":
				return ec.fieldContext_Directions_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_Directions_end_time(ctx, field)
			case "itineraries":
				return ec.fieldContext_Directions_itineraries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Directions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_directions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_nearby_stops(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_nearby_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().NearbyStops(rctx, obj, fc.Args["limit"].(*int), fc.Args["radius"].(*float64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalOStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_nearby_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_nearby_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_alerts(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Alerts(rctx, obj, fc.Args["active"].(*bool), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Alert)
	fc.Result = res
	return ec.marshalOAlert2githubcominterlineiotransitlandlibservermodelAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "active_period":
				return ec.fieldContext_Alert_active_period(ctx, field)
			case "cause":
				return ec.fieldContext_Alert_cause(ctx, field)
			case "effect":
				return ec.fieldContext_Alert_effect(ctx, field)
			case "header_text":
				return ec.fieldContext_Alert_header_text(ctx, field)
			case "description_text":
				return ec.fieldContext_Alert_description_text(ctx, field)
			case "tts_header_text":
				return ec.fieldContext_Alert_tts_header_text(ctx, field)
			case "tts_description_text":
				return ec.fieldContext_Alert_tts_description_text(ctx, field)
			case "url":
				return ec.fieldContext_Alert_url(ctx, field)
			case "severity_level":
				return ec.fieldContext_Alert_severity_level(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_alerts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Stop_within_features(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_within_features(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WithinFeatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Strings)
	fc.Result = res
	return ec.marshalOStrings2githubcominterlineiotransitlandlibttStrings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_within_features(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Strings does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopExternalReference_id(ctx context.Context, field graphql.CollectedField, obj *model.StopExternalReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopExternalReference_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopExternalReference_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopExternalReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopExternalReference_target_feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.StopExternalReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopExternalReference_target_feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetFeedOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopExternalReference_target_feed_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopExternalReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopExternalReference_target_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.StopExternalReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopExternalReference_target_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetStopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopExternalReference_target_stop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopExternalReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopExternalReference_inactive(ctx context.Context, field graphql.CollectedField, obj *model.StopExternalReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopExternalReference_inactive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Inactive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBoolean2githubcominterlineiotransitlandlibttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopExternalReference_inactive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopExternalReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopExternalReference_target_active_stop(ctx context.Context, field graphql.CollectedField, obj *model.StopExternalReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopExternalReference_target_active_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopExternalReference().TargetActiveStop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalOStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopExternalReference_target_active_stop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopExternalReference",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_schedule_relationship(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_schedule_relationship(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduleRelationship, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_schedule_relationship(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_trip_start_date(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_trip_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripStartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_trip_start_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_trip_start_time(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_trip_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripStartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_trip_start_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_from_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_from_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromStopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_from_stop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_to_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_to_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToStopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_to_stop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_agency_id(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_agency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_agency_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_route_id(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_route_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_route_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_trip_id(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_trip_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_trip_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_stop_sequence(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_stop_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopSequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_stop_sequence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_source(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_scheduled_arrival_time(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_scheduled_arrival_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledArrivalTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_scheduled_arrival_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_scheduled_departure_time(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_scheduled_departure_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledDepartureTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_scheduled_departure_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_observed_arrival_time(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_observed_arrival_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ObservedArrivalTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_observed_arrival_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_observed_departure_time(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_observed_departure_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ObservedDepartureTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_observed_departure_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopPlace_adm1_name(ctx context.Context, field graphql.CollectedField, obj *model.StopPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopPlace_adm1_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm1Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopPlace_adm1_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopPlace_adm1_iso(ctx context.Context, field graphql.CollectedField, obj *model.StopPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopPlace_adm1_iso(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm1Iso, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopPlace_adm1_iso(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopPlace_adm0_name(ctx context.Context, field graphql.CollectedField, obj *model.StopPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopPlace_adm0_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm0Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopPlace_adm0_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopPlace_adm0_iso(ctx context.Context, field graphql.CollectedField, obj *model.StopPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopPlace_adm0_iso(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm0Iso, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopPlace_adm0_iso(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_arrival_time(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_arrival_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArrivalTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_arrival_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_departure_time(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_departure_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DepartureTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_departure_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_stop_sequence(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_stop_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopSequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_stop_sequence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_stop_headsign(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_stop_headsign(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopHeadsign, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_stop_headsign(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_pickup_type(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_pickup_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PickupType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_pickup_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_drop_off_type(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_drop_off_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DropOffType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_drop_off_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_timepoint(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_timepoint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timepoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_timepoint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_continuous_drop_off(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_continuous_drop_off(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContinuousDropOff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_continuous_drop_off(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_continuous_pickup(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_continuous_pickup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContinuousPickup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_continuous_pickup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_shape_dist_traveled(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_shape_dist_traveled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShapeDistTraveled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_shape_dist_traveled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_interpolated(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_interpolated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interpolated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_interpolated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_start_pickup_drop_off_window(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_start_pickup_drop_off_window(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartPickupDropOffWindow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_start_pickup_drop_off_window(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_end_pickup_drop_off_window(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_end_pickup_drop_off_window(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndPickupDropOffWindow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_end_pickup_drop_off_window(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_pickup_booking_rule(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_pickup_booking_rule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopTime().PickupBookingRule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BookingRule)
	fc.Result = res
	return ec.marshalOBookingRule2githubcominterlineiotransitlandlibservermodelBookingRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_pickup_booking_rule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BookingRule_id(ctx, field)
			case "booking_rule_id":
				return ec.fieldContext_BookingRule_booking_rule_id(ctx, field)
			case "booking_type":
				return ec.fieldContext_BookingRule_booking_type(ctx, field)
			case "prior_notice_duration_min":
				return ec.fieldContext_BookingRule_prior_notice_duration_min(ctx, field)
			case "prior_notice_duration_max":
				return ec.fieldContext_BookingRule_prior_notice_duration_max(ctx, field)
			case "prior_notice_last_day":
				return ec.fieldContext_BookingRule_prior_notice_last_day(ctx, field)
			case "prior_notice_last_time":
				return ec.fieldContext_BookingRule_prior_notice_last_time(ctx, field)
			case "prior_notice_start_day":
				return ec.fieldContext_BookingRule_prior_notice_start_day(ctx, field)
			case "prior_notice_start_time":
				return ec.fieldContext_BookingRule_prior_notice_start_time(ctx, field)
			case "prior_notice_service":
				return ec.fieldContext_BookingRule_prior_notice_service(ctx, field)
			case "message":
				return ec.fieldContext_BookingRule_message(ctx, field)
			case "pickup_message":
				return ec.fieldContext_BookingRule_pickup_message(ctx, field)
			case "drop_off_message":
				return ec.fieldContext_BookingRule_drop_off_message(ctx, field)
			case "phone_number":
				return ec.fieldContext_BookingRule_phone_number(ctx, field)
			case "info_url":
				return ec.fieldContext_BookingRule_info_url(ctx, field)
			case "booking_url":
				return ec.fieldContext_BookingRule_booking_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_BookingRule_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_BookingRule_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_BookingRule_feed_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookingRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_drop_off_booking_rule(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_drop_off_booking_rule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopTime().DropOffBookingRule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BookingRule)
	fc.Result = res
	return ec.marshalOBookingRule2githubcominterlineiotransitlandlibservermodelBookingRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_drop_off_booking_rule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BookingRule_id(ctx, field)
			case "booking_rule_id":
				return ec.fieldContext_BookingRule_booking_rule_id(ctx, field)
			case "booking_type":
				return ec.fieldContext_BookingRule_booking_type(ctx, field)
			case "prior_notice_duration_min":
				return ec.fieldContext_BookingRule_prior_notice_duration_min(ctx, field)
			case "prior_notice_duration_max":
				return ec.fieldContext_BookingRule_prior_notice_duration_max(ctx, field)
			case "prior_notice_last_day":
				return ec.fieldContext_BookingRule_prior_notice_last_day(ctx, field)
			case "prior_notice_last_time":
				return ec.fieldContext_BookingRule_prior_notice_last_time(ctx, field)
			case "prior_notice_start_day":
				return ec.fieldContext_BookingRule_prior_notice_start_day(ctx, field)
			case "prior_notice_start_time":
				return ec.fieldContext_BookingRule_prior_notice_start_time(ctx, field)
			case "prior_notice_service":
				return ec.fieldContext_BookingRule_prior_notice_service(ctx, field)
			case "message":
				return ec.fieldContext_BookingRule_message(ctx, field)
			case "pickup_message":
				return ec.fieldContext_BookingRule_pickup_message(ctx, field)
			case "drop_off_message":
				return ec.fieldContext_BookingRule_drop_off_message(ctx, field)
			case "phone_number":
				return ec.fieldContext_BookingRule_phone_number(ctx, field)
			case "info_url":
				return ec.fieldContext_BookingRule_info_url(ctx, field)
			case "booking_url":
				return ec.fieldContext_BookingRule_booking_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_BookingRule_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_BookingRule_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_BookingRule_feed_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookingRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_stop(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopTime().Stop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_stop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_trip(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_trip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopTime().Trip(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Trip)
	fc.Result = res
	return ec.marshalNTrip2githubcominterlineiotransitlandlibservermodelTrip(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_trip(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trip_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_Trip_trip_id(ctx, field)
			case "trip_headsign":
				return ec.fieldContext_Trip_trip_headsign(ctx, field)
			case "trip_short_name":
				return ec.fieldContext_Trip_trip_short_name(ctx, field)
			case "direction_id":
				return ec.fieldContext_Trip_direction_id(ctx, field)
			case "block_id":
				return ec.fieldContext_Trip_block_id(ctx, field)
			case "wheelchair_accessible":
				return ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
			case "bikes_allowed":
				return ec.fieldContext_Trip_bikes_allowed(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_Trip_stop_pattern_id(ctx, field)
			case "calendar":
				return ec.fieldContext_Trip_calendar(ctx, field)
			case "route":
				return ec.fieldContext_Trip_route(ctx, field)
			case "shape":
				return ec.fieldContext_Trip_shape(ctx, field)
			case "feed_version":
				return ec.fieldContext_Trip_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Trip_stop_times(ctx, field)
			case "flex_stop_times":
				return ec.fieldContext_Trip_flex_stop_times(ctx, field)
			case "frequencies":
				return ec.fieldContext_Trip_frequencies(ctx, field)
			case "alerts":
				return ec.fieldContext_Trip_alerts(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_Trip_schedule_relationship(ctx, field)
			case "timestamp":
				return ec.fieldContext_Trip_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trip", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_arrival(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_arrival(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopTime().Arrival(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.StopTimeEvent)
	fc.Result = res
	return ec.marshalNStopTimeEvent2githubcominterlineiotransitlandlibservermodelStopTimeEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_arrival(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stop_timezone":
				return ec.fieldContext_StopTimeEvent_stop_timezone(ctx, field)
			case "estimated_utc":
				return ec.fieldContext_StopTimeEvent_estimated_utc(ctx, field)
			case "estimated_unix":
				return ec.fieldContext_StopTimeEvent_estimated_unix(ctx, field)
			case "estimated_local":
				return ec.fieldContext_StopTimeEvent_estimated_local(ctx, field)
			case "estimated_delay":
				return ec.fieldContext_StopTimeEvent_estimated_delay(ctx, field)
			case "estimated":
				return ec.fieldContext_StopTimeEvent_estimated(ctx, field)
			case "scheduled_utc":
				return ec.fieldContext_StopTimeEvent_scheduled_utc(ctx, field)
			case "scheduled_unix":
				return ec.fieldContext_StopTimeEvent_scheduled_unix(ctx, field)
			case "scheduled_local":
				return ec.fieldContext_StopTimeEvent_scheduled_local(ctx, field)
			case "scheduled":
				return ec.fieldContext_StopTimeEvent_scheduled(ctx, field)
			case "time_utc":
				return ec.fieldContext_StopTimeEvent_time_utc(ctx, field)
			case "time_unix":
				return ec.fieldContext_StopTimeEvent_time_unix(ctx, field)
			case "delay":
				return ec.fieldContext_StopTimeEvent_delay(ctx, field)
			case "uncertainty":
				return ec.fieldContext_StopTimeEvent_uncertainty(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTimeEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_departure(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_departure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopTime().Departure(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.StopTimeEvent)
	fc.Result = res
	return ec.marshalNStopTimeEvent2githubcominterlineiotransitlandlibservermodelStopTimeEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_departure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stop_timezone":
				return ec.fieldContext_StopTimeEvent_stop_timezone(ctx, field)
			case "estimated_utc":
				return ec.fieldContext_StopTimeEvent_estimated_utc(ctx, field)
			case "estimated_unix":
				return ec.fieldContext_StopTimeEvent_estimated_unix(ctx, field)
			case "estimated_local":
				return ec.fieldContext_StopTimeEvent_estimated_local(ctx, field)
			case "estimated_delay":
				return ec.fieldContext_StopTimeEvent_estimated_delay(ctx, field)
			case "estimated":
				return ec.fieldContext_StopTimeEvent_estimated(ctx, field)
			case "scheduled_utc":
				return ec.fieldContext_StopTimeEvent_scheduled_utc(ctx, field)
			case "scheduled_unix":
				return ec.fieldContext_StopTimeEvent_scheduled_unix(ctx, field)
			case "scheduled_local":
				return ec.fieldContext_StopTimeEvent_scheduled_local(ctx, field)
			case "scheduled":
				return ec.fieldContext_StopTimeEvent_scheduled(ctx, field)
			case "time_utc":
				return ec.fieldContext_StopTimeEvent_time_utc(ctx, field)
			case "time_unix":
				return ec.fieldContext_StopTimeEvent_time_unix(ctx, field)
			case "delay":
				return ec.fieldContext_StopTimeEvent_delay(ctx, field)
			case "uncertainty":
				return ec.fieldContext_StopTimeEvent_uncertainty(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTimeEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_service_date(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_service_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_service_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_date(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_schedule_relationship(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_schedule_relationship(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopTime().ScheduleRelationship(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ScheduleRelationship)
	fc.Result = res
	return ec.marshalOScheduleRelationship2githubcominterlineiotransitlandlibservermodelScheduleRelationship(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_schedule_relationship(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScheduleRelationship does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_stop_timezone(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_stop_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopTimezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_stop_timezone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_estimated_utc(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_estimated_utc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EstimatedUtc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_estimated_utc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_estimated_unix(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_estimated_unix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EstimatedUnix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_estimated_unix(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_estimated_local(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_estimated_local(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EstimatedLocal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_estimated_local(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_estimated_delay(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_estimated_delay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EstimatedDelay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_estimated_delay(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_estimated(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_estimated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Estimated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_estimated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_scheduled_utc(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_scheduled_utc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledUtc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_scheduled_utc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_scheduled_unix(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_scheduled_unix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledUnix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_scheduled_unix(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_scheduled_local(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_scheduled_local(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledLocal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_scheduled_local(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_scheduled(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_scheduled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scheduled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Seconds)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_scheduled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_time_utc(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_time_utc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeUtc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_time_utc(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_time_unix(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_time_unix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeUnix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_time_unix(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_delay(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_delay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Delay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_delay(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_uncertainty(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_uncertainty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uncertainty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_uncertainty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_id(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_trip_id(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_trip_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalNString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_trip_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_trip_headsign(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_trip_headsign(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripHeadsign, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_trip_headsign(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_trip_short_name(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_trip_short_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_trip_short_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_direction_id(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_direction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DirectionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_direction_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_block_id(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_block_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_block_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_wheelchair_accessible(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WheelchairAccessible, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_wheelchair_accessible(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_bikes_allowed(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_bikes_allowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BikesAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_bikes_allowed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_stop_pattern_id(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_stop_pattern_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopPatternID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalNInt2githubcominterlineiotransitlandlibttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_stop_pattern_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_calendar(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_calendar(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().Calendar(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Calendar)
	fc.Result = res
	return ec.marshalNCalendar2githubcominterlineiotransitlandlibservermodelCalendar(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_calendar(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Calendar_id(ctx, field)
			case "service_id":
				return ec.fieldContext_Calendar_service_id(ctx, field)
			case "start_date":
				return ec.fieldContext_Calendar_start_date(ctx, field)
			case "end_date":
				return ec.fieldContext_Calendar_end_date(ctx, field)
			case "monday":
				return ec.fieldContext_Calendar_monday(ctx, field)
			case "tuesday":
				return ec.fieldContext_Calendar_tuesday(ctx, field)
			case "wednesday":
				return ec.fieldContext_Calendar_wednesday(ctx, field)
			case "thursday":
				return ec.fieldContext_Calendar_thursday(ctx, field)
			case "friday":
				return ec.fieldContext_Calendar_friday(ctx, field)
			case "saturday":
				return ec.fieldContext_Calendar_saturday(ctx, field)
			case "sunday":
				return ec.fieldContext_Calendar_sunday(ctx, field)
			case "added_dates":
				return ec.fieldContext_Calendar_added_dates(ctx, field)
			case "removed_dates":
				return ec.fieldContext_Calendar_removed_dates(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Calendar", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_route(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().Route(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandlibservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_route(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			case "segments":
				return ec.fieldContext_Route_segments(ctx, field)
			case "segment_patterns":
				return ec.fieldContext_Route_segment_patterns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_shape(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_shape(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().Shape(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Shape)
	fc.Result = res
	return ec.marshalOShape2githubcominterlineiotransitlandlibservermodelShape(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_shape(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Shape_id(ctx, field)
			case "shape_id":
				return ec.fieldContext_Shape_shape_id(ctx, field)
			case "geometry":
				return ec.fieldContext_Shape_geometry(ctx, field)
			case "generated":
				return ec.fieldContext_Shape_generated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Shape", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_feed_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "service_window":
				return ec.fieldContext_FeedVersion_service_window(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "locations":
				return ec.fieldContext_FeedVersion_locations(ctx, field)
			case "booking_rules":
				return ec.fieldContext_FeedVersion_booking_rules(ctx, field)
			case "location_groups":
				return ec.fieldContext_FeedVersion_location_groups(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			case "validation_reports":
				return ec.fieldContext_FeedVersion_validation_reports(ctx, field)
			case "segments":
				return ec.fieldContext_FeedVersion_segments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_stop_times(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_stop_times(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().StopTimes(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.TripStopTimeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StopTime)
	fc.Result = res
	return ec.marshalNStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_stop_times(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arrival_time":
				return ec.fieldContext_StopTime_arrival_time(ctx, field)
			case "departure_time":
				return ec.fieldContext_StopTime_departure_time(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_StopTime_stop_sequence(ctx, field)
			case "stop_headsign":
				return ec.fieldContext_StopTime_stop_headsign(ctx, field)
			case "pickup_type":
				return ec.fieldContext_StopTime_pickup_type(ctx, field)
			case "drop_off_type":
				return ec.fieldContext_StopTime_drop_off_type(ctx, field)
			case "timepoint":
				return ec.fieldContext_StopTime_timepoint(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_StopTime_continuous_drop_off(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_StopTime_continuous_pickup(ctx, field)
			case "shape_dist_traveled":
				return ec.fieldContext_StopTime_shape_dist_traveled(ctx, field)
			case "interpolated":
				return ec.fieldContext_StopTime_interpolated(ctx, field)
			case "start_pickup_drop_off_window":
				return ec.fieldContext_StopTime_start_pickup_drop_off_window(ctx, field)
			case "end_pickup_drop_off_window":
				return ec.fieldContext_StopTime_end_pickup_drop_off_window(ctx, field)
			case "pickup_booking_rule":
				return ec.fieldContext_StopTime_pickup_booking_rule(ctx, field)
			case "drop_off_booking_rule":
				return ec.fieldContext_StopTime_drop_off_booking_rule(ctx, field)
			case "stop":
				return ec.fieldContext_StopTime_stop(ctx, field)
			case "trip":
				return ec.fieldContext_StopTime_trip(ctx, field)
			case "arrival":
				return ec.fieldContext_StopTime_arrival(ctx, field)
			case "departure":
				return ec.fieldContext_StopTime_departure(ctx, field)
			case "service_date":
				return ec.fieldContext_StopTime_service_date(ctx, field)
			case "date":
				return ec.fieldContext_StopTime_date(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_StopTime_schedule_relationship(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Trip_stop_times_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Trip_flex_stop_times(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_flex_stop_times(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().FlexStopTimes(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.TripStopTimeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StopTime)
	fc.Result = res
	return ec.marshalNFlexStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_flex_stop_times(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arrival_time":
				return ec.fieldContext_FlexStopTime_arrival_time(ctx, field)
			case "departure_time":
				return ec.fieldContext_FlexStopTime_departure_time(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_FlexStopTime_stop_sequence(ctx, field)
			case "stop_headsign":
				return ec.fieldContext_FlexStopTime_stop_headsign(ctx, field)
			case "pickup_type":
				return ec.fieldContext_FlexStopTime_pickup_type(ctx, field)
			case "drop_off_type":
				return ec.fieldContext_FlexStopTime_drop_off_type(ctx, field)
			case "timepoint":
				return ec.fieldContext_FlexStopTime_timepoint(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_FlexStopTime_continuous_drop_off(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_FlexStopTime_continuous_pickup(ctx, field)
			case "shape_dist_traveled":
				return ec.fieldContext_FlexStopTime_shape_dist_traveled(ctx, field)
			case "interpolated":
				return ec.fieldContext_FlexStopTime_interpolated(ctx, field)
			case "start_pickup_drop_off_window":
				return ec.fieldContext_FlexStopTime_start_pickup_drop_off_window(ctx, field)
			case "end_pickup_drop_off_window":
				return ec.fieldContext_FlexStopTime_end_pickup_drop_off_window(ctx, field)
			case "pickup_booking_rule":
				return ec.fieldContext_FlexStopTime_pickup_booking_rule(ctx, field)
			case "drop_off_booking_rule":
				return ec.fieldContext_FlexStopTime_drop_off_booking_rule(ctx, field)
			case "location":
				return ec.fieldContext_FlexStopTime_location(ctx, field)
			case "location_group":
				return ec.fieldContext_FlexStopTime_location_group(ctx, field)
			case "trip":
				return ec.fieldContext_FlexStopTime_trip(ctx, field)
			case "arrival":
				return ec.fieldContext_FlexStopTime_arrival(ctx, field)
			case "departure":
				return ec.fieldContext_FlexStopTime_departure(ctx, field)
			case "service_date":
				return ec.fieldContext_FlexStopTime_service_date(ctx, field)
			case "date":
				return ec.fieldContext_FlexStopTime_date(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_FlexStopTime_schedule_relationship(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FlexStopTime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Trip_flex_stop_times_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Trip_frequencies(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_frequencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().Frequencies(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Frequency)
	fc.Result = res
	return ec.marshalNFrequency2githubcominterlineiotransitlandlibservermodelFrequency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_frequencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Frequency_id(ctx, field)
			case "start_time":
				return ec.fieldContext_Frequency_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_Frequency_end_time(ctx, field)
			case "headway_secs":
				return ec.fieldContext_Frequency_headway_secs(ctx, field)
			case "exact_times":
				return ec.fieldContext_Frequency_exact_times(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Frequency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Trip_frequencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Trip_alerts(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().Alerts(rctx, obj, fc.Args["active"].(*bool), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Alert)
	fc.Result = res
	return ec.marshalOAlert2githubcominterlineiotransitlandlibservermodelAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "active_period":
				return ec.fieldContext_Alert_active_period(ctx, field)
			case "cause":
				return ec.fieldContext_Alert_cause(ctx, field)
			case "effect":
				return ec.fieldContext_Alert_effect(ctx, field)
			case "header_text":
				return ec.fieldContext_Alert_header_text(ctx, field)
			case "description_text":
				return ec.fieldContext_Alert_description_text(ctx, field)
			case "tts_header_text":
				return ec.fieldContext_Alert_tts_header_text(ctx, field)
			case "tts_description_text":
				return ec.fieldContext_Alert_tts_description_text(ctx, field)
			case "url":
				return ec.fieldContext_Alert_url(ctx, field)
			case "severity_level":
				return ec.fieldContext_Alert_severity_level(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Trip_alerts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Trip_schedule_relationship(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_schedule_relationship(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().ScheduleRelationship(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ScheduleRelationship)
	fc.Result = res
	return ec.marshalOScheduleRelationship2githubcominterlineiotransitlandlibservermodelScheduleRelationship(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_schedule_relationship(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScheduleRelationship does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().Timestamp(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationRealtimeResult_url(ctx context.Context, field graphql.CollectedField, obj *model.ValidationRealtimeResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationRealtimeResult_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationRealtimeResult_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationRealtimeResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationRealtimeResult_json(ctx context.Context, field graphql.CollectedField, obj *model.ValidationRealtimeResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationRealtimeResult_json(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JSON, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Map)
	fc.Result = res
	return ec.marshalNMap2githubcominterlineiotransitlandlibttMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationRealtimeResult_json(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationRealtimeResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_id(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_reported_at(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_reported_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReportedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_reported_at(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_reported_at_local(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_reported_at_local(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReportedAtLocal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_reported_at_local(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_reported_at_local_timezone(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_reported_at_local_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReportedAtLocalTimezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_reported_at_local_timezone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_success(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_failure_reason(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_failure_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailureReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_failure_reason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_includes_static(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_includes_static(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncludesStatic, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_includes_static(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_includes_rt(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_includes_rt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncludesRt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_includes_rt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_validator(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_validator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_validator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_validator_version(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_validator_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidatorVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_validator_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_errors(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ValidationReport().Errors(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ValidationReportErrorGroup)
	fc.Result = res
	return ec.marshalNValidationReportErrorGroup2githubcominterlineiotransitlandlibservermodelValidationReportErrorGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filename":
				return ec.fieldContext_ValidationReportErrorGroup_filename(ctx, field)
			case "error_type":
				return ec.fieldContext_ValidationReportErrorGroup_error_type(ctx, field)
			case "error_code":
				return ec.fieldContext_ValidationReportErrorGroup_error_code(ctx, field)
			case "group_key":
				return ec.fieldContext_ValidationReportErrorGroup_group_key(ctx, field)
			case "field":
				return ec.fieldContext_ValidationReportErrorGroup_field(ctx, field)
			case "count":
				return ec.fieldContext_ValidationReportErrorGroup_count(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationReportErrorGroup_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationReportErrorGroup", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationReport_errors_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_warnings(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_warnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ValidationReport().Warnings(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ValidationReportErrorGroup)
	fc.Result = res
	return ec.marshalNValidationReportErrorGroup2githubcominterlineiotransitlandlibservermodelValidationReportErrorGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_warnings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filename":
				return ec.fieldContext_ValidationReportErrorGroup_filename(ctx, field)
			case "error_type":
				return ec.fieldContext_ValidationReportErrorGroup_error_type(ctx, field)
			case "error_code":
				return ec.fieldContext_ValidationReportErrorGroup_error_code(ctx, field)
			case "group_key":
				return ec.fieldContext_ValidationReportErrorGroup_group_key(ctx, field)
			case "field":
				return ec.fieldContext_ValidationReportErrorGroup_field(ctx, field)
			case "count":
				return ec.fieldContext_ValidationReportErrorGroup_count(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationReportErrorGroup_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationReportErrorGroup", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationReport_warnings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReport_details(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReport_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ValidationReport().Details(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ValidationReportDetails)
	fc.Result = res
	return ec.marshalOValidationReportDetails2githubcominterlineiotransitlandlibservermodelValidationReportDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReport_details(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sha1":
				return ec.fieldContext_ValidationReportDetails_sha1(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_ValidationReportDetails_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_ValidationReportDetails_latest_calendar_date(ctx, field)
			case "files":
				return ec.fieldContext_ValidationReportDetails_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_ValidationReportDetails_service_levels(ctx, field)
			case "agencies":
				return ec.fieldContext_ValidationReportDetails_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_ValidationReportDetails_routes(ctx, field)
			case "stops":
				return ec.fieldContext_ValidationReportDetails_stops(ctx, field)
			case "feed_infos":
				return ec.fieldContext_ValidationReportDetails_feed_infos(ctx, field)
			case "realtime":
				return ec.fieldContext_ValidationReportDetails_realtime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationReportDetails", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportDetails_sha1(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportDetails_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sha1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportDetails_sha1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportDetails_earliest_calendar_date(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportDetails_earliest_calendar_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EarliestCalendarDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportDetails_earliest_calendar_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportDetails_latest_calendar_date(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportDetails_latest_calendar_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestCalendarDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportDetails_latest_calendar_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportDetails_files(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportDetails_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Files, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedVersionFileInfo)
	fc.Result = res
	return ec.marshalNFeedVersionFileInfo2githubcominterlineiotransitlandlibservermodelFeedVersionFileInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportDetails_files(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersionFileInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersionFileInfo_name(ctx, field)
			case "rows":
				return ec.fieldContext_FeedVersionFileInfo_rows(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersionFileInfo_sha1(ctx, field)
			case "header":
				return ec.fieldContext_FeedVersionFileInfo_header(ctx, field)
			case "csv_like":
				return ec.fieldContext_FeedVersionFileInfo_csv_like(ctx, field)
			case "size":
				return ec.fieldContext_FeedVersionFileInfo_size(ctx, field)
			case "values_count":
				return ec.fieldContext_FeedVersionFileInfo_values_count(ctx, field)
			case "values_unique":
				return ec.fieldContext_FeedVersionFileInfo_values_unique(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionFileInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportDetails_service_levels(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportDetails_service_levels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceLevels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedVersionServiceLevel)
	fc.Result = res
	return ec.marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandlibservermodelFeedVersionServiceLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportDetails_service_levels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersionServiceLevel_id(ctx, field)
			case "start_date":
				return ec.fieldContext_FeedVersionServiceLevel_start_date(ctx, field)
			case "end_date":
				return ec.fieldContext_FeedVersionServiceLevel_end_date(ctx, field)
			case "monday":
				return ec.fieldContext_FeedVersionServiceLevel_monday(ctx, field)
			case "tuesday":
				return ec.fieldContext_FeedVersionServiceLevel_tuesday(ctx, field)
			case "wednesday":
				return ec.fieldContext_FeedVersionServiceLevel_wednesday(ctx, field)
			case "thursday":
				return ec.fieldContext_FeedVersionServiceLevel_thursday(ctx, field)
			case "friday":
				return ec.fieldContext_FeedVersionServiceLevel_friday(ctx, field)
			case "saturday":
				return ec.fieldContext_FeedVersionServiceLevel_saturday(ctx, field)
			case "sunday":
				return ec.fieldContext_FeedVersionServiceLevel_sunday(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionServiceLevel", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationReportDetails_service_levels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportDetails_agencies(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportDetails_agencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Agencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Agency)
	fc.Result = res
	return ec.marshalNAgency2githubcominterlineiotransitlandlibservermodelAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportDetails_agencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Agency_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Agency_onestop_id(ctx, field)
			case "agency_email":
				return ec.fieldContext_Agency_agency_email(ctx, field)
			case "agency_fare_url":
				return ec.fieldContext_Agency_agency_fare_url(ctx, field)
			case "agency_id":
				return ec.fieldContext_Agency_agency_id(ctx, field)
			case "agency_lang":
				return ec.fieldContext_Agency_agency_lang(ctx, field)
			case "agency_name":
				return ec.fieldContext_Agency_agency_name(ctx, field)
			case "agency_phone":
				return ec.fieldContext_Agency_agency_phone(ctx, field)
			case "agency_timezone":
				return ec.fieldContext_Agency_agency_timezone(ctx, field)
			case "agency_url":
				return ec.fieldContext_Agency_agency_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Agency_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Agency_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Agency_feed_version(ctx, field)
			case "geometry":
				return ec.fieldContext_Agency_geometry(ctx, field)
			case "search_rank":
				return ec.fieldContext_Agency_search_rank(ctx, field)
			case "operator":
				return ec.fieldContext_Agency_operator(ctx, field)
			case "places":
				return ec.fieldContext_Agency_places(ctx, field)
			case "routes":
				return ec.fieldContext_Agency_routes(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Agency_census_geographies(ctx, field)
			case "alerts":
				return ec.fieldContext_Agency_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Agency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationReportDetails_agencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportDetails_routes(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportDetails_routes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Routes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandlibservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportDetails_routes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			case "segments":
				return ec.fieldContext_Route_segments(ctx, field)
			case "segment_patterns":
				return ec.fieldContext_Route_segment_patterns(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationReportDetails_routes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportDetails_stops(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportDetails_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stops, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportDetails_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationReportDetails_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportDetails_feed_infos(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportDetails_feed_infos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedInfos, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedInfo)
	fc.Result = res
	return ec.marshalNFeedInfo2githubcominterlineiotransitlandlibservermodelFeedInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportDetails_feed_infos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedInfo_id(ctx, field)
			case "feed_publisher_name":
				return ec.fieldContext_FeedInfo_feed_publisher_name(ctx, field)
			case "feed_publisher_url":
				return ec.fieldContext_FeedInfo_feed_publisher_url(ctx, field)
			case "feed_lang":
				return ec.fieldContext_FeedInfo_feed_lang(ctx, field)
			case "default_lang":
				return ec.fieldContext_FeedInfo_default_lang(ctx, field)
			case "feed_version":
				return ec.fieldContext_FeedInfo_feed_version(ctx, field)
			case "feed_start_date":
				return ec.fieldContext_FeedInfo_feed_start_date(ctx, field)
			case "feed_end_date":
				return ec.fieldContext_FeedInfo_feed_end_date(ctx, field)
			case "feed_contact_email":
				return ec.fieldContext_FeedInfo_feed_contact_email(ctx, field)
			case "feed_contact_url":
				return ec.fieldContext_FeedInfo_feed_contact_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationReportDetails_feed_infos_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportDetails_realtime(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportDetails_realtime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Realtime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ValidationRealtimeResult)
	fc.Result = res
	return ec.marshalOValidationRealtimeResult2githubcominterlineiotransitlandlibservermodelValidationRealtimeResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportDetails_realtime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_ValidationRealtimeResult_url(ctx, field)
			case "json":
				return ec.fieldContext_ValidationRealtimeResult_json(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationRealtimeResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportError_filename(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportError_filename(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Filename, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportError_filename(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportError_error_type(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportError_error_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportError_error_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportError_error_code(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportError_error_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportError_error_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportError_group_key(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportError_group_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportError_group_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportError_entity_id(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportError_entity_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportError_entity_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportError_field(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportError_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportError_field(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportError_line(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportError_line(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Line, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportError_line(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportError_value(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportError_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportError_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportError_message(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportError_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportError_geometry(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportError_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportError_geometry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportError_entity_json(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportError_entity_json(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntityJSON, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Map)
	fc.Result = res
	return ec.marshalNMap2githubcominterlineiotransitlandlibttMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportError_entity_json(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportErrorGroup_filename(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportErrorGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportErrorGroup_filename(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Filename, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportErrorGroup_filename(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportErrorGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportErrorGroup_error_type(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportErrorGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportErrorGroup_error_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportErrorGroup_error_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportErrorGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportErrorGroup_error_code(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportErrorGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportErrorGroup_error_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportErrorGroup_error_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportErrorGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportErrorGroup_group_key(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportErrorGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportErrorGroup_group_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportErrorGroup_group_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportErrorGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportErrorGroup_field(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportErrorGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportErrorGroup_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportErrorGroup_field(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportErrorGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportErrorGroup_count(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportErrorGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportErrorGroup_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportErrorGroup_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportErrorGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationReportErrorGroup_errors(ctx context.Context, field graphql.CollectedField, obj *model.ValidationReportErrorGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationReportErrorGroup_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ValidationReportErrorGroup().Errors(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ValidationReportError)
	fc.Result = res
	return ec.marshalNValidationReportError2githubcominterlineiotransitlandlibservermodelValidationReportError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationReportErrorGroup_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationReportErrorGroup",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filename":
				return ec.fieldContext_ValidationReportError_filename(ctx, field)
			case "error_type":
				return ec.fieldContext_ValidationReportError_error_type(ctx, field)
			case "error_code":
				return ec.fieldContext_ValidationReportError_error_code(ctx, field)
			case "group_key":
				return ec.fieldContext_ValidationReportError_group_key(ctx, field)
			case "entity_id":
				return ec.fieldContext_ValidationReportError_entity_id(ctx, field)
			case "field":
				return ec.fieldContext_ValidationReportError_field(ctx, field)
			case "line":
				return ec.fieldContext_ValidationReportError_line(ctx, field)
			case "value":
				return ec.fieldContext_ValidationReportError_value(ctx, field)
			case "message":
				return ec.fieldContext_ValidationReportError_message(ctx, field)
			case "geometry":
				return ec.fieldContext_ValidationReportError_geometry(ctx, field)
			case "entity_json":
				return ec.fieldContext_ValidationReportError_entity_json(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationReportError", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationReportErrorGroup_errors_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_vehicle(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_vehicle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vehicle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RTVehicleDescriptor)
	fc.Result = res
	return ec.marshalORTVehicleDescriptor2githubcominterlineiotransitlandlibservermodelRTVehicleDescriptor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_vehicle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RTVehicleDescriptor_id(ctx, field)
			case "label":
				return ec.fieldContext_RTVehicleDescriptor_label(ctx, field)
			case "license_plate":
				return ec.fieldContext_RTVehicleDescriptor_license_plate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTVehicleDescriptor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_position(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Point)
	fc.Result = res
	return ec.marshalOPoint2githubcominterlineiotransitlandlibttPoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Point does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_current_stop_sequence(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_current_stop_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentStopSequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_current_stop_sequence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalOStop2githubcominterlineiotransitlandlibservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_stop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "location_groups":
				return ec.fieldContext_Stop_location_groups(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "child_levels":
				return ec.fieldContext_Stop_child_levels(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "place":
				return ec.fieldContext_Stop_place(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			case "within_features":
				return ec.fieldContext_Stop_within_features(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_current_status(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_current_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_current_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_congestion_level(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_congestion_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CongestionLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_congestion_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waypoint_lon(ctx context.Context, field graphql.CollectedField, obj *model.Waypoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Waypoint_lon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Waypoint_lon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waypoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waypoint_lat(ctx context.Context, field graphql.CollectedField, obj *model.Waypoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Waypoint_lat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Waypoint_lat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waypoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waypoint_name(ctx context.Context, field graphql.CollectedField, obj *model.Waypoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Waypoint_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Waypoint_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waypoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waypoint_stop(ctx context.Context, field graphql.CollectedField, obj *model.Waypoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Waypoint_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stop, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.WaypointStop)
	fc.Result = res
	return ec.marshalOWaypointStop2githubcominterlineiotransitlandlibservermodelWaypointStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Waypoint_stop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waypoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_WaypointStop_lon(ctx, field)
			case "lat":
				return ec.fieldContext_WaypointStop_lat(ctx, field)
			case "departure":
				return ec.fieldContext_WaypointStop_departure(ctx, field)
			case "stop_id":
				return ec.fieldContext_WaypointStop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_WaypointStop_stop_name(ctx, field)
			case "stop_code":
				return ec.fieldContext_WaypointStop_stop_code(ctx, field)
			case "stop_onestop_id":
				return ec.fieldContext_WaypointStop_stop_onestop_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaypointStop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointDeparture_lon(ctx context.Context, field graphql.CollectedField, obj *model.WaypointDeparture) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointDeparture_lon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointDeparture_lon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointDeparture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointDeparture_lat(ctx context.Context, field graphql.CollectedField, obj *model.WaypointDeparture) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointDeparture_lat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointDeparture_lat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointDeparture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointDeparture_departure(ctx context.Context, field graphql.CollectedField, obj *model.WaypointDeparture) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointDeparture_departure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Departure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointDeparture_departure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointDeparture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointDeparture_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.WaypointDeparture) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointDeparture_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointDeparture_stop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointDeparture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointDeparture_stop_name(ctx context.Context, field graphql.CollectedField, obj *model.WaypointDeparture) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointDeparture_stop_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointDeparture_stop_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointDeparture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointDeparture_stop_code(ctx context.Context, field graphql.CollectedField, obj *model.WaypointDeparture) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointDeparture_stop_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointDeparture_stop_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointDeparture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointDeparture_stop_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.WaypointDeparture) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointDeparture_stop_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointDeparture_stop_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointDeparture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointDeparture_stop_index(ctx context.Context, field graphql.CollectedField, obj *model.WaypointDeparture) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointDeparture_stop_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopIndex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointDeparture_stop_index(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointDeparture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointDeparture_stop_sequence(ctx context.Context, field graphql.CollectedField, obj *model.WaypointDeparture) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointDeparture_stop_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopSequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointDeparture_stop_sequence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointDeparture",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointStop_lon(ctx context.Context, field graphql.CollectedField, obj *model.WaypointStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointStop_lon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointStop_lon(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointStop_lat(ctx context.Context, field graphql.CollectedField, obj *model.WaypointStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointStop_lat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointStop_lat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointStop_departure(ctx context.Context, field graphql.CollectedField, obj *model.WaypointStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointStop_departure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Departure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointStop_departure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointStop_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.WaypointStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointStop_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointStop_stop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointStop_stop_name(ctx context.Context, field graphql.CollectedField, obj *model.WaypointStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointStop_stop_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointStop_stop_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointStop_stop_code(ctx context.Context, field graphql.CollectedField, obj *model.WaypointStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointStop_stop_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointStop_stop_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaypointStop_stop_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.WaypointStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaypointStop_stop_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaypointStop_stop_onestop_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaypointStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAgencyFilter(ctx context.Context, obj any) (model.AgencyFilter, error) {
	var it model.AgencyFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"onestop_id", "feed_version_sha1", "feed_onestop_id", "agency_id", "agency_name", "search", "city_name", "adm0_name", "adm1_name", "adm0_iso", "adm1_iso", "license", "location", "bbox", "within", "near"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnestopID = data
		case "feed_version_sha1":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version_sha1"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedVersionSha1 = data
		case "feed_onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedOnestopID = data
		case "agency_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agency_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgencyID = data
		case "agency_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agency_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgencyName = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "city_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("city_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityName = data
		case "adm0_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm0_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Adm0Name = data
		case "adm1_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm1_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Adm1Name = data
		case "adm0_iso":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm0_iso"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Adm0Iso = data
		case "adm1_iso":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm1_iso"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Adm1Iso = data
		case "license":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			data, err := ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandlibservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.License = data
		case "location":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			data, err := ec.unmarshalOAgencyLocationFilter2githubcominterlineiotransitlandlibservermodelAgencyLocationFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Location = data
		case "bbox":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bbox"))
			data, err := ec.unmarshalOBoundingBox2githubcominterlineiotransitlandlibservermodelBoundingBox(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bbox = data
		case "within":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("within"))
			data, err := ec.unmarshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
			it.Within = data
		case "near":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			data, err := ec.unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
			it.Near = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAgencyLocationFilter(ctx context.Context, obj any) (model.AgencyLocationFilter, error) {
	var it model.AgencyLocationFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"bbox", "polygon", "near", "focus"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "bbox":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bbox"))
			data, err := ec.unmarshalOBoundingBox2githubcominterlineiotransitlandlibservermodelBoundingBox(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bbox = data
		case "polygon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("polygon"))
			data, err := ec.unmarshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
			it.Polygon = data
		case "near":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			data, err := ec.unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
			it.Near = data
		case "focus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("focus"))
			data, err := ec.unmarshalOFocusPoint2githubcominterlineiotransitlandlibservermodelFocusPoint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Focus = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAgencyPlaceFilter(ctx context.Context, obj any) (model.AgencyPlaceFilter, error) {
	var it model.AgencyPlaceFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"min_rank"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "min_rank":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min_rank"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinRank = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBookingRuleFilter(ctx context.Context, obj any) (model.BookingRuleFilter, error) {
	var it model.BookingRuleFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ids", "booking_rule_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ids = data
		case "booking_rule_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("booking_rule_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BookingRuleID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBoundingBox(ctx context.Context, obj any) (model.BoundingBox, error) {
	var it model.BoundingBox
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"min_lon", "min_lat", "max_lon", "max_lat"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "min_lon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min_lon"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinLon = data
		case "min_lat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min_lat"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinLat = data
		case "max_lon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_lon"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLon = data
		case "max_lat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_lat"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxLat = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCalendarDateFilter(ctx context.Context, obj any) (model.CalendarDateFilter, error) {
	var it model.CalendarDateFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"date", "exception_type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		case "exception_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exception_type"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExceptionType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCensusDatasetFilter(ctx context.Context, obj any) (model.CensusDatasetFilter, error) {
	var it model.CensusDatasetFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "search"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCensusDatasetGeographyFilter(ctx context.Context, obj any) (model.CensusDatasetGeographyFilter, error) {
	var it model.CensusDatasetGeographyFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ids", "dataset", "layer", "search", "location"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ids = data
		case "dataset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dataset"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dataset = data
		case "layer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layer = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "location":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			data, err := ec.unmarshalOCensusDatasetGeographyLocationFilter2githubcominterlineiotransitlandlibservermodelCensusDatasetGeographyLocationFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Location = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCensusDatasetGeographyLocationFilter(ctx context.Context, obj any) (model.CensusDatasetGeographyLocationFilter, error) {
	var it model.CensusDatasetGeographyLocationFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"bbox", "within", "near", "focus", "stop_buffer"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "bbox":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bbox"))
			data, err := ec.unmarshalOBoundingBox2githubcominterlineiotransitlandlibservermodelBoundingBox(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bbox = data
		case "within":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("within"))
			data, err := ec.unmarshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
			it.Within = data
		case "near":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			data, err := ec.unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
			it.Near = data
		case "focus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("focus"))
			data, err := ec.unmarshalOFocusPoint2githubcominterlineiotransitlandlibservermodelFocusPoint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Focus = data
		case "stop_buffer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_buffer"))
			data, err := ec.unmarshalOStopBuffer2githubcominterlineiotransitlandlibservermodelStopBuffer(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopBuffer = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCensusGeographyFilter(ctx context.Context, obj any) (model.CensusGeographyFilter, error) {
	var it model.CensusGeographyFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"dataset", "layer", "radius", "search"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "dataset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dataset"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dataset = data
		case "layer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layer = data
		case "radius":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("radius"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Radius = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCensusSourceFilter(ctx context.Context, obj any) (model.CensusSourceFilter, error) {
	var it model.CensusSourceFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "search"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCensusSourceGeographyFilter(ctx context.Context, obj any) (model.CensusSourceGeographyFilter, error) {
	var it model.CensusSourceGeographyFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ids", "search", "location"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ids = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "location":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			data, err := ec.unmarshalOCensusDatasetGeographyLocationFilter2githubcominterlineiotransitlandlibservermodelCensusDatasetGeographyLocationFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Location = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCensusTableFilter(ctx context.Context, obj any) (model.CensusTableFilter, error) {
	var it model.CensusTableFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"search"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCensusValueFilter(ctx context.Context, obj any) (model.CensusValueFilter, error) {
	var it model.CensusValueFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"dataset", "table", "geoid", "geoid_prefix"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "dataset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dataset"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dataset = data
		case "table":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("table"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Table = data
		case "geoid":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("geoid"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Geoid = data
		case "geoid_prefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("geoid_prefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.GeoidPrefix = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDirectionRequest(ctx context.Context, obj any) (model.DirectionRequest, error) {
	var it model.DirectionRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"to", "from", "mode", "depart_at"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "to":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
			data, err := ec.unmarshalNWaypointInput2githubcominterlineiotransitlandlibservermodelWaypointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.To = data
		case "from":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
			data, err := ec.unmarshalNWaypointInput2githubcominterlineiotransitlandlibservermodelWaypointInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.From = data
		case "mode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			data, err := ec.unmarshalNStepMode2githubcominterlineiotransitlandlibservermodelStepMode(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mode = data
		case "depart_at":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("depart_at"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.DepartAt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeature(ctx context.Context, obj any) (model.Feature, error) {
	var it model.Feature
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "geometry", "properties", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "geometry":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("geometry"))
			data, err := ec.unmarshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx, v)
			if err != nil {
				return it, err
			}
			it.Geometry = data
		case "properties":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("properties"))
			data, err := ec.unmarshalOMap2githubcominterlineiotransitlandlibttMap(ctx, v)
			if err != nil {
				return it, err
			}
			it.Properties = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedFetchFilter(ctx context.Context, obj any) (model.FeedFetchFilter, error) {
	var it model.FeedFetchFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"success"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "success":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("success"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Success = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedFilter(ctx context.Context, obj any) (model.FeedFilter, error) {
	var it model.FeedFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"onestop_id", "spec", "fetch_error", "import_status", "search", "tags", "source_url", "license", "bbox", "within", "near"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnestopID = data
		case "spec":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spec"))
			data, err := ec.unmarshalOFeedSpecTypes2githubcominterlineiotransitlandlibservermodelFeedSpecTypes(ctx, v)
			if err != nil {
				return it, err
			}
			it.Spec = data
		case "fetch_error":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fetch_error"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.FetchError = data
		case "import_status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("import_status"))
			data, err := ec.unmarshalOImportStatus2githubcominterlineiotransitlandlibservermodelImportStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImportStatus = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOTags2githubcominterlineiotransitlandlibttTags(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "source_url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source_url"))
			data, err := ec.unmarshalOFeedSourceUrl2githubcominterlineiotransitlandlibservermodelFeedSourceURL(ctx, v)
			if err != nil {
				return it, err
			}
			it.SourceURL = data
		case "license":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			data, err := ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandlibservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.License = data
		case "bbox":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bbox"))
			data, err := ec.unmarshalOBoundingBox2githubcominterlineiotransitlandlibservermodelBoundingBox(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bbox = data
		case "within":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("within"))
			data, err := ec.unmarshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
			it.Within = data
		case "near":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			data, err := ec.unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
			it.Near = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedSourceUrl(ctx context.Context, obj any) (model.FeedSourceURL, error) {
	var it model.FeedSourceURL
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "type", "case_sensitive"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOFeedSourceUrlTypes2githubcominterlineiotransitlandlibservermodelFeedSourceURLTypes(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "case_sensitive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("case_sensitive"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CaseSensitive = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedVersionFilter(ctx context.Context, obj any) (model.FeedVersionFilter, error) {
	var it model.FeedVersionFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ids", "import_status", "feed_onestop_id", "sha1", "file", "feed_ids", "covers", "bbox", "within", "near", "license"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ids = data
		case "import_status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("import_status"))
			data, err := ec.unmarshalOImportStatus2githubcominterlineiotransitlandlibservermodelImportStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImportStatus = data
		case "feed_onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedOnestopID = data
		case "sha1":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sha1"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sha1 = data
		case "file":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.File = data
		case "feed_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedIds = data
		case "covers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("covers"))
			data, err := ec.unmarshalOServiceCoversFilter2githubcominterlineiotransitlandlibservermodelServiceCoversFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Covers = data
		case "bbox":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bbox"))
			data, err := ec.unmarshalOBoundingBox2githubcominterlineiotransitlandlibservermodelBoundingBox(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bbox = data
		case "within":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("within"))
			data, err := ec.unmarshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
			it.Within = data
		case "near":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			data, err := ec.unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
			it.Near = data
		case "license":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			data, err := ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandlibservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.License = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedVersionInput(ctx context.Context, obj any) (model.FeedVersionInput, error) {
	var it model.FeedVersionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedVersionServiceLevelFilter(ctx context.Context, obj any) (model.FeedVersionServiceLevelFilter, error) {
	var it model.FeedVersionServiceLevelFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"start_date", "end_date"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "start_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start_date"))
			data, err := ec.unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartDate = data
		case "end_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end_date"))
			data, err := ec.unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndDate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedVersionSetInput(ctx context.Context, obj any) (model.FeedVersionSetInput, error) {
	var it model.FeedVersionSetInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFocusPoint(ctx context.Context, obj any) (model.FocusPoint, error) {
	var it model.FocusPoint
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lat", "lon"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lat"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lat = data
		case "lon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lon"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lon = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGbfsBikeRequest(ctx context.Context, obj any) (model.GbfsBikeRequest, error) {
	var it model.GbfsBikeRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"near"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "near":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			data, err := ec.unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
			it.Near = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGbfsDockRequest(ctx context.Context, obj any) (model.GbfsDockRequest, error) {
	var it model.GbfsDockRequest
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"near"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "near":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			data, err := ec.unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
			it.Near = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLevelSetInput(ctx context.Context, obj any) (model.LevelSetInput, error) {
	var it model.LevelSetInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "feed_version", "level_id", "level_name", "level_index", "geometry", "parent"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "feed_version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version"))
			data, err := ec.unmarshalOFeedVersionInput2githubcominterlineiotransitlandlibservermodelFeedVersionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedVersion = data
		case "level_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelID = data
		case "level_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelName = data
		case "level_index":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level_index"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.LevelIndex = data
		case "geometry":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("geometry"))
			data, err := ec.unmarshalOMultiPolygon2githubcominterlineiotransitlandlibttMultiPolygon(ctx, v)
			if err != nil {
				return it, err
			}
			it.Geometry = data
		case "parent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parent"))
			data, err := ec.unmarshalOStopSetInput2githubcominterlineiotransitlandlibservermodelStopSetInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parent = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLicenseFilter(ctx context.Context, obj any) (model.LicenseFilter, error) {
	var it model.LicenseFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"share_alike_optional", "create_derived_product", "commercial_use_allowed", "use_without_attribution", "redistribution_allowed"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "share_alike_optional":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("share_alike_optional"))
			data, err := ec.unmarshalOLicenseValue2githubcominterlineiotransitlandlibservermodelLicenseValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShareAlikeOptional = data
		case "create_derived_product":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("create_derived_product"))
			data, err := ec.unmarshalOLicenseValue2githubcominterlineiotransitlandlibservermodelLicenseValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateDerivedProduct = data
		case "commercial_use_allowed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commercial_use_allowed"))
			data, err := ec.unmarshalOLicenseValue2githubcominterlineiotransitlandlibservermodelLicenseValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommercialUseAllowed = data
		case "use_without_attribution":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("use_without_attribution"))
			data, err := ec.unmarshalOLicenseValue2githubcominterlineiotransitlandlibservermodelLicenseValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseWithoutAttribution = data
		case "redistribution_allowed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redistribution_allowed"))
			data, err := ec.unmarshalOLicenseValue2githubcominterlineiotransitlandlibservermodelLicenseValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedistributionAllowed = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLocationFilter(ctx context.Context, obj any) (model.LocationFilter, error) {
	var it model.LocationFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ids", "location_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ids = data
		case "location_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocationID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLocationGroupFilter(ctx context.Context, obj any) (model.LocationGroupFilter, error) {
	var it model.LocationGroupFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ids", "location_group_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ids = data
		case "location_group_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location_group_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocationGroupID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOperatorFilter(ctx context.Context, obj any) (model.OperatorFilter, error) {
	var it model.OperatorFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"merged", "onestop_id", "feed_onestop_id", "agency_id", "search", "tags", "city_name", "adm0_name", "adm1_name", "adm0_iso", "adm1_iso", "license", "bbox", "within", "near"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "merged":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merged"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Merged = data
		case "onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnestopID = data
		case "feed_onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedOnestopID = data
		case "agency_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agency_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgencyID = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOTags2githubcominterlineiotransitlandlibttTags(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "city_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("city_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityName = data
		case "adm0_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm0_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Adm0Name = data
		case "adm1_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm1_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Adm1Name = data
		case "adm0_iso":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm0_iso"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Adm0Iso = data
		case "adm1_iso":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm1_iso"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Adm1Iso = data
		case "license":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			data, err := ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandlibservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.License = data
		case "bbox":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bbox"))
			data, err := ec.unmarshalOBoundingBox2githubcominterlineiotransitlandlibservermodelBoundingBox(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bbox = data
		case "within":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("within"))
			data, err := ec.unmarshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
			it.Within = data
		case "near":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			data, err := ec.unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
			it.Near = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPathwayFilter(ctx context.Context, obj any) (model.PathwayFilter, error) {
	var it model.PathwayFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"pathway_mode"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "pathway_mode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathway_mode"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathwayMode = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPathwaySetInput(ctx context.Context, obj any) (model.PathwaySetInput, error) {
	var it model.PathwaySetInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "feed_version", "pathway_id", "pathway_mode", "is_bidirectional", "length", "traversal_time", "stair_count", "max_slope", "min_width", "signposted_as", "reverse_signposted_as", "from_stop", "to_stop"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "feed_version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version"))
			data, err := ec.unmarshalOFeedVersionInput2githubcominterlineiotransitlandlibservermodelFeedVersionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedVersion = data
		case "pathway_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathway_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathwayID = data
		case "pathway_mode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathway_mode"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathwayMode = data
		case "is_bidirectional":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("is_bidirectional"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsBidirectional = data
		case "length":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("length"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Length = data
		case "traversal_time":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("traversal_time"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TraversalTime = data
		case "stair_count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stair_count"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StairCount = data
		case "max_slope":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_slope"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxSlope = data
		case "min_width":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min_width"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinWidth = data
		case "signposted_as":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("signposted_as"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SignpostedAs = data
		case "reverse_signposted_as":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reverse_signposted_as"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReverseSignpostedAs = data
		case "from_stop":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from_stop"))
			data, err := ec.unmarshalOStopSetInput2githubcominterlineiotransitlandlibservermodelStopSetInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromStop = data
		case "to_stop":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to_stop"))
			data, err := ec.unmarshalOStopSetInput2githubcominterlineiotransitlandlibservermodelStopSetInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToStop = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlaceFilter(ctx context.Context, obj any) (model.PlaceFilter, error) {
	var it model.PlaceFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"min_rank", "adm0_name", "adm1_name", "city_name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "min_rank":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min_rank"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinRank = data
		case "adm0_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm0_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Adm0Name = data
		case "adm1_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm1_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Adm1Name = data
		case "city_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("city_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CityName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPointRadius(ctx context.Context, obj any) (model.PointRadius, error) {
	var it model.PointRadius
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lat", "lon", "radius"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lat"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lat = data
		case "lon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lon"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lon = data
		case "radius":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("radius"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Radius = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRouteFilter(ctx context.Context, obj any) (model.RouteFilter, error) {
	var it model.RouteFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"onestop_id", "onestop_ids", "allow_previous_onestop_ids", "feed_version_sha1", "feed_onestop_id", "route_id", "route_type", "route_types", "serviced", "search", "operator_onestop_id", "license", "agency_ids", "location", "bbox", "within", "near"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnestopID = data
		case "onestop_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_ids"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnestopIds = data
		case "allow_previous_onestop_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allow_previous_onestop_ids"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowPreviousOnestopIds = data
		case "feed_version_sha1":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version_sha1"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedVersionSha1 = data
		case "feed_onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedOnestopID = data
		case "route_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RouteID = data
		case "route_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route_type"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RouteType = data
		case "route_types":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route_types"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RouteTypes = data
		case "serviced":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviced"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Serviced = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "operator_onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operator_onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OperatorOnestopID = data
		case "license":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			data, err := ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandlibservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.License = data
		case "agency_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agency_ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgencyIds = data
		case "location":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			data, err := ec.unmarshalORouteLocationFilter2githubcominterlineiotransitlandlibservermodelRouteLocationFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Location = data
		case "bbox":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bbox"))
			data, err := ec.unmarshalOBoundingBox2githubcominterlineiotransitlandlibservermodelBoundingBox(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bbox = data
		case "within":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("within"))
			data, err := ec.unmarshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
			it.Within = data
		case "near":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			data, err := ec.unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
			it.Near = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRouteLocationFilter(ctx context.Context, obj any) (model.RouteLocationFilter, error) {
	var it model.RouteLocationFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"bbox", "polygon", "near", "focus"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "bbox":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bbox"))
			data, err := ec.unmarshalOBoundingBox2githubcominterlineiotransitlandlibservermodelBoundingBox(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bbox = data
		case "polygon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("polygon"))
			data, err := ec.unmarshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
			it.Polygon = data
		case "near":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			data, err := ec.unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
			it.Near = data
		case "focus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("focus"))
			data, err := ec.unmarshalOFocusPoint2githubcominterlineiotransitlandlibservermodelFocusPoint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Focus = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSegmentFilter(ctx context.Context, obj any) (model.SegmentFilter, error) {
	var it model.SegmentFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"layer"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "layer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layer = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSegmentPatternFilter(ctx context.Context, obj any) (model.SegmentPatternFilter, error) {
	var it model.SegmentPatternFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"layer"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "layer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layer"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layer = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputServiceCoversFilter(ctx context.Context, obj any) (model.ServiceCoversFilter, error) {
	var it model.ServiceCoversFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fetched_after", "fetched_before", "feed_start_date", "feed_end_date", "start_date", "end_date", "earliest_calendar_date", "latest_calendar_date"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fetched_after":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fetched_after"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FetchedAfter = data
		case "fetched_before":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fetched_before"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FetchedBefore = data
		case "feed_start_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_start_date"))
			data, err := ec.unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedStartDate = data
		case "feed_end_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_end_date"))
			data, err := ec.unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedEndDate = data
		case "start_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start_date"))
			data, err := ec.unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartDate = data
		case "end_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end_date"))
			data, err := ec.unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndDate = data
		case "earliest_calendar_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("earliest_calendar_date"))
			data, err := ec.unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.EarliestCalendarDate = data
		case "latest_calendar_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("latest_calendar_date"))
			data, err := ec.unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.LatestCalendarDate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStopBuffer(ctx context.Context, obj any) (model.StopBuffer, error) {
	var it model.StopBuffer
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"stop_ids", "radius"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "stop_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopIds = data
		case "radius":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("radius"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Radius = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStopExternalReferenceSetInput(ctx context.Context, obj any) (model.StopExternalReferenceSetInput, error) {
	var it model.StopExternalReferenceSetInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"target_feed_onestop_id", "target_stop_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "target_feed_onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target_feed_onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetFeedOnestopID = data
		case "target_stop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target_stop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetStopID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStopFilter(ctx context.Context, obj any) (model.StopFilter, error) {
	var it model.StopFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"onestop_id", "onestop_ids", "allow_previous_onestop_ids", "feed_version_sha1", "feed_onestop_id", "stop_id", "stop_code", "location_type", "serviced", "search", "license", "served_by_onestop_ids", "served_by_route_type", "served_by_route_types", "agency_ids", "location", "bbox", "within", "near"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnestopID = data
		case "onestop_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_ids"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnestopIds = data
		case "allow_previous_onestop_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allow_previous_onestop_ids"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowPreviousOnestopIds = data
		case "feed_version_sha1":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version_sha1"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedVersionSha1 = data
		case "feed_onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedOnestopID = data
		case "stop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopID = data
		case "stop_code":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_code"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopCode = data
		case "location_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location_type"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocationType = data
		case "serviced":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviced"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Serviced = data
		case "search":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Search = data
		case "license":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			data, err := ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandlibservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.License = data
		case "served_by_onestop_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("served_by_onestop_ids"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServedByOnestopIds = data
		case "served_by_route_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("served_by_route_type"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServedByRouteType = data
		case "served_by_route_types":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("served_by_route_types"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServedByRouteTypes = data
		case "agency_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agency_ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgencyIds = data
		case "location":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location"))
			data, err := ec.unmarshalOStopLocationFilter2githubcominterlineiotransitlandlibservermodelStopLocationFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Location = data
		case "bbox":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bbox"))
			data, err := ec.unmarshalOBoundingBox2githubcominterlineiotransitlandlibservermodelBoundingBox(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bbox = data
		case "within":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("within"))
			data, err := ec.unmarshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
			it.Within = data
		case "near":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			data, err := ec.unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
			it.Near = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStopLocationFilter(ctx context.Context, obj any) (model.StopLocationFilter, error) {
	var it model.StopLocationFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"bbox", "polygon", "features", "near", "geography_ids", "focus"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "bbox":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bbox"))
			data, err := ec.unmarshalOBoundingBox2githubcominterlineiotransitlandlibservermodelBoundingBox(ctx, v)
			if err != nil {
				return it, err
			}
			it.Bbox = data
		case "polygon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("polygon"))
			data, err := ec.unmarshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
			it.Polygon = data
		case "features":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("features"))
			data, err := ec.unmarshalOFeature2githubcominterlineiotransitlandlibservermodelFeature(ctx, v)
			if err != nil {
				return it, err
			}
			it.Features = data
		case "near":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			data, err := ec.unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
			it.Near = data
		case "geography_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("geography_ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.GeographyIds = data
		case "focus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("focus"))
			data, err := ec.unmarshalOFocusPoint2githubcominterlineiotransitlandlibservermodelFocusPoint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Focus = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStopObservationFilter(ctx context.Context, obj any) (model.StopObservationFilter, error) {
	var it model.StopObservationFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"source", "feed_version_id", "trip_start_date"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "source":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Source = data
		case "feed_version_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version_id"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedVersionID = data
		case "trip_start_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trip_start_date"))
			data, err := ec.unmarshalNDate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.TripStartDate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStopSetInput(ctx context.Context, obj any) (model.StopSetInput, error) {
	var it model.StopSetInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "feed_version", "location_type", "stop_code", "stop_desc", "stop_id", "stop_name", "stop_timezone", "stop_url", "wheelchair_boarding", "zone_id", "platform_code", "tts_stop_name", "geometry", "parent", "level", "external_reference"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "feed_version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version"))
			data, err := ec.unmarshalOFeedVersionInput2githubcominterlineiotransitlandlibservermodelFeedVersionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedVersion = data
		case "location_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location_type"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocationType = data
		case "stop_code":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_code"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopCode = data
		case "stop_desc":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_desc"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopDesc = data
		case "stop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopID = data
		case "stop_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopName = data
		case "stop_timezone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_timezone"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopTimezone = data
		case "stop_url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_url"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopURL = data
		case "wheelchair_boarding":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("wheelchair_boarding"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.WheelchairBoarding = data
		case "zone_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("zone_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ZoneID = data
		case "platform_code":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("platform_code"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PlatformCode = data
		case "tts_stop_name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tts_stop_name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TtsStopName = data
		case "geometry":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("geometry"))
			data, err := ec.unmarshalOPoint2githubcominterlineiotransitlandlibttPoint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Geometry = data
		case "parent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parent"))
			data, err := ec.unmarshalOStopSetInput2githubcominterlineiotransitlandlibservermodelStopSetInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parent = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOLevelSetInput2githubcominterlineiotransitlandlibservermodelLevelSetInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "external_reference":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("external_reference"))
			data, err := ec.unmarshalOStopExternalReferenceSetInput2githubcominterlineiotransitlandlibservermodelStopExternalReferenceSetInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalReference = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStopTimeFilter(ctx context.Context, obj any) (model.StopTimeFilter, error) {
	var it model.StopTimeFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"date", "relative_date", "service_date", "use_service_window", "start_time", "end_time", "start", "end", "next", "route_onestop_ids", "allow_previous_route_onestop_ids", "exclude_first", "exclude_last"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		case "relative_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("relative_date"))
			data, err := ec.unmarshalORelativeDate2githubcominterlineiotransitlandlibservermodelRelativeDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.RelativeDate = data
		case "service_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("service_date"))
			data, err := ec.unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceDate = data
		case "use_service_window":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("use_service_window"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseServiceWindow = data
		case "start_time":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start_time"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartTime = data
		case "end_time":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end_time"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndTime = data
		case "start":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
			data, err := ec.unmarshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, v)
			if err != nil {
				return it, err
			}
			it.Start = data
		case "end":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
			data, err := ec.unmarshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, v)
			if err != nil {
				return it, err
			}
			it.End = data
		case "next":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("next"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Next = data
		case "route_onestop_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route_onestop_ids"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RouteOnestopIds = data
		case "allow_previous_route_onestop_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allow_previous_route_onestop_ids"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowPreviousRouteOnestopIds = data
		case "exclude_first":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exclude_first"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExcludeFirst = data
		case "exclude_last":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exclude_last"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExcludeLast = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTripFilter(ctx context.Context, obj any) (model.TripFilter, error) {
	var it model.TripFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"service_date", "relative_date", "use_service_window", "trip_id", "stop_pattern_id", "license", "route_ids", "route_onestop_ids", "feed_version_sha1", "feed_onestop_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "service_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("service_date"))
			data, err := ec.unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceDate = data
		case "relative_date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("relative_date"))
			data, err := ec.unmarshalORelativeDate2githubcominterlineiotransitlandlibservermodelRelativeDate(ctx, v)
			if err != nil {
				return it, err
			}
			it.RelativeDate = data
		case "use_service_window":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("use_service_window"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseServiceWindow = data
		case "trip_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trip_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TripID = data
		case "stop_pattern_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_pattern_id"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StopPatternID = data
		case "license":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			data, err := ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandlibservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
			it.License = data
		case "route_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route_ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RouteIds = data
		case "route_onestop_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route_onestop_ids"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RouteOnestopIds = data
		case "feed_version_sha1":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version_sha1"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedVersionSha1 = data
		case "feed_onestop_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedOnestopID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTripStopTimeFilter(ctx context.Context, obj any) (model.TripStopTimeFilter, error) {
	var it model.TripStopTimeFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"start", "end"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "start":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
			data, err := ec.unmarshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, v)
			if err != nil {
				return it, err
			}
			it.Start = data
		case "end":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
			data, err := ec.unmarshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, v)
			if err != nil {
				return it, err
			}
			it.End = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputValidationReportFilter(ctx context.Context, obj any) (model.ValidationReportFilter, error) {
	var it model.ValidationReportFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"report_ids", "success", "validator", "validator_version", "includes_rt", "includes_static"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "report_ids":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("report_ids"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReportIds = data
		case "success":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("success"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Success = data
		case "validator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("validator"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Validator = data
		case "validator_version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("validator_version"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValidatorVersion = data
		case "includes_rt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includes_rt"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludesRt = data
		case "includes_static":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includes_static"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludesStatic = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWaypointInput(ctx context.Context, obj any) (model.WaypointInput, error) {
	var it model.WaypointInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lon", "lat", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lon"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lon = data
		case "lat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lat"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lat = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var agencyImplementors = []string{"Agency"}

func (ec *executionContext) _Agency(ctx context.Context, sel ast.SelectionSet, obj *model.Agency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Agency")
		case "id":
			out.Values[i] = ec._Agency_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "onestop_id":
			out.Values[i] = ec._Agency_onestop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "agency_email":
			out.Values[i] = ec._Agency_agency_email(ctx, field, obj)
		case "agency_fare_url":
			out.Values[i] = ec._Agency_agency_fare_url(ctx, field, obj)
		case "agency_id":
			out.Values[i] = ec._Agency_agency_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "agency_lang":
			out.Values[i] = ec._Agency_agency_lang(ctx, field, obj)
		case "agency_name":
			out.Values[i] = ec._Agency_agency_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "agency_phone":
			out.Values[i] = ec._Agency_agency_phone(ctx, field, obj)
		case "agency_timezone":
			out.Values[i] = ec._Agency_agency_timezone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "agency_url":
			out.Values[i] = ec._Agency_agency_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feed_version_sha1":
			out.Values[i] = ec._Agency_feed_version_sha1(ctx, field, obj)
		case "feed_onestop_id":
			out.Values[i] = ec._Agency_feed_onestop_id(ctx, field, obj)
		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Agency_feed_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "geometry":
			out.Values[i] = ec._Agency_geometry(ctx, field, obj)
		case "search_rank":
			out.Values[i] = ec._Agency_search_rank(ctx, field, obj)
		case "operator":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Agency_operator(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "places":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Agency_places(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "routes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Agency_routes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "census_geographies":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Agency_census_geographies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "alerts":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Agency_alerts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var agencyPlaceImplementors = []string{"AgencyPlace"}

func (ec *executionContext) _AgencyPlace(ctx context.Context, sel ast.SelectionSet, obj *model.AgencyPlace) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agencyPlaceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AgencyPlace")
		case "city_name":
			out.Values[i] = ec._AgencyPlace_city_name(ctx, field, obj)
		case "adm1_name":
			out.Values[i] = ec._AgencyPlace_adm1_name(ctx, field, obj)
		case "adm1_iso":
			out.Values[i] = ec._AgencyPlace_adm1_iso(ctx, field, obj)
		case "adm0_name":
			out.Values[i] = ec._AgencyPlace_adm0_name(ctx, field, obj)
		case "adm0_iso":
			out.Values[i] = ec._AgencyPlace_adm0_iso(ctx, field, obj)
		case "rank":
			out.Values[i] = ec._AgencyPlace_rank(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var alertImplementors = []string{"Alert"}

func (ec *executionContext) _Alert(ctx context.Context, sel ast.SelectionSet, obj *model.Alert) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alertImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Alert")
		case "active_period":
			out.Values[i] = ec._Alert_active_period(ctx, field, obj)
		case "cause":
			out.Values[i] = ec._Alert_cause(ctx, field, obj)
		case "effect":
			out.Values[i] = ec._Alert_effect(ctx, field, obj)
		case "header_text":
			out.Values[i] = ec._Alert_header_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description_text":
			out.Values[i] = ec._Alert_description_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tts_header_text":
			out.Values[i] = ec._Alert_tts_header_text(ctx, field, obj)
		case "tts_description_text":
			out.Values[i] = ec._Alert_tts_description_text(ctx, field, obj)
		case "url":
			out.Values[i] = ec._Alert_url(ctx, field, obj)
		case "severity_level":
			out.Values[i] = ec._Alert_severity_level(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bookingRuleImplementors = []string{"BookingRule"}

func (ec *executionContext) _BookingRule(ctx context.Context, sel ast.SelectionSet, obj *model.BookingRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bookingRuleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BookingRule")
		case "id":
			out.Values[i] = ec._BookingRule_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "booking_rule_id":
			out.Values[i] = ec._BookingRule_booking_rule_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "booking_type":
			out.Values[i] = ec._BookingRule_booking_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "prior_notice_duration_min":
			out.Values[i] = ec._BookingRule_prior_notice_duration_min(ctx, field, obj)
		case "prior_notice_duration_max":
			out.Values[i] = ec._BookingRule_prior_notice_duration_max(ctx, field, obj)
		case "prior_notice_last_day":
			out.Values[i] = ec._BookingRule_prior_notice_last_day(ctx, field, obj)
		case "prior_notice_last_time":
			out.Values[i] = ec._BookingRule_prior_notice_last_time(ctx, field, obj)
		case "prior_notice_start_day":
			out.Values[i] = ec._BookingRule_prior_notice_start_day(ctx, field, obj)
		case "prior_notice_start_time":
			out.Values[i] = ec._BookingRule_prior_notice_start_time(ctx, field, obj)
		case "prior_notice_service":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BookingRule_prior_notice_service(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "message":
			out.Values[i] = ec._BookingRule_message(ctx, field, obj)
		case "pickup_message":
			out.Values[i] = ec._BookingRule_pickup_message(ctx, field, obj)
		case "drop_off_message":
			out.Values[i] = ec._BookingRule_drop_off_message(ctx, field, obj)
		case "phone_number":
			out.Values[i] = ec._BookingRule_phone_number(ctx, field, obj)
		case "info_url":
			out.Values[i] = ec._BookingRule_info_url(ctx, field, obj)
		case "booking_url":
			out.Values[i] = ec._BookingRule_booking_url(ctx, field, obj)
		case "feed_version_sha1":
			out.Values[i] = ec._BookingRule_feed_version_sha1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feed_onestop_id":
			out.Values[i] = ec._BookingRule_feed_onestop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BookingRule_feed_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var calendarImplementors = []string{"Calendar"}

func (ec *executionContext) _Calendar(ctx context.Context, sel ast.SelectionSet, obj *model.Calendar) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, calendarImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Calendar")
		case "id":
			out.Values[i] = ec._Calendar_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "service_id":
			out.Values[i] = ec._Calendar_service_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "start_date":
			out.Values[i] = ec._Calendar_start_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "end_date":
			out.Values[i] = ec._Calendar_end_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "monday":
			out.Values[i] = ec._Calendar_monday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tuesday":
			out.Values[i] = ec._Calendar_tuesday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "wednesday":
			out.Values[i] = ec._Calendar_wednesday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "thursday":
			out.Values[i] = ec._Calendar_thursday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "friday":
			out.Values[i] = ec._Calendar_friday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "saturday":
			out.Values[i] = ec._Calendar_saturday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sunday":
			out.Values[i] = ec._Calendar_sunday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "added_dates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Calendar_added_dates(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "removed_dates":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Calendar_removed_dates(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var censusDatasetImplementors = []string{"CensusDataset"}

func (ec *executionContext) _CensusDataset(ctx context.Context, sel ast.SelectionSet, obj *model.CensusDataset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, censusDatasetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CensusDataset")
		case "id":
			out.Values[i] = ec._CensusDataset_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._CensusDataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._CensusDataset_description(ctx, field, obj)
		case "url":
			out.Values[i] = ec._CensusDataset_url(ctx, field, obj)
		case "year_min":
			out.Values[i] = ec._CensusDataset_year_min(ctx, field, obj)
		case "year_max":
			out.Values[i] = ec._CensusDataset_year_max(ctx, field, obj)
		case "sources":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusDataset_sources(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "geographies":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusDataset_geographies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tables":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusDataset_tables(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "layers":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusDataset_layers(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var censusFieldImplementors = []string{"CensusField"}

func (ec *executionContext) _CensusField(ctx context.Context, sel ast.SelectionSet, obj *model.CensusField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, censusFieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CensusField")
		case "id":
			out.Values[i] = ec._CensusField_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "field_name":
			out.Values[i] = ec._CensusField_field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "field_title":
			out.Values[i] = ec._CensusField_field_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "column_order":
			out.Values[i] = ec._CensusField_column_order(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var censusGeographyImplementors = []string{"CensusGeography"}

func (ec *executionContext) _CensusGeography(ctx context.Context, sel ast.SelectionSet, obj *model.CensusGeography) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, censusGeographyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CensusGeography")
		case "id":
			out.Values[i] = ec._CensusGeography_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dataset_name":
			out.Values[i] = ec._CensusGeography_dataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "source_name":
			out.Values[i] = ec._CensusGeography_source_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "layer_name":
			out.Values[i] = ec._CensusGeography_layer_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "geoid":
			out.Values[i] = ec._CensusGeography_geoid(ctx, field, obj)
		case "name":
			out.Values[i] = ec._CensusGeography_name(ctx, field, obj)
		case "geometry_area":
			out.Values[i] = ec._CensusGeography_geometry_area(ctx, field, obj)
		case "aland":
			out.Values[i] = ec._CensusGeography_aland(ctx, field, obj)
		case "awater":
			out.Values[i] = ec._CensusGeography_awater(ctx, field, obj)
		case "adm1_name":
			out.Values[i] = ec._CensusGeography_adm1_name(ctx, field, obj)
		case "adm1_iso":
			out.Values[i] = ec._CensusGeography_adm1_iso(ctx, field, obj)
		case "adm0_name":
			out.Values[i] = ec._CensusGeography_adm0_name(ctx, field, obj)
		case "adm0_iso":
			out.Values[i] = ec._CensusGeography_adm0_iso(ctx, field, obj)
		case "geometry":
			out.Values[i] = ec._CensusGeography_geometry(ctx, field, obj)
		case "intersection_area":
			out.Values[i] = ec._CensusGeography_intersection_area(ctx, field, obj)
		case "intersection_geometry":
			out.Values[i] = ec._CensusGeography_intersection_geometry(ctx, field, obj)
		case "values":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusGeography_values(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "layer":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusGeography_layer(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "source":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusGeography_source(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var censusLayerImplementors = []string{"CensusLayer"}

func (ec *executionContext) _CensusLayer(ctx context.Context, sel ast.SelectionSet, obj *model.CensusLayer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, censusLayerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CensusLayer")
		case "id":
			out.Values[i] = ec._CensusLayer_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._CensusLayer_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._CensusLayer_description(ctx, field, obj)
		case "geographies":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusLayer_geographies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var censusSourceImplementors = []string{"CensusSource"}

func (ec *executionContext) _CensusSource(ctx context.Context, sel ast.SelectionSet, obj *model.CensusSource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, censusSourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CensusSource")
		case "id":
			out.Values[i] = ec._CensusSource_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._CensusSource_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._CensusSource_description(ctx, field, obj)
		case "url":
			out.Values[i] = ec._CensusSource_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sha1":
			out.Values[i] = ec._CensusSource_sha1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "geographies":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusSource_geographies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tables":
			out.Values[i] = ec._CensusSource_tables(ctx, field, obj)
		case "layers":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusSource_layers(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var censusTableImplementors = []string{"CensusTable"}

func (ec *executionContext) _CensusTable(ctx context.Context, sel ast.SelectionSet, obj *model.CensusTable) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, censusTableImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CensusTable")
		case "id":
			out.Values[i] = ec._CensusTable_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "table_name":
			out.Values[i] = ec._CensusTable_table_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "table_title":
			out.Values[i] = ec._CensusTable_table_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "table_group":
			out.Values[i] = ec._CensusTable_table_group(ctx, field, obj)
		case "table_details":
			out.Values[i] = ec._CensusTable_table_details(ctx, field, obj)
		case "fields":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusTable_fields(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var censusValueImplementors = []string{"CensusValue"}

func (ec *executionContext) _CensusValue(ctx context.Context, sel ast.SelectionSet, obj *model.CensusValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, censusValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CensusValue")
		case "dataset_name":
			out.Values[i] = ec._CensusValue_dataset_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "source_name":
			out.Values[i] = ec._CensusValue_source_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "table":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusValue_table(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "values":
			out.Values[i] = ec._CensusValue_values(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "geoid":
			out.Values[i] = ec._CensusValue_geoid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var directionsImplementors = []string{"Directions"}

func (ec *executionContext) _Directions(ctx context.Context, sel ast.SelectionSet, obj *model.Directions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, directionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Directions")
		case "success":
			out.Values[i] = ec._Directions_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exception":
			out.Values[i] = ec._Directions_exception(ctx, field, obj)
		case "data_source":
			out.Values[i] = ec._Directions_data_source(ctx, field, obj)
		case "origin":
			out.Values[i] = ec._Directions_origin(ctx, field, obj)
		case "destination":
			out.Values[i] = ec._Directions_destination(ctx, field, obj)
		case "duration":
			out.Values[i] = ec._Directions_duration(ctx, field, obj)
		case "distance":
			out.Values[i] = ec._Directions_distance(ctx, field, obj)
		case "start_time":
			out.Values[i] = ec._Directions_start_time(ctx, field, obj)
		case "end_time":
			out.Values[i] = ec._Directions_end_time(ctx, field, obj)
		case "itineraries":
			out.Values[i] = ec._Directions_itineraries(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distanceImplementors = []string{"Distance"}

func (ec *executionContext) _Distance(ctx context.Context, sel ast.SelectionSet, obj *model.Distance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distanceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Distance")
		case "distance":
			out.Values[i] = ec._Distance_distance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "units":
			out.Values[i] = ec._Distance_units(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var durationImplementors = []string{"Duration"}

func (ec *executionContext) _Duration(ctx context.Context, sel ast.SelectionSet, obj *model.Duration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, durationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Duration")
		case "duration":
			out.Values[i] = ec._Duration_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "units":
			out.Values[i] = ec._Duration_units(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var entityDeleteResultImplementors = []string{"EntityDeleteResult"}

func (ec *executionContext) _EntityDeleteResult(ctx context.Context, sel ast.SelectionSet, obj *model.EntityDeleteResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entityDeleteResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EntityDeleteResult")
		case "id":
			out.Values[i] = ec._EntityDeleteResult_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedImplementors = []string{"Feed"}

func (ec *executionContext) _Feed(ctx context.Context, sel ast.SelectionSet, obj *model.Feed) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Feed")
		case "id":
			out.Values[i] = ec._Feed_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "onestop_id":
			out.Values[i] = ec._Feed_onestop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Feed_name(ctx, field, obj)
		case "file":
			out.Values[i] = ec._Feed_file(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "spec":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_spec(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "languages":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_languages(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tags":
			out.Values[i] = ec._Feed_tags(ctx, field, obj)
		case "authorization":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_authorization(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "urls":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_urls(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "license":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_license(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "search_rank":
			out.Values[i] = ec._Feed_search_rank(ctx, field, obj)
		case "associated_operators":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_associated_operators(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "feed_state":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_feed_state(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "feed_fetches":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_feed_fetches(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "feed_versions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_feed_versions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedAuthorizationImplementors = []string{"FeedAuthorization"}

func (ec *executionContext) _FeedAuthorization(ctx context.Context, sel ast.SelectionSet, obj *model.FeedAuthorization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedAuthorizationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedAuthorization")
		case "type":
			out.Values[i] = ec._FeedAuthorization_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "param_name":
			out.Values[i] = ec._FeedAuthorization_param_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "info_url":
			out.Values[i] = ec._FeedAuthorization_info_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedFetchImplementors = []string{"FeedFetch"}

func (ec *executionContext) _FeedFetch(ctx context.Context, sel ast.SelectionSet, obj *model.FeedFetch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedFetchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedFetch")
		case "id":
			out.Values[i] = ec._FeedFetch_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url_type":
			out.Values[i] = ec._FeedFetch_url_type(ctx, field, obj)
		case "url":
			out.Values[i] = ec._FeedFetch_url(ctx, field, obj)
		case "success":
			out.Values[i] = ec._FeedFetch_success(ctx, field, obj)
		case "fetched_at":
			out.Values[i] = ec._FeedFetch_fetched_at(ctx, field, obj)
		case "fetch_error":
			out.Values[i] = ec._FeedFetch_fetch_error(ctx, field, obj)
		case "response_size":
			out.Values[i] = ec._FeedFetch_response_size(ctx, field, obj)
		case "response_code":
			out.Values[i] = ec._FeedFetch_response_code(ctx, field, obj)
		case "response_sha1":
			out.Values[i] = ec._FeedFetch_response_sha1(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedInfoImplementors = []string{"FeedInfo"}

func (ec *executionContext) _FeedInfo(ctx context.Context, sel ast.SelectionSet, obj *model.FeedInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedInfo")
		case "id":
			out.Values[i] = ec._FeedInfo_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "feed_publisher_name":
			out.Values[i] = ec._FeedInfo_feed_publisher_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "feed_publisher_url":
			out.Values[i] = ec._FeedInfo_feed_publisher_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "feed_lang":
			out.Values[i] = ec._FeedInfo_feed_lang(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "default_lang":
			out.Values[i] = ec._FeedInfo_default_lang(ctx, field, obj)
		case "feed_version":
			out.Values[i] = ec._FeedInfo_feed_version(ctx, field, obj)
		case "feed_start_date":
			out.Values[i] = ec._FeedInfo_feed_start_date(ctx, field, obj)
		case "feed_end_date":
			out.Values[i] = ec._FeedInfo_feed_end_date(ctx, field, obj)
		case "feed_contact_email":
			out.Values[i] = ec._FeedInfo_feed_contact_email(ctx, field, obj)
		case "feed_contact_url":
			out.Values[i] = ec._FeedInfo_feed_contact_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedLicenseImplementors = []string{"FeedLicense"}

func (ec *executionContext) _FeedLicense(ctx context.Context, sel ast.SelectionSet, obj *model.FeedLicense) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedLicenseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedLicense")
		case "spdx_identifier":
			out.Values[i] = ec._FeedLicense_spdx_identifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._FeedLicense_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "use_without_attribution":
			out.Values[i] = ec._FeedLicense_use_without_attribution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "create_derived_product":
			out.Values[i] = ec._FeedLicense_create_derived_product(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "redistribution_allowed":
			out.Values[i] = ec._FeedLicense_redistribution_allowed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "commercial_use_allowed":
			out.Values[i] = ec._FeedLicense_commercial_use_allowed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "share_alike_optional":
			out.Values[i] = ec._FeedLicense_share_alike_optional(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attribution_text":
			out.Values[i] = ec._FeedLicense_attribution_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attribution_instructions":
			out.Values[i] = ec._FeedLicense_attribution_instructions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedStateImplementors = []string{"FeedState"}

func (ec *executionContext) _FeedState(ctx context.Context, sel ast.SelectionSet, obj *model.FeedState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedState")
		case "id":
			out.Values[i] = ec._FeedState_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedState_feed_version(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedUrlsImplementors = []string{"FeedUrls"}

func (ec *executionContext) _FeedUrls(ctx context.Context, sel ast.SelectionSet, obj *model.FeedUrls) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedUrlsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedUrls")
		case "static_current":
			out.Values[i] = ec._FeedUrls_static_current(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "static_historic":
			out.Values[i] = ec._FeedUrls_static_historic(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "static_planned":
			out.Values[i] = ec._FeedUrls_static_planned(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "realtime_vehicle_positions":
			out.Values[i] = ec._FeedUrls_realtime_vehicle_positions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "realtime_trip_updates":
			out.Values[i] = ec._FeedUrls_realtime_trip_updates(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "realtime_alerts":
			out.Values[i] = ec._FeedUrls_realtime_alerts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gbfs_auto_discovery":
			out.Values[i] = ec._FeedUrls_gbfs_auto_discovery(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mds_provider":
			out.Values[i] = ec._FeedUrls_mds_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedVersionImplementors = []string{"FeedVersion"}

func (ec *executionContext) _FeedVersion(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersion")
		case "id":
			out.Values[i] = ec._FeedVersion_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sha1":
			out.Values[i] = ec._FeedVersion_sha1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "fetched_at":
			out.Values[i] = ec._FeedVersion_fetched_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "url":
			out.Values[i] = ec._FeedVersion_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "earliest_calendar_date":
			out.Values[i] = ec._FeedVersion_earliest_calendar_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "latest_calendar_date":
			out.Values[i] = ec._FeedVersion_latest_calendar_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "created_by":
			out.Values[i] = ec._FeedVersion_created_by(ctx, field, obj)
		case "updated_by":
			out.Values[i] = ec._FeedVersion_updated_by(ctx, field, obj)
		case "name":
			out.Values[i] = ec._FeedVersion_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._FeedVersion_description(ctx, field, obj)
		case "file":
			out.Values[i] = ec._FeedVersion_file(ctx, field, obj)
		case "geometry":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_geometry(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "feed":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_feed(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "feed_version_gtfs_import":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_feed_version_gtfs_import(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "files":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_files(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "service_levels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_service_levels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "service_window":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_service_window(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "agencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_agencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "routes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_routes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stops":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_stops(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trips":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_trips(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "locations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_locations(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "booking_rules":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_booking_rules(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "location_groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_location_groups(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "feed_infos":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_feed_infos(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "validation_reports":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_validation_reports(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "segments":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_segments(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedVersionDeleteResultImplementors = []string{"FeedVersionDeleteResult"}

func (ec *executionContext) _FeedVersionDeleteResult(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionDeleteResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionDeleteResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionDeleteResult")
		case "success":
			out.Values[i] = ec._FeedVersionDeleteResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedVersionFetchResultImplementors = []string{"FeedVersionFetchResult"}

func (ec *executionContext) _FeedVersionFetchResult(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionFetchResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionFetchResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionFetchResult")
		case "feed_version":
			out.Values[i] = ec._FeedVersionFetchResult_feed_version(ctx, field, obj)
		case "fetch_error":
			out.Values[i] = ec._FeedVersionFetchResult_fetch_error(ctx, field, obj)
		case "found_sha1":
			out.Values[i] = ec._FeedVersionFetchResult_found_sha1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "found_dir_sha1":
			out.Values[i] = ec._FeedVersionFetchResult_found_dir_sha1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedVersionFileInfoImplementors = []string{"FeedVersionFileInfo"}

func (ec *executionContext) _FeedVersionFileInfo(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionFileInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionFileInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionFileInfo")
		case "id":
			out.Values[i] = ec._FeedVersionFileInfo_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FeedVersionFileInfo_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rows":
			out.Values[i] = ec._FeedVersionFileInfo_rows(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sha1":
			out.Values[i] = ec._FeedVersionFileInfo_sha1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "header":
			out.Values[i] = ec._FeedVersionFileInfo_header(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "csv_like":
			out.Values[i] = ec._FeedVersionFileInfo_csv_like(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "size":
			out.Values[i] = ec._FeedVersionFileInfo_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "values_count":
			out.Values[i] = ec._FeedVersionFileInfo_values_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "values_unique":
			out.Values[i] = ec._FeedVersionFileInfo_values_unique(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedVersionGtfsImportImplementors = []string{"FeedVersionGtfsImport"}

func (ec *executionContext) _FeedVersionGtfsImport(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionGtfsImport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionGtfsImportImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionGtfsImport")
		case "id":
			out.Values[i] = ec._FeedVersionGtfsImport_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "in_progress":
			out.Values[i] = ec._FeedVersionGtfsImport_in_progress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "success":
			out.Values[i] = ec._FeedVersionGtfsImport_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "schedule_removed":
			out.Values[i] = ec._FeedVersionGtfsImport_schedule_removed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "exception_log":
			out.Values[i] = ec._FeedVersionGtfsImport_exception_log(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "skip_entity_error_count":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersionGtfsImport_skip_entity_error_count(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "entity_count":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersionGtfsImport_entity_count(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "warning_count":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersionGtfsImport_warning_count(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "skip_entity_reference_count":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersionGtfsImport_skip_entity_reference_count(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "skip_entity_filter_count":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersionGtfsImport_skip_entity_filter_count(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "skip_entity_marked_count":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersionGtfsImport_skip_entity_marked_count(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "interpolated_stop_time_count":
			out.Values[i] = ec._FeedVersionGtfsImport_interpolated_stop_time_count(ctx, field, obj)
		case "created_at":
			out.Values[i] = ec._FeedVersionGtfsImport_created_at(ctx, field, obj)
		case "updated_at":
			out.Values[i] = ec._FeedVersionGtfsImport_updated_at(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedVersionImportResultImplementors = []string{"FeedVersionImportResult"}

func (ec *executionContext) _FeedVersionImportResult(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionImportResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionImportResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionImportResult")
		case "success":
			out.Values[i] = ec._FeedVersionImportResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedVersionServiceLevelImplementors = []string{"FeedVersionServiceLevel"}

func (ec *executionContext) _FeedVersionServiceLevel(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionServiceLevel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionServiceLevelImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionServiceLevel")
		case "id":
			out.Values[i] = ec._FeedVersionServiceLevel_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "start_date":
			out.Values[i] = ec._FeedVersionServiceLevel_start_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "end_date":
			out.Values[i] = ec._FeedVersionServiceLevel_end_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "monday":
			out.Values[i] = ec._FeedVersionServiceLevel_monday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tuesday":
			out.Values[i] = ec._FeedVersionServiceLevel_tuesday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "wednesday":
			out.Values[i] = ec._FeedVersionServiceLevel_wednesday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "thursday":
			out.Values[i] = ec._FeedVersionServiceLevel_thursday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "friday":
			out.Values[i] = ec._FeedVersionServiceLevel_friday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saturday":
			out.Values[i] = ec._FeedVersionServiceLevel_saturday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sunday":
			out.Values[i] = ec._FeedVersionServiceLevel_sunday(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedVersionServiceWindowImplementors = []string{"FeedVersionServiceWindow"}

func (ec *executionContext) _FeedVersionServiceWindow(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionServiceWindow) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionServiceWindowImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionServiceWindow")
		case "id":
			out.Values[i] = ec._FeedVersionServiceWindow_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "feed_start_date":
			out.Values[i] = ec._FeedVersionServiceWindow_feed_start_date(ctx, field, obj)
		case "feed_end_date":
			out.Values[i] = ec._FeedVersionServiceWindow_feed_end_date(ctx, field, obj)
		case "earliest_calendar_date":
			out.Values[i] = ec._FeedVersionServiceWindow_earliest_calendar_date(ctx, field, obj)
		case "latest_calendar_date":
			out.Values[i] = ec._FeedVersionServiceWindow_latest_calendar_date(ctx, field, obj)
		case "fallback_week":
			out.Values[i] = ec._FeedVersionServiceWindow_fallback_week(ctx, field, obj)
		case "default_timezone":
			out.Values[i] = ec._FeedVersionServiceWindow_default_timezone(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var feedVersionUnimportResultImplementors = []string{"FeedVersionUnimportResult"}

func (ec *executionContext) _FeedVersionUnimportResult(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionUnimportResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionUnimportResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionUnimportResult")
		case "success":
			out.Values[i] = ec._FeedVersionUnimportResult_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var flexStopTimeImplementors = []string{"FlexStopTime"}

func (ec *executionContext) _FlexStopTime(ctx context.Context, sel ast.SelectionSet, obj *model.StopTime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, flexStopTimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FlexStopTime")
		case "arrival_time":
			out.Values[i] = ec._FlexStopTime_arrival_time(ctx, field, obj)
		case "departure_time":
			out.Values[i] = ec._FlexStopTime_departure_time(ctx, field, obj)
		case "stop_sequence":
			out.Values[i] = ec._FlexStopTime_stop_sequence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stop_headsign":
			out.Values[i] = ec._FlexStopTime_stop_headsign(ctx, field, obj)
		case "pickup_type":
			out.Values[i] = ec._FlexStopTime_pickup_type(ctx, field, obj)
		case "drop_off_type":
			out.Values[i] = ec._FlexStopTime_drop_off_type(ctx, field, obj)
		case "timepoint":
			out.Values[i] = ec._FlexStopTime_timepoint(ctx, field, obj)
		case "continuous_drop_off":
			out.Values[i] = ec._FlexStopTime_continuous_drop_off(ctx, field, obj)
		case "continuous_pickup":
			out.Values[i] = ec._FlexStopTime_continuous_pickup(ctx, field, obj)
		case "shape_dist_traveled":
			out.Values[i] = ec._FlexStopTime_shape_dist_traveled(ctx, field, obj)
		case "interpolated":
			out.Values[i] = ec._FlexStopTime_interpolated(ctx, field, obj)
		case "start_pickup_drop_off_window":
			out.Values[i] = ec._FlexStopTime_start_pickup_drop_off_window(ctx, field, obj)
		case "end_pickup_drop_off_window":
			out.Values[i] = ec._FlexStopTime_end_pickup_drop_off_window(ctx, field, obj)
		case "pickup_booking_rule":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FlexStopTime_pickup_booking_rule(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "drop_off_booking_rule":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FlexStopTime_drop_off_booking_rule(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "location":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FlexStopTime_location(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "location_group":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FlexStopTime_location_group(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trip":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FlexStopTime_trip(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "arrival":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FlexStopTime_arrival(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "departure":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FlexStopTime_departure(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "service_date":
			out.Values[i] = ec._FlexStopTime_service_date(ctx, field, obj)
		case "date":
			out.Values[i] = ec._FlexStopTime_date(ctx, field, obj)
		case "schedule_relationship":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FlexStopTime_schedule_relationship(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var frequencyImplementors = []string{"Frequency"}

func (ec *executionContext) _Frequency(ctx context.Context, sel ast.SelectionSet, obj *model.Frequency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, frequencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Frequency")
		case "id":
			out.Values[i] = ec._Frequency_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "start_time":
			out.Values[i] = ec._Frequency_start_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "end_time":
			out.Values[i] = ec._Frequency_end_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "headway_secs":
			out.Values[i] = ec._Frequency_headway_secs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exact_times":
			out.Values[i] = ec._Frequency_exact_times(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsAlertTimeImplementors = []string{"GbfsAlertTime"}

func (ec *executionContext) _GbfsAlertTime(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsAlertTime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsAlertTimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsAlertTime")
		case "start":
			out.Values[i] = ec._GbfsAlertTime_start(ctx, field, obj)
		case "end":
			out.Values[i] = ec._GbfsAlertTime_end(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsBrandAssetImplementors = []string{"GbfsBrandAsset"}

func (ec *executionContext) _GbfsBrandAsset(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsBrandAsset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsBrandAssetImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsBrandAsset")
		case "brand_last_modified":
			out.Values[i] = ec._GbfsBrandAsset_brand_last_modified(ctx, field, obj)
		case "brand_terms_url":
			out.Values[i] = ec._GbfsBrandAsset_brand_terms_url(ctx, field, obj)
		case "brand_image_url":
			out.Values[i] = ec._GbfsBrandAsset_brand_image_url(ctx, field, obj)
		case "brand_image_url_dark":
			out.Values[i] = ec._GbfsBrandAsset_brand_image_url_dark(ctx, field, obj)
		case "color":
			out.Values[i] = ec._GbfsBrandAsset_color(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsFeedImplementors = []string{"GbfsFeed"}

func (ec *executionContext) _GbfsFeed(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsFeed) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsFeedImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsFeed")
		case "system_information":
			out.Values[i] = ec._GbfsFeed_system_information(ctx, field, obj)
		case "station_information":
			out.Values[i] = ec._GbfsFeed_station_information(ctx, field, obj)
		case "rental_hours":
			out.Values[i] = ec._GbfsFeed_rental_hours(ctx, field, obj)
		case "calendars":
			out.Values[i] = ec._GbfsFeed_calendars(ctx, field, obj)
		case "alerts":
			out.Values[i] = ec._GbfsFeed_alerts(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsFreeBikeStatusImplementors = []string{"GbfsFreeBikeStatus"}

func (ec *executionContext) _GbfsFreeBikeStatus(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsFreeBikeStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsFreeBikeStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsFreeBikeStatus")
		case "bike_id":
			out.Values[i] = ec._GbfsFreeBikeStatus_bike_id(ctx, field, obj)
		case "lat":
			out.Values[i] = ec._GbfsFreeBikeStatus_lat(ctx, field, obj)
		case "lon":
			out.Values[i] = ec._GbfsFreeBikeStatus_lon(ctx, field, obj)
		case "is_reserved":
			out.Values[i] = ec._GbfsFreeBikeStatus_is_reserved(ctx, field, obj)
		case "is_disabled":
			out.Values[i] = ec._GbfsFreeBikeStatus_is_disabled(ctx, field, obj)
		case "last_reported":
			out.Values[i] = ec._GbfsFreeBikeStatus_last_reported(ctx, field, obj)
		case "current_range_meters":
			out.Values[i] = ec._GbfsFreeBikeStatus_current_range_meters(ctx, field, obj)
		case "current_fuel_percent":
			out.Values[i] = ec._GbfsFreeBikeStatus_current_fuel_percent(ctx, field, obj)
		case "vehicle_equipment":
			out.Values[i] = ec._GbfsFreeBikeStatus_vehicle_equipment(ctx, field, obj)
		case "available_until":
			out.Values[i] = ec._GbfsFreeBikeStatus_available_until(ctx, field, obj)
		case "station":
			out.Values[i] = ec._GbfsFreeBikeStatus_station(ctx, field, obj)
		case "home_station":
			out.Values[i] = ec._GbfsFreeBikeStatus_home_station(ctx, field, obj)
		case "pricing_plan":
			out.Values[i] = ec._GbfsFreeBikeStatus_pricing_plan(ctx, field, obj)
		case "vehicle_type":
			out.Values[i] = ec._GbfsFreeBikeStatus_vehicle_type(ctx, field, obj)
		case "rental_uris":
			out.Values[i] = ec._GbfsFreeBikeStatus_rental_uris(ctx, field, obj)
		case "feed":
			out.Values[i] = ec._GbfsFreeBikeStatus_feed(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsGeofenceFeatureImplementors = []string{"GbfsGeofenceFeature"}

func (ec *executionContext) _GbfsGeofenceFeature(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsGeofenceFeature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsGeofenceFeatureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsGeofenceFeature")
		case "type":
			out.Values[i] = ec._GbfsGeofenceFeature_type(ctx, field, obj)
		case "geometry":
			out.Values[i] = ec._GbfsGeofenceFeature_geometry(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsGeofencePropertyImplementors = []string{"GbfsGeofenceProperty"}

func (ec *executionContext) _GbfsGeofenceProperty(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsGeofenceProperty) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsGeofencePropertyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsGeofenceProperty")
		case "name":
			out.Values[i] = ec._GbfsGeofenceProperty_name(ctx, field, obj)
		case "start":
			out.Values[i] = ec._GbfsGeofenceProperty_start(ctx, field, obj)
		case "end":
			out.Values[i] = ec._GbfsGeofenceProperty_end(ctx, field, obj)
		case "rules":
			out.Values[i] = ec._GbfsGeofenceProperty_rules(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsGeofenceRuleImplementors = []string{"GbfsGeofenceRule"}

func (ec *executionContext) _GbfsGeofenceRule(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsGeofenceRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsGeofenceRuleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsGeofenceRule")
		case "ride_allowed":
			out.Values[i] = ec._GbfsGeofenceRule_ride_allowed(ctx, field, obj)
		case "ride_through_allowed":
			out.Values[i] = ec._GbfsGeofenceRule_ride_through_allowed(ctx, field, obj)
		case "maximum_speed_kph":
			out.Values[i] = ec._GbfsGeofenceRule_maximum_speed_kph(ctx, field, obj)
		case "station_parking":
			out.Values[i] = ec._GbfsGeofenceRule_station_parking(ctx, field, obj)
		case "vehicle_type":
			out.Values[i] = ec._GbfsGeofenceRule_vehicle_type(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsGeofenceZoneImplementors = []string{"GbfsGeofenceZone"}

func (ec *executionContext) _GbfsGeofenceZone(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsGeofenceZone) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsGeofenceZoneImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsGeofenceZone")
		case "type":
			out.Values[i] = ec._GbfsGeofenceZone_type(ctx, field, obj)
		case "features":
			out.Values[i] = ec._GbfsGeofenceZone_features(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsPlanPriceImplementors = []string{"GbfsPlanPrice"}

func (ec *executionContext) _GbfsPlanPrice(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsPlanPrice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsPlanPriceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsPlanPrice")
		case "start":
			out.Values[i] = ec._GbfsPlanPrice_start(ctx, field, obj)
		case "rate":
			out.Values[i] = ec._GbfsPlanPrice_rate(ctx, field, obj)
		case "interval":
			out.Values[i] = ec._GbfsPlanPrice_interval(ctx, field, obj)
		case "end":
			out.Values[i] = ec._GbfsPlanPrice_end(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsRentalAppImplementors = []string{"GbfsRentalApp"}

func (ec *executionContext) _GbfsRentalApp(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsRentalApp) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsRentalAppImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsRentalApp")
		case "store_uri":
			out.Values[i] = ec._GbfsRentalApp_store_uri(ctx, field, obj)
		case "discovery_uri":
			out.Values[i] = ec._GbfsRentalApp_discovery_uri(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsRentalAppsImplementors = []string{"GbfsRentalApps"}

func (ec *executionContext) _GbfsRentalApps(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsRentalApps) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsRentalAppsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsRentalApps")
		case "ios":
			out.Values[i] = ec._GbfsRentalApps_ios(ctx, field, obj)
		case "android":
			out.Values[i] = ec._GbfsRentalApps_android(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsRentalUrisImplementors = []string{"GbfsRentalUris"}

func (ec *executionContext) _GbfsRentalUris(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsRentalUris) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsRentalUrisImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsRentalUris")
		case "android":
			out.Values[i] = ec._GbfsRentalUris_android(ctx, field, obj)
		case "ios":
			out.Values[i] = ec._GbfsRentalUris_ios(ctx, field, obj)
		case "web":
			out.Values[i] = ec._GbfsRentalUris_web(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsStationInformationImplementors = []string{"GbfsStationInformation"}

func (ec *executionContext) _GbfsStationInformation(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsStationInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsStationInformationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsStationInformation")
		case "station_id":
			out.Values[i] = ec._GbfsStationInformation_station_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._GbfsStationInformation_name(ctx, field, obj)
		case "short_name":
			out.Values[i] = ec._GbfsStationInformation_short_name(ctx, field, obj)
		case "lat":
			out.Values[i] = ec._GbfsStationInformation_lat(ctx, field, obj)
		case "lon":
			out.Values[i] = ec._GbfsStationInformation_lon(ctx, field, obj)
		case "address":
			out.Values[i] = ec._GbfsStationInformation_address(ctx, field, obj)
		case "cross_street":
			out.Values[i] = ec._GbfsStationInformation_cross_street(ctx, field, obj)
		case "post_code":
			out.Values[i] = ec._GbfsStationInformation_post_code(ctx, field, obj)
		case "rental_methods":
			out.Values[i] = ec._GbfsStationInformation_rental_methods(ctx, field, obj)
		case "is_virtual_station":
			out.Values[i] = ec._GbfsStationInformation_is_virtual_station(ctx, field, obj)
		case "station_area":
			out.Values[i] = ec._GbfsStationInformation_station_area(ctx, field, obj)
		case "parking_type":
			out.Values[i] = ec._GbfsStationInformation_parking_type(ctx, field, obj)
		case "parking_hoop":
			out.Values[i] = ec._GbfsStationInformation_parking_hoop(ctx, field, obj)
		case "contact_phone":
			out.Values[i] = ec._GbfsStationInformation_contact_phone(ctx, field, obj)
		case "capacity":
			out.Values[i] = ec._GbfsStationInformation_capacity(ctx, field, obj)
		case "is_valet_station":
			out.Values[i] = ec._GbfsStationInformation_is_valet_station(ctx, field, obj)
		case "is_charging_station":
			out.Values[i] = ec._GbfsStationInformation_is_charging_station(ctx, field, obj)
		case "feed":
			out.Values[i] = ec._GbfsStationInformation_feed(ctx, field, obj)
		case "region":
			out.Values[i] = ec._GbfsStationInformation_region(ctx, field, obj)
		case "status":
			out.Values[i] = ec._GbfsStationInformation_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsStationStatusImplementors = []string{"GbfsStationStatus"}

func (ec *executionContext) _GbfsStationStatus(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsStationStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsStationStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsStationStatus")
		case "station_id":
			out.Values[i] = ec._GbfsStationStatus_station_id(ctx, field, obj)
		case "num_bikes_available":
			out.Values[i] = ec._GbfsStationStatus_num_bikes_available(ctx, field, obj)
		case "num_bikes_disabled":
			out.Values[i] = ec._GbfsStationStatus_num_bikes_disabled(ctx, field, obj)
		case "num_docks_available":
			out.Values[i] = ec._GbfsStationStatus_num_docks_available(ctx, field, obj)
		case "num_docks_disabled":
			out.Values[i] = ec._GbfsStationStatus_num_docks_disabled(ctx, field, obj)
		case "is_returning":
			out.Values[i] = ec._GbfsStationStatus_is_returning(ctx, field, obj)
		case "is_renting":
			out.Values[i] = ec._GbfsStationStatus_is_renting(ctx, field, obj)
		case "is_installed":
			out.Values[i] = ec._GbfsStationStatus_is_installed(ctx, field, obj)
		case "last_reported":
			out.Values[i] = ec._GbfsStationStatus_last_reported(ctx, field, obj)
		case "vehicle_types_available":
			out.Values[i] = ec._GbfsStationStatus_vehicle_types_available(ctx, field, obj)
		case "vehicle_docks_available":
			out.Values[i] = ec._GbfsStationStatus_vehicle_docks_available(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsSystemAlertImplementors = []string{"GbfsSystemAlert"}

func (ec *executionContext) _GbfsSystemAlert(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemAlert) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemAlertImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemAlert")
		case "alert_id":
			out.Values[i] = ec._GbfsSystemAlert_alert_id(ctx, field, obj)
		case "type":
			out.Values[i] = ec._GbfsSystemAlert_type(ctx, field, obj)
		case "url":
			out.Values[i] = ec._GbfsSystemAlert_url(ctx, field, obj)
		case "summary":
			out.Values[i] = ec._GbfsSystemAlert_summary(ctx, field, obj)
		case "description":
			out.Values[i] = ec._GbfsSystemAlert_description(ctx, field, obj)
		case "last_updated":
			out.Values[i] = ec._GbfsSystemAlert_last_updated(ctx, field, obj)
		case "times":
			out.Values[i] = ec._GbfsSystemAlert_times(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsSystemCalendarImplementors = []string{"GbfsSystemCalendar"}

func (ec *executionContext) _GbfsSystemCalendar(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemCalendar) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemCalendarImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemCalendar")
		case "start_month":
			out.Values[i] = ec._GbfsSystemCalendar_start_month(ctx, field, obj)
		case "start_day":
			out.Values[i] = ec._GbfsSystemCalendar_start_day(ctx, field, obj)
		case "start_year":
			out.Values[i] = ec._GbfsSystemCalendar_start_year(ctx, field, obj)
		case "end_month":
			out.Values[i] = ec._GbfsSystemCalendar_end_month(ctx, field, obj)
		case "end_day":
			out.Values[i] = ec._GbfsSystemCalendar_end_day(ctx, field, obj)
		case "end_year":
			out.Values[i] = ec._GbfsSystemCalendar_end_year(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsSystemHourImplementors = []string{"GbfsSystemHour"}

func (ec *executionContext) _GbfsSystemHour(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemHour) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemHourImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemHour")
		case "user_types":
			out.Values[i] = ec._GbfsSystemHour_user_types(ctx, field, obj)
		case "days":
			out.Values[i] = ec._GbfsSystemHour_days(ctx, field, obj)
		case "start_time":
			out.Values[i] = ec._GbfsSystemHour_start_time(ctx, field, obj)
		case "end_time":
			out.Values[i] = ec._GbfsSystemHour_end_time(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsSystemInformationImplementors = []string{"GbfsSystemInformation"}

func (ec *executionContext) _GbfsSystemInformation(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemInformationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemInformation")
		case "system_id":
			out.Values[i] = ec._GbfsSystemInformation_system_id(ctx, field, obj)
		case "language":
			out.Values[i] = ec._GbfsSystemInformation_language(ctx, field, obj)
		case "name":
			out.Values[i] = ec._GbfsSystemInformation_name(ctx, field, obj)
		case "short_name":
			out.Values[i] = ec._GbfsSystemInformation_short_name(ctx, field, obj)
		case "operator":
			out.Values[i] = ec._GbfsSystemInformation_operator(ctx, field, obj)
		case "url":
			out.Values[i] = ec._GbfsSystemInformation_url(ctx, field, obj)
		case "purchase_url":
			out.Values[i] = ec._GbfsSystemInformation_purchase_url(ctx, field, obj)
		case "start_date":
			out.Values[i] = ec._GbfsSystemInformation_start_date(ctx, field, obj)
		case "phone_number":
			out.Values[i] = ec._GbfsSystemInformation_phone_number(ctx, field, obj)
		case "email":
			out.Values[i] = ec._GbfsSystemInformation_email(ctx, field, obj)
		case "feed_contact_email":
			out.Values[i] = ec._GbfsSystemInformation_feed_contact_email(ctx, field, obj)
		case "timezone":
			out.Values[i] = ec._GbfsSystemInformation_timezone(ctx, field, obj)
		case "license_url":
			out.Values[i] = ec._GbfsSystemInformation_license_url(ctx, field, obj)
		case "terms_url":
			out.Values[i] = ec._GbfsSystemInformation_terms_url(ctx, field, obj)
		case "terms_last_updated":
			out.Values[i] = ec._GbfsSystemInformation_terms_last_updated(ctx, field, obj)
		case "privacy_url":
			out.Values[i] = ec._GbfsSystemInformation_privacy_url(ctx, field, obj)
		case "privacy_last_updated":
			out.Values[i] = ec._GbfsSystemInformation_privacy_last_updated(ctx, field, obj)
		case "brand_assets":
			out.Values[i] = ec._GbfsSystemInformation_brand_assets(ctx, field, obj)
		case "rental_apps":
			out.Values[i] = ec._GbfsSystemInformation_rental_apps(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsSystemPricingPlanImplementors = []string{"GbfsSystemPricingPlan"}

func (ec *executionContext) _GbfsSystemPricingPlan(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemPricingPlan) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemPricingPlanImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemPricingPlan")
		case "plan_id":
			out.Values[i] = ec._GbfsSystemPricingPlan_plan_id(ctx, field, obj)
		case "url":
			out.Values[i] = ec._GbfsSystemPricingPlan_url(ctx, field, obj)
		case "name":
			out.Values[i] = ec._GbfsSystemPricingPlan_name(ctx, field, obj)
		case "currency":
			out.Values[i] = ec._GbfsSystemPricingPlan_currency(ctx, field, obj)
		case "price":
			out.Values[i] = ec._GbfsSystemPricingPlan_price(ctx, field, obj)
		case "is_taxable":
			out.Values[i] = ec._GbfsSystemPricingPlan_is_taxable(ctx, field, obj)
		case "description":
			out.Values[i] = ec._GbfsSystemPricingPlan_description(ctx, field, obj)
		case "surge_pricing":
			out.Values[i] = ec._GbfsSystemPricingPlan_surge_pricing(ctx, field, obj)
		case "per_km_pricing":
			out.Values[i] = ec._GbfsSystemPricingPlan_per_km_pricing(ctx, field, obj)
		case "per_min_pricing":
			out.Values[i] = ec._GbfsSystemPricingPlan_per_min_pricing(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsSystemRegionImplementors = []string{"GbfsSystemRegion"}

func (ec *executionContext) _GbfsSystemRegion(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemRegion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemRegionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemRegion")
		case "region_id":
			out.Values[i] = ec._GbfsSystemRegion_region_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._GbfsSystemRegion_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsSystemVersionImplementors = []string{"GbfsSystemVersion"}

func (ec *executionContext) _GbfsSystemVersion(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemVersion")
		case "version":
			out.Values[i] = ec._GbfsSystemVersion_version(ctx, field, obj)
		case "url":
			out.Values[i] = ec._GbfsSystemVersion_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsVehicleAssetsImplementors = []string{"GbfsVehicleAssets"}

func (ec *executionContext) _GbfsVehicleAssets(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsVehicleAssets) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsVehicleAssetsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsVehicleAssets")
		case "icon_url":
			out.Values[i] = ec._GbfsVehicleAssets_icon_url(ctx, field, obj)
		case "icon_url_dark":
			out.Values[i] = ec._GbfsVehicleAssets_icon_url_dark(ctx, field, obj)
		case "icon_last_modified":
			out.Values[i] = ec._GbfsVehicleAssets_icon_last_modified(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsVehicleDockAvailableImplementors = []string{"GbfsVehicleDockAvailable"}

func (ec *executionContext) _GbfsVehicleDockAvailable(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsVehicleDockAvailable) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsVehicleDockAvailableImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsVehicleDockAvailable")
		case "count":
			out.Values[i] = ec._GbfsVehicleDockAvailable_count(ctx, field, obj)
		case "vehicle_types":
			out.Values[i] = ec._GbfsVehicleDockAvailable_vehicle_types(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsVehicleTypeImplementors = []string{"GbfsVehicleType"}

func (ec *executionContext) _GbfsVehicleType(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsVehicleType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsVehicleTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsVehicleType")
		case "vehicle_type_id":
			out.Values[i] = ec._GbfsVehicleType_vehicle_type_id(ctx, field, obj)
		case "form_factor":
			out.Values[i] = ec._GbfsVehicleType_form_factor(ctx, field, obj)
		case "rider_capacity":
			out.Values[i] = ec._GbfsVehicleType_rider_capacity(ctx, field, obj)
		case "cargo_volume_capacity":
			out.Values[i] = ec._GbfsVehicleType_cargo_volume_capacity(ctx, field, obj)
		case "cargo_load_capacity":
			out.Values[i] = ec._GbfsVehicleType_cargo_load_capacity(ctx, field, obj)
		case "propulsion_type":
			out.Values[i] = ec._GbfsVehicleType_propulsion_type(ctx, field, obj)
		case "eco_label":
			out.Values[i] = ec._GbfsVehicleType_eco_label(ctx, field, obj)
		case "country_code":
			out.Values[i] = ec._GbfsVehicleType_country_code(ctx, field, obj)
		case "eco_sticker":
			out.Values[i] = ec._GbfsVehicleType_eco_sticker(ctx, field, obj)
		case "max_range_meters":
			out.Values[i] = ec._GbfsVehicleType_max_range_meters(ctx, field, obj)
		case "name":
			out.Values[i] = ec._GbfsVehicleType_name(ctx, field, obj)
		case "vehicle_accessories":
			out.Values[i] = ec._GbfsVehicleType_vehicle_accessories(ctx, field, obj)
		case "gco_2_km":
			out.Values[i] = ec._GbfsVehicleType_gco_2_km(ctx, field, obj)
		case "vehicle_image":
			out.Values[i] = ec._GbfsVehicleType_vehicle_image(ctx, field, obj)
		case "make":
			out.Values[i] = ec._GbfsVehicleType_make(ctx, field, obj)
		case "model":
			out.Values[i] = ec._GbfsVehicleType_model(ctx, field, obj)
		case "color":
			out.Values[i] = ec._GbfsVehicleType_color(ctx, field, obj)
		case "wheel_count":
			out.Values[i] = ec._GbfsVehicleType_wheel_count(ctx, field, obj)
		case "max_permitted_speed":
			out.Values[i] = ec._GbfsVehicleType_max_permitted_speed(ctx, field, obj)
		case "rated_power":
			out.Values[i] = ec._GbfsVehicleType_rated_power(ctx, field, obj)
		case "default_reserve_time":
			out.Values[i] = ec._GbfsVehicleType_default_reserve_time(ctx, field, obj)
		case "return_constraint":
			out.Values[i] = ec._GbfsVehicleType_return_constraint(ctx, field, obj)
		case "default_pricing_plan":
			out.Values[i] = ec._GbfsVehicleType_default_pricing_plan(ctx, field, obj)
		case "pricing_plans":
			out.Values[i] = ec._GbfsVehicleType_pricing_plans(ctx, field, obj)
		case "rental_uris":
			out.Values[i] = ec._GbfsVehicleType_rental_uris(ctx, field, obj)
		case "vehicle_assets":
			out.Values[i] = ec._GbfsVehicleType_vehicle_assets(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gbfsVehicleTypeAvailableImplementors = []string{"GbfsVehicleTypeAvailable"}

func (ec *executionContext) _GbfsVehicleTypeAvailable(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsVehicleTypeAvailable) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsVehicleTypeAvailableImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsVehicleTypeAvailable")
		case "num_bikes_disabled":
			out.Values[i] = ec._GbfsVehicleTypeAvailable_num_bikes_disabled(ctx, field, obj)
		case "num_docks_available":
			out.Values[i] = ec._GbfsVehicleTypeAvailable_num_docks_available(ctx, field, obj)
		case "count":
			out.Values[i] = ec._GbfsVehicleTypeAvailable_count(ctx, field, obj)
		case "vehicle_type":
			out.Values[i] = ec._GbfsVehicleTypeAvailable_vehicle_type(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itineraryImplementors = []string{"Itinerary"}

func (ec *executionContext) _Itinerary(ctx context.Context, sel ast.SelectionSet, obj *model.Itinerary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itineraryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Itinerary")
		case "duration":
			out.Values[i] = ec._Itinerary_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "distance":
			out.Values[i] = ec._Itinerary_distance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "start_time":
			out.Values[i] = ec._Itinerary_start_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "end_time":
			out.Values[i] = ec._Itinerary_end_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "from":
			out.Values[i] = ec._Itinerary_from(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "to":
			out.Values[i] = ec._Itinerary_to(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "legs":
			out.Values[i] = ec._Itinerary_legs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var legImplementors = []string{"Leg"}

func (ec *executionContext) _Leg(ctx context.Context, sel ast.SelectionSet, obj *model.Leg) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, legImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Leg")
		case "duration":
			out.Values[i] = ec._Leg_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "distance":
			out.Values[i] = ec._Leg_distance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "start_time":
			out.Values[i] = ec._Leg_start_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "end_time":
			out.Values[i] = ec._Leg_end_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "from":
			out.Values[i] = ec._Leg_from(ctx, field, obj)
		case "to":
			out.Values[i] = ec._Leg_to(ctx, field, obj)
		case "mode":
			out.Values[i] = ec._Leg_mode(ctx, field, obj)
		case "steps":
			out.Values[i] = ec._Leg_steps(ctx, field, obj)
		case "stops":
			out.Values[i] = ec._Leg_stops(ctx, field, obj)
		case "geometry":
			out.Values[i] = ec._Leg_geometry(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "trip":
			out.Values[i] = ec._Leg_trip(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var legRouteImplementors = []string{"LegRoute"}

func (ec *executionContext) _LegRoute(ctx context.Context, sel ast.SelectionSet, obj *model.LegRoute) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, legRouteImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LegRoute")
		case "route_id":
			out.Values[i] = ec._LegRoute_route_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "route_short_name":
			out.Values[i] = ec._LegRoute_route_short_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "route_long_name":
			out.Values[i] = ec._LegRoute_route_long_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "route_onestop_id":
			out.Values[i] = ec._LegRoute_route_onestop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "route_type":
			out.Values[i] = ec._LegRoute_route_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "route_color":
			out.Values[i] = ec._LegRoute_route_color(ctx, field, obj)
		case "route_text_color":
			out.Values[i] = ec._LegRoute_route_text_color(ctx, field, obj)
		case "agency":
			out.Values[i] = ec._LegRoute_agency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var legRouteAgencyImplementors = []string{"LegRouteAgency"}

func (ec *executionContext) _LegRouteAgency(ctx context.Context, sel ast.SelectionSet, obj *model.LegRouteAgency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, legRouteAgencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LegRouteAgency")
		case "agency_id":
			out.Values[i] = ec._LegRouteAgency_agency_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "agency_name":
			out.Values[i] = ec._LegRouteAgency_agency_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "agency_onestop_id":
			out.Values[i] = ec._LegRouteAgency_agency_onestop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var legTripImplementors = []string{"LegTrip"}

func (ec *executionContext) _LegTrip(ctx context.Context, sel ast.SelectionSet, obj *model.LegTrip) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, legTripImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LegTrip")
		case "trip_id":
			out.Values[i] = ec._LegTrip_trip_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "trip_short_name":
			out.Values[i] = ec._LegTrip_trip_short_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "headsign":
			out.Values[i] = ec._LegTrip_headsign(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "feed_id":
			out.Values[i] = ec._LegTrip_feed_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "feed_version_sha1":
			out.Values[i] = ec._LegTrip_feed_version_sha1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "route":
			out.Values[i] = ec._LegTrip_route(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var levelImplementors = []string{"Level"}

func (ec *executionContext) _Level(ctx context.Context, sel ast.SelectionSet, obj *model.Level) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, levelImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Level")
		case "id":
			out.Values[i] = ec._Level_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "level_id":
			out.Values[i] = ec._Level_level_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "level_index":
			out.Values[i] = ec._Level_level_index(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "level_name":
			out.Values[i] = ec._Level_level_name(ctx, field, obj)
		case "geometry":
			out.Values[i] = ec._Level_geometry(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stops":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Level_stops(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var locationImplementors = []string{"Location"}

func (ec *executionContext) _Location(ctx context.Context, sel ast.SelectionSet, obj *model.Location) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Location")
		case "id":
			out.Values[i] = ec._Location_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "location_id":
			out.Values[i] = ec._Location_location_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stop_name":
			out.Values[i] = ec._Location_stop_name(ctx, field, obj)
		case "stop_desc":
			out.Values[i] = ec._Location_stop_desc(ctx, field, obj)
		case "zone_id":
			out.Values[i] = ec._Location_zone_id(ctx, field, obj)
		case "stop_url":
			out.Values[i] = ec._Location_stop_url(ctx, field, obj)
		case "geometry":
			out.Values[i] = ec._Location_geometry(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feed_version_sha1":
			out.Values[i] = ec._Location_feed_version_sha1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feed_onestop_id":
			out.Values[i] = ec._Location_feed_onestop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Location_feed_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stop_times":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Location_stop_times(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var locationGroupImplementors = []string{"LocationGroup"}

func (ec *executionContext) _LocationGroup(ctx context.Context, sel ast.SelectionSet, obj *model.LocationGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationGroupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LocationGroup")
		case "id":
			out.Values[i] = ec._LocationGroup_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "location_group_id":
			out.Values[i] = ec._LocationGroup_location_group_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "location_group_name":
			out.Values[i] = ec._LocationGroup_location_group_name(ctx, field, obj)
		case "feed_version_sha1":
			out.Values[i] = ec._LocationGroup_feed_version_sha1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feed_onestop_id":
			out.Values[i] = ec._LocationGroup_feed_onestop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LocationGroup_feed_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stops":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LocationGroup_stops(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stop_times":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LocationGroup_stop_times(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var locationGroupStopImplementors = []string{"LocationGroupStop"}

func (ec *executionContext) _LocationGroupStop(ctx context.Context, sel ast.SelectionSet, obj *model.LocationGroupStop) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationGroupStopImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LocationGroupStop")
		case "id":
			out.Values[i] = ec._LocationGroupStop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "location_group":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LocationGroupStop_location_group(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stop":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LocationGroupStop_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var meImplementors = []string{"Me"}

func (ec *executionContext) _Me(ctx context.Context, sel ast.SelectionSet, obj *model.Me) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, meImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Me")
		case "id":
			out.Values[i] = ec._Me_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Me_name(ctx, field, obj)
		case "email":
			out.Values[i] = ec._Me_email(ctx, field, obj)
		case "roles":
			out.Values[i] = ec._Me_roles(ctx, field, obj)
		case "external_data":
			out.Values[i] = ec._Me_external_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "validate_gtfs":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_validate_gtfs(ctx, field)
			})
		case "feed_version_update":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_feed_version_update(ctx, field)
			})
		case "feed_version_fetch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_feed_version_fetch(ctx, field)
			})
		case "feed_version_import":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_feed_version_import(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "feed_version_unimport":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_feed_version_unimport(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "feed_version_delete":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_feed_version_delete(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stop_create":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_stop_create(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stop_update":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_stop_update(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stop_delete":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_stop_delete(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "level_create":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_level_create(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "level_update":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_level_update(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "level_delete":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_level_delete(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pathway_create":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_pathway_create(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pathway_update":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_pathway_update(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pathway_delete":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_pathway_delete(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var operatorImplementors = []string{"Operator"}

func (ec *executionContext) _Operator(ctx context.Context, sel ast.SelectionSet, obj *model.Operator) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, operatorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Operator")
		case "id":
			out.Values[i] = ec._Operator_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "generated":
			out.Values[i] = ec._Operator_generated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "file":
			out.Values[i] = ec._Operator_file(ctx, field, obj)
		case "onestop_id":
			out.Values[i] = ec._Operator_onestop_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Operator_name(ctx, field, obj)
		case "short_name":
			out.Values[i] = ec._Operator_short_name(ctx, field, obj)
		case "website":
			out.Values[i] = ec._Operator_website(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._Operator_tags(ctx, field, obj)
		case "search_rank":
			out.Values[i] = ec._Operator_search_rank(ctx, field, obj)
		case "agencies":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Operator_agencies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "feeds":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Operator_feeds(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pathwayImplementors = []string{"Pathway"}

func (ec *executionContext) _Pathway(ctx context.Context, sel ast.SelectionSet, obj *model.Pathway) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pathwayImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pathway")
		case "id":
			out.Values[i] = ec._Pathway_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "pathway_id":
			out.Values[i] = ec._Pathway_pathway_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "pathway_mode":
			out.Values[i] = ec._Pathway_pathway_mode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "is_bidirectional":
			out.Values[i] = ec._Pathway_is_bidirectional(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "length":
			out.Values[i] = ec._Pathway_length(ctx, field, obj)
		case "traversal_time":
			out.Values[i] = ec._Pathway_traversal_time(ctx, field, obj)
		case "stair_count":
			out.Values[i] = ec._Pathway_stair_count(ctx, field, obj)
		case "max_slope":
			out.Values[i] = ec._Pathway_max_slope(ctx, field, obj)
		case "min_width":
			out.Values[i] = ec._Pathway_min_width(ctx, field, obj)
		case "signposted_as":
			out.Values[i] = ec._Pathway_signposted_as(ctx, field, obj)
		case "reverse_signposted_as":
			out.Values[i] = ec._Pathway_reverse_signposted_as(ctx, field, obj)
		case "from_stop":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pathway_from_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "to_stop":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pathway_to_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var placeImplementors = []string{"Place"}

func (ec *executionContext) _Place(ctx context.Context, sel ast.SelectionSet, obj *model.Place) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, placeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Place")
		case "adm0_name":
			out.Values[i] = ec._Place_adm0_name(ctx, field, obj)
		case "adm1_name":
			out.Values[i] = ec._Place_adm1_name(ctx, field, obj)
		case "city_name":
			out.Values[i] = ec._Place_city_name(ctx, field, obj)
		case "count":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Place_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "operators":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Place_operators(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "feeds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_feeds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "operators":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_operators(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "feed_versions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_feed_versions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "agencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_agencies(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "routes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_routes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "stops":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_stops(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "trips":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_trips(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "places":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_places(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "directions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_directions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "bikes":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bikes(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "docks":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_docks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "me":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "census_datasets":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_census_datasets(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "census_values":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_census_values(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rTTimeRangeImplementors = []string{"RTTimeRange"}

func (ec *executionContext) _RTTimeRange(ctx context.Context, sel ast.SelectionSet, obj *model.RTTimeRange) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rTTimeRangeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RTTimeRange")
		case "start":
			out.Values[i] = ec._RTTimeRange_start(ctx, field, obj)
		case "end":
			out.Values[i] = ec._RTTimeRange_end(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rTTranslationImplementors = []string{"RTTranslation"}

func (ec *executionContext) _RTTranslation(ctx context.Context, sel ast.SelectionSet, obj *model.RTTranslation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rTTranslationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RTTranslation")
		case "text":
			out.Values[i] = ec._RTTranslation_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "language":
			out.Values[i] = ec._RTTranslation_language(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rTTripDescriptorImplementors = []string{"RTTripDescriptor"}

func (ec *executionContext) _RTTripDescriptor(ctx context.Context, sel ast.SelectionSet, obj *model.RTTripDescriptor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rTTripDescriptorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RTTripDescriptor")
		case "trip_id":
			out.Values[i] = ec._RTTripDescriptor_trip_id(ctx, field, obj)
		case "route_id":
			out.Values[i] = ec._RTTripDescriptor_route_id(ctx, field, obj)
		case "direction_id":
			out.Values[i] = ec._RTTripDescriptor_direction_id(ctx, field, obj)
		case "start_time":
			out.Values[i] = ec._RTTripDescriptor_start_time(ctx, field, obj)
		case "start_date":
			out.Values[i] = ec._RTTripDescriptor_start_date(ctx, field, obj)
		case "schedule_relationship":
			out.Values[i] = ec._RTTripDescriptor_schedule_relationship(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rTVehicleDescriptorImplementors = []string{"RTVehicleDescriptor"}

func (ec *executionContext) _RTVehicleDescriptor(ctx context.Context, sel ast.SelectionSet, obj *model.RTVehicleDescriptor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rTVehicleDescriptorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RTVehicleDescriptor")
		case "id":
			out.Values[i] = ec._RTVehicleDescriptor_id(ctx, field, obj)
		case "label":
			out.Values[i] = ec._RTVehicleDescriptor_label(ctx, field, obj)
		case "license_plate":
			out.Values[i] = ec._RTVehicleDescriptor_license_plate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routeImplementors = []string{"Route"}

func (ec *executionContext) _Route(ctx context.Context, sel ast.SelectionSet, obj *model.Route) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Route")
		case "id":
			out.Values[i] = ec._Route_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "onestop_id":
			out.Values[i] = ec._Route_onestop_id(ctx, field, obj)
		case "route_id":
			out.Values[i] = ec._Route_route_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "route_short_name":
			out.Values[i] = ec._Route_route_short_name(ctx, field, obj)
		case "route_long_name":
			out.Values[i] = ec._Route_route_long_name(ctx, field, obj)
		case "route_type":
			out.Values[i] = ec._Route_route_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "route_color":
			out.Values[i] = ec._Route_route_color(ctx, field, obj)
		case "route_text_color":
			out.Values[i] = ec._Route_route_text_color(ctx, field, obj)
		case "route_sort_order":
			out.Values[i] = ec._Route_route_sort_order(ctx, field, obj)
		case "route_url":
			out.Values[i] = ec._Route_route_url(ctx, field, obj)
		case "route_desc":
			out.Values[i] = ec._Route_route_desc(ctx, field, obj)
		case "continuous_pickup":
			out.Values[i] = ec._Route_continuous_pickup(ctx, field, obj)
		case "continuous_drop_off":
			out.Values[i] = ec._Route_continuous_drop_off(ctx, field, obj)
		case "geometry":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_geometry(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "agency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_agency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "feed_version_sha1":
			out.Values[i] = ec._Route_feed_version_sha1(ctx, field, obj)
		case "feed_onestop_id":
			out.Values[i] = ec._Route_feed_onestop_id(ctx, field, obj)
		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_feed_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "search_rank":
			out.Values[i] = ec._Route_search_rank(ctx, field, obj)
		case "route_attribute":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_route_attribute(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trips":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_trips(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stops":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_stops(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "route_stops":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_route_stops(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "headways":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_headways(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "geometries":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_geometries(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "census_geographies":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_census_geographies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "route_stop_buffer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_route_stop_buffer(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "patterns":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_patterns(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "alerts":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_alerts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "segments":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_segments(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "segment_patterns":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_segment_patterns(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routeAttributeImplementors = []string{"RouteAttribute"}

func (ec *executionContext) _RouteAttribute(ctx context.Context, sel ast.SelectionSet, obj *model.RouteAttribute) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeAttributeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteAttribute")
		case "category":
			out.Values[i] = ec._RouteAttribute_category(ctx, field, obj)
		case "subcategory":
			out.Values[i] = ec._RouteAttribute_subcategory(ctx, field, obj)
		case "running_way":
			out.Values[i] = ec._RouteAttribute_running_way(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routeGeometryImplementors = []string{"RouteGeometry"}

func (ec *executionContext) _RouteGeometry(ctx context.Context, sel ast.SelectionSet, obj *model.RouteGeometry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeGeometryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteGeometry")
		case "generated":
			out.Values[i] = ec._RouteGeometry_generated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "geometry":
			out.Values[i] = ec._RouteGeometry_geometry(ctx, field, obj)
		case "combined_geometry":
			out.Values[i] = ec._RouteGeometry_combined_geometry(ctx, field, obj)
		case "length":
			out.Values[i] = ec._RouteGeometry_length(ctx, field, obj)
		case "max_segment_length":
			out.Values[i] = ec._RouteGeometry_max_segment_length(ctx, field, obj)
		case "first_point_max_distance":
			out.Values[i] = ec._RouteGeometry_first_point_max_distance(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routeHeadwayImplementors = []string{"RouteHeadway"}

func (ec *executionContext) _RouteHeadway(ctx context.Context, sel ast.SelectionSet, obj *model.RouteHeadway) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeHeadwayImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteHeadway")
		case "stop":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RouteHeadway_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dow_category":
			out.Values[i] = ec._RouteHeadway_dow_category(ctx, field, obj)
		case "direction_id":
			out.Values[i] = ec._RouteHeadway_direction_id(ctx, field, obj)
		case "headway_secs":
			out.Values[i] = ec._RouteHeadway_headway_secs(ctx, field, obj)
		case "service_date":
			out.Values[i] = ec._RouteHeadway_service_date(ctx, field, obj)
		case "stop_trip_count":
			out.Values[i] = ec._RouteHeadway_stop_trip_count(ctx, field, obj)
		case "departures":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RouteHeadway_departures(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routeStopImplementors = []string{"RouteStop"}

func (ec *executionContext) _RouteStop(ctx context.Context, sel ast.SelectionSet, obj *model.RouteStop) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeStopImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteStop")
		case "id":
			out.Values[i] = ec._RouteStop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stop_id":
			out.Values[i] = ec._RouteStop_stop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "route_id":
			out.Values[i] = ec._RouteStop_route_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "agency_id":
			out.Values[i] = ec._RouteStop_agency_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "route":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RouteStop_route(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stop":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RouteStop_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "agency":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RouteStop_agency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routeStopBufferImplementors = []string{"RouteStopBuffer"}

func (ec *executionContext) _RouteStopBuffer(ctx context.Context, sel ast.SelectionSet, obj *model.RouteStopBuffer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeStopBufferImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteStopBuffer")
		case "stop_buffer":
			out.Values[i] = ec._RouteStopBuffer_stop_buffer(ctx, field, obj)
		case "stop_points":
			out.Values[i] = ec._RouteStopBuffer_stop_points(ctx, field, obj)
		case "stop_convexhull":
			out.Values[i] = ec._RouteStopBuffer_stop_convexhull(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var routeStopPatternImplementors = []string{"RouteStopPattern"}

func (ec *executionContext) _RouteStopPattern(ctx context.Context, sel ast.SelectionSet, obj *model.RouteStopPattern) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeStopPatternImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteStopPattern")
		case "stop_pattern_id":
			out.Values[i] = ec._RouteStopPattern_stop_pattern_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "direction_id":
			out.Values[i] = ec._RouteStopPattern_direction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "count":
			out.Values[i] = ec._RouteStopPattern_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "trips":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RouteStopPattern_trips(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var segmentImplementors = []string{"Segment"}

func (ec *executionContext) _Segment(ctx context.Context, sel ast.SelectionSet, obj *model.Segment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, segmentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Segment")
		case "id":
			out.Values[i] = ec._Segment_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "way_id":
			out.Values[i] = ec._Segment_way_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "geometry":
			out.Values[i] = ec._Segment_geometry(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "segment_patterns":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Segment_segment_patterns(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var segmentPatternImplementors = []string{"SegmentPattern"}

func (ec *executionContext) _SegmentPattern(ctx context.Context, sel ast.SelectionSet, obj *model.SegmentPattern) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, segmentPatternImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SegmentPattern")
		case "id":
			out.Values[i] = ec._SegmentPattern_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "route":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SegmentPattern_route(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stop_pattern_id":
			out.Values[i] = ec._SegmentPattern_stop_pattern_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "segment":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SegmentPattern_segment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var shapeImplementors = []string{"Shape"}

func (ec *executionContext) _Shape(ctx context.Context, sel ast.SelectionSet, obj *model.Shape) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, shapeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Shape")
		case "id":
			out.Values[i] = ec._Shape_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "shape_id":
			out.Values[i] = ec._Shape_shape_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "geometry":
			out.Values[i] = ec._Shape_geometry(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "generated":
			out.Values[i] = ec._Shape_generated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stepImplementors = []string{"Step"}

func (ec *executionContext) _Step(ctx context.Context, sel ast.SelectionSet, obj *model.Step) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stepImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Step")
		case "duration":
			out.Values[i] = ec._Step_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "distance":
			out.Values[i] = ec._Step_distance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "start_time":
			out.Values[i] = ec._Step_start_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "end_time":
			out.Values[i] = ec._Step_end_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "to":
			out.Values[i] = ec._Step_to(ctx, field, obj)
		case "mode":
			out.Values[i] = ec._Step_mode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "instruction":
			out.Values[i] = ec._Step_instruction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "geometry_offset":
			out.Values[i] = ec._Step_geometry_offset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stopImplementors = []string{"Stop"}

func (ec *executionContext) _Stop(ctx context.Context, sel ast.SelectionSet, obj *model.Stop) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Stop")
		case "id":
			out.Values[i] = ec._Stop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "onestop_id":
			out.Values[i] = ec._Stop_onestop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "location_type":
			out.Values[i] = ec._Stop_location_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stop_code":
			out.Values[i] = ec._Stop_stop_code(ctx, field, obj)
		case "stop_desc":
			out.Values[i] = ec._Stop_stop_desc(ctx, field, obj)
		case "stop_id":
			out.Values[i] = ec._Stop_stop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stop_name":
			out.Values[i] = ec._Stop_stop_name(ctx, field, obj)
		case "stop_timezone":
			out.Values[i] = ec._Stop_stop_timezone(ctx, field, obj)
		case "stop_url":
			out.Values[i] = ec._Stop_stop_url(ctx, field, obj)
		case "wheelchair_boarding":
			out.Values[i] = ec._Stop_wheelchair_boarding(ctx, field, obj)
		case "zone_id":
			out.Values[i] = ec._Stop_zone_id(ctx, field, obj)
		case "platform_code":
			out.Values[i] = ec._Stop_platform_code(ctx, field, obj)
		case "tts_stop_name":
			out.Values[i] = ec._Stop_tts_stop_name(ctx, field, obj)
		case "geometry":
			out.Values[i] = ec._Stop_geometry(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feed_version_sha1":
			out.Values[i] = ec._Stop_feed_version_sha1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feed_onestop_id":
			out.Values[i] = ec._Stop_feed_onestop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_feed_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "location_groups":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_location_groups(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "level":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_level(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "parent":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_parent(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "external_reference":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_external_reference(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "observations":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_observations(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "children":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_children(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "route_stops":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_route_stops(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "child_levels":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_child_levels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "pathways_from_stop":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_pathways_from_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "pathways_to_stop":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_pathways_to_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stop_times":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_stop_times(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "departures":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_departures(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "arrivals":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_arrivals(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "search_rank":
			out.Values[i] = ec._Stop_search_rank(ctx, field, obj)
		case "place":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_place(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "census_geographies":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_census_geographies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "directions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_directions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "nearby_stops":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_nearby_stops(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "alerts":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_alerts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "within_features":
			out.Values[i] = ec._Stop_within_features(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stopExternalReferenceImplementors = []string{"StopExternalReference"}

func (ec *executionContext) _StopExternalReference(ctx context.Context, sel ast.SelectionSet, obj *model.StopExternalReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopExternalReferenceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StopExternalReference")
		case "id":
			out.Values[i] = ec._StopExternalReference_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "target_feed_onestop_id":
			out.Values[i] = ec._StopExternalReference_target_feed_onestop_id(ctx, field, obj)
		case "target_stop_id":
			out.Values[i] = ec._StopExternalReference_target_stop_id(ctx, field, obj)
		case "inactive":
			out.Values[i] = ec._StopExternalReference_inactive(ctx, field, obj)
		case "target_active_stop":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopExternalReference_target_active_stop(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stopObservationImplementors = []string{"StopObservation"}

func (ec *executionContext) _StopObservation(ctx context.Context, sel ast.SelectionSet, obj *model.StopObservation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopObservationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StopObservation")
		case "schedule_relationship":
			out.Values[i] = ec._StopObservation_schedule_relationship(ctx, field, obj)
		case "trip_start_date":
			out.Values[i] = ec._StopObservation_trip_start_date(ctx, field, obj)
		case "trip_start_time":
			out.Values[i] = ec._StopObservation_trip_start_time(ctx, field, obj)
		case "from_stop_id":
			out.Values[i] = ec._StopObservation_from_stop_id(ctx, field, obj)
		case "to_stop_id":
			out.Values[i] = ec._StopObservation_to_stop_id(ctx, field, obj)
		case "agency_id":
			out.Values[i] = ec._StopObservation_agency_id(ctx, field, obj)
		case "route_id":
			out.Values[i] = ec._StopObservation_route_id(ctx, field, obj)
		case "trip_id":
			out.Values[i] = ec._StopObservation_trip_id(ctx, field, obj)
		case "stop_sequence":
			out.Values[i] = ec._StopObservation_stop_sequence(ctx, field, obj)
		case "source":
			out.Values[i] = ec._StopObservation_source(ctx, field, obj)
		case "scheduled_arrival_time":
			out.Values[i] = ec._StopObservation_scheduled_arrival_time(ctx, field, obj)
		case "scheduled_departure_time":
			out.Values[i] = ec._StopObservation_scheduled_departure_time(ctx, field, obj)
		case "observed_arrival_time":
			out.Values[i] = ec._StopObservation_observed_arrival_time(ctx, field, obj)
		case "observed_departure_time":
			out.Values[i] = ec._StopObservation_observed_departure_time(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stopPlaceImplementors = []string{"StopPlace"}

func (ec *executionContext) _StopPlace(ctx context.Context, sel ast.SelectionSet, obj *model.StopPlace) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopPlaceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StopPlace")
		case "adm1_name":
			out.Values[i] = ec._StopPlace_adm1_name(ctx, field, obj)
		case "adm1_iso":
			out.Values[i] = ec._StopPlace_adm1_iso(ctx, field, obj)
		case "adm0_name":
			out.Values[i] = ec._StopPlace_adm0_name(ctx, field, obj)
		case "adm0_iso":
			out.Values[i] = ec._StopPlace_adm0_iso(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stopTimeImplementors = []string{"StopTime"}

func (ec *executionContext) _StopTime(ctx context.Context, sel ast.SelectionSet, obj *model.StopTime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopTimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StopTime")
		case "arrival_time":
			out.Values[i] = ec._StopTime_arrival_time(ctx, field, obj)
		case "departure_time":
			out.Values[i] = ec._StopTime_departure_time(ctx, field, obj)
		case "stop_sequence":
			out.Values[i] = ec._StopTime_stop_sequence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stop_headsign":
			out.Values[i] = ec._StopTime_stop_headsign(ctx, field, obj)
		case "pickup_type":
			out.Values[i] = ec._StopTime_pickup_type(ctx, field, obj)
		case "drop_off_type":
			out.Values[i] = ec._StopTime_drop_off_type(ctx, field, obj)
		case "timepoint":
			out.Values[i] = ec._StopTime_timepoint(ctx, field, obj)
		case "continuous_drop_off":
			out.Values[i] = ec._StopTime_continuous_drop_off(ctx, field, obj)
		case "continuous_pickup":
			out.Values[i] = ec._StopTime_continuous_pickup(ctx, field, obj)
		case "shape_dist_traveled":
			out.Values[i] = ec._StopTime_shape_dist_traveled(ctx, field, obj)
		case "interpolated":
			out.Values[i] = ec._StopTime_interpolated(ctx, field, obj)
		case "start_pickup_drop_off_window":
			out.Values[i] = ec._StopTime_start_pickup_drop_off_window(ctx, field, obj)
		case "end_pickup_drop_off_window":
			out.Values[i] = ec._StopTime_end_pickup_drop_off_window(ctx, field, obj)
		case "pickup_booking_rule":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopTime_pickup_booking_rule(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "drop_off_booking_rule":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopTime_drop_off_booking_rule(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stop":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopTime_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "trip":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopTime_trip(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "arrival":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopTime_arrival(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "departure":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopTime_departure(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "service_date":
			out.Values[i] = ec._StopTime_service_date(ctx, field, obj)
		case "date":
			out.Values[i] = ec._StopTime_date(ctx, field, obj)
		case "schedule_relationship":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopTime_schedule_relationship(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stopTimeEventImplementors = []string{"StopTimeEvent"}

func (ec *executionContext) _StopTimeEvent(ctx context.Context, sel ast.SelectionSet, obj *model.StopTimeEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopTimeEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StopTimeEvent")
		case "stop_timezone":
			out.Values[i] = ec._StopTimeEvent_stop_timezone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "estimated_utc":
			out.Values[i] = ec._StopTimeEvent_estimated_utc(ctx, field, obj)
		case "estimated_unix":
			out.Values[i] = ec._StopTimeEvent_estimated_unix(ctx, field, obj)
		case "estimated_local":
			out.Values[i] = ec._StopTimeEvent_estimated_local(ctx, field, obj)
		case "estimated_delay":
			out.Values[i] = ec._StopTimeEvent_estimated_delay(ctx, field, obj)
		case "estimated":
			out.Values[i] = ec._StopTimeEvent_estimated(ctx, field, obj)
		case "scheduled_utc":
			out.Values[i] = ec._StopTimeEvent_scheduled_utc(ctx, field, obj)
		case "scheduled_unix":
			out.Values[i] = ec._StopTimeEvent_scheduled_unix(ctx, field, obj)
		case "scheduled_local":
			out.Values[i] = ec._StopTimeEvent_scheduled_local(ctx, field, obj)
		case "scheduled":
			out.Values[i] = ec._StopTimeEvent_scheduled(ctx, field, obj)
		case "time_utc":
			out.Values[i] = ec._StopTimeEvent_time_utc(ctx, field, obj)
		case "time_unix":
			out.Values[i] = ec._StopTimeEvent_time_unix(ctx, field, obj)
		case "delay":
			out.Values[i] = ec._StopTimeEvent_delay(ctx, field, obj)
		case "uncertainty":
			out.Values[i] = ec._StopTimeEvent_uncertainty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tripImplementors = []string{"Trip"}

func (ec *executionContext) _Trip(ctx context.Context, sel ast.SelectionSet, obj *model.Trip) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tripImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Trip")
		case "id":
			out.Values[i] = ec._Trip_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "trip_id":
			out.Values[i] = ec._Trip_trip_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "trip_headsign":
			out.Values[i] = ec._Trip_trip_headsign(ctx, field, obj)
		case "trip_short_name":
			out.Values[i] = ec._Trip_trip_short_name(ctx, field, obj)
		case "direction_id":
			out.Values[i] = ec._Trip_direction_id(ctx, field, obj)
		case "block_id":
			out.Values[i] = ec._Trip_block_id(ctx, field, obj)
		case "wheelchair_accessible":
			out.Values[i] = ec._Trip_wheelchair_accessible(ctx, field, obj)
		case "bikes_allowed":
			out.Values[i] = ec._Trip_bikes_allowed(ctx, field, obj)
		case "stop_pattern_id":
			out.Values[i] = ec._Trip_stop_pattern_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "calendar":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_calendar(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "route":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_route(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "shape":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_shape(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_feed_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "stop_times":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_stop_times(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "flex_stop_times":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_flex_stop_times(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "frequencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_frequencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "alerts":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_alerts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "schedule_relationship":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_schedule_relationship(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "timestamp":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_timestamp(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var validationRealtimeResultImplementors = []string{"ValidationRealtimeResult"}

func (ec *executionContext) _ValidationRealtimeResult(ctx context.Context, sel ast.SelectionSet, obj *model.ValidationRealtimeResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validationRealtimeResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidationRealtimeResult")
		case "url":
			out.Values[i] = ec._ValidationRealtimeResult_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "json":
			out.Values[i] = ec._ValidationRealtimeResult_json(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var validationReportImplementors = []string{"ValidationReport"}

func (ec *executionContext) _ValidationReport(ctx context.Context, sel ast.SelectionSet, obj *model.ValidationReport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validationReportImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidationReport")
		case "id":
			out.Values[i] = ec._ValidationReport_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "reported_at":
			out.Values[i] = ec._ValidationReport_reported_at(ctx, field, obj)
		case "reported_at_local":
			out.Values[i] = ec._ValidationReport_reported_at_local(ctx, field, obj)
		case "reported_at_local_timezone":
			out.Values[i] = ec._ValidationReport_reported_at_local_timezone(ctx, field, obj)
		case "success":
			out.Values[i] = ec._ValidationReport_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "failure_reason":
			out.Values[i] = ec._ValidationReport_failure_reason(ctx, field, obj)
		case "includes_static":
			out.Values[i] = ec._ValidationReport_includes_static(ctx, field, obj)
		case "includes_rt":
			out.Values[i] = ec._ValidationReport_includes_rt(ctx, field, obj)
		case "validator":
			out.Values[i] = ec._ValidationReport_validator(ctx, field, obj)
		case "validator_version":
			out.Values[i] = ec._ValidationReport_validator_version(ctx, field, obj)
		case "errors":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValidationReport_errors(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "warnings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValidationReport_warnings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "details":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValidationReport_details(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var validationReportDetailsImplementors = []string{"ValidationReportDetails"}

func (ec *executionContext) _ValidationReportDetails(ctx context.Context, sel ast.SelectionSet, obj *model.ValidationReportDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validationReportDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidationReportDetails")
		case "sha1":
			out.Values[i] = ec._ValidationReportDetails_sha1(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "earliest_calendar_date":
			out.Values[i] = ec._ValidationReportDetails_earliest_calendar_date(ctx, field, obj)
		case "latest_calendar_date":
			out.Values[i] = ec._ValidationReportDetails_latest_calendar_date(ctx, field, obj)
		case "files":
			out.Values[i] = ec._ValidationReportDetails_files(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "service_levels":
			out.Values[i] = ec._ValidationReportDetails_service_levels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "agencies":
			out.Values[i] = ec._ValidationReportDetails_agencies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "routes":
			out.Values[i] = ec._ValidationReportDetails_routes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stops":
			out.Values[i] = ec._ValidationReportDetails_stops(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "feed_infos":
			out.Values[i] = ec._ValidationReportDetails_feed_infos(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "realtime":
			out.Values[i] = ec._ValidationReportDetails_realtime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var validationReportErrorImplementors = []string{"ValidationReportError"}

func (ec *executionContext) _ValidationReportError(ctx context.Context, sel ast.SelectionSet, obj *model.ValidationReportError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validationReportErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidationReportError")
		case "filename":
			out.Values[i] = ec._ValidationReportError_filename(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error_type":
			out.Values[i] = ec._ValidationReportError_error_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error_code":
			out.Values[i] = ec._ValidationReportError_error_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "group_key":
			out.Values[i] = ec._ValidationReportError_group_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "entity_id":
			out.Values[i] = ec._ValidationReportError_entity_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "field":
			out.Values[i] = ec._ValidationReportError_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "line":
			out.Values[i] = ec._ValidationReportError_line(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._ValidationReportError_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._ValidationReportError_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "geometry":
			out.Values[i] = ec._ValidationReportError_geometry(ctx, field, obj)
		case "entity_json":
			out.Values[i] = ec._ValidationReportError_entity_json(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var validationReportErrorGroupImplementors = []string{"ValidationReportErrorGroup"}

func (ec *executionContext) _ValidationReportErrorGroup(ctx context.Context, sel ast.SelectionSet, obj *model.ValidationReportErrorGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validationReportErrorGroupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidationReportErrorGroup")
		case "filename":
			out.Values[i] = ec._ValidationReportErrorGroup_filename(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error_type":
			out.Values[i] = ec._ValidationReportErrorGroup_error_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "error_code":
			out.Values[i] = ec._ValidationReportErrorGroup_error_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "group_key":
			out.Values[i] = ec._ValidationReportErrorGroup_group_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "field":
			out.Values[i] = ec._ValidationReportErrorGroup_field(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "count":
			out.Values[i] = ec._ValidationReportErrorGroup_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "errors":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ValidationReportErrorGroup_errors(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var vehiclePositionImplementors = []string{"VehiclePosition"}

func (ec *executionContext) _VehiclePosition(ctx context.Context, sel ast.SelectionSet, obj *model.VehiclePosition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vehiclePositionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VehiclePosition")
		case "vehicle":
			out.Values[i] = ec._VehiclePosition_vehicle(ctx, field, obj)
		case "position":
			out.Values[i] = ec._VehiclePosition_position(ctx, field, obj)
		case "current_stop_sequence":
			out.Values[i] = ec._VehiclePosition_current_stop_sequence(ctx, field, obj)
		case "stop_id":
			out.Values[i] = ec._VehiclePosition_stop_id(ctx, field, obj)
		case "current_status":
			out.Values[i] = ec._VehiclePosition_current_status(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._VehiclePosition_timestamp(ctx, field, obj)
		case "congestion_level":
			out.Values[i] = ec._VehiclePosition_congestion_level(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waypointImplementors = []string{"Waypoint"}

func (ec *executionContext) _Waypoint(ctx context.Context, sel ast.SelectionSet, obj *model.Waypoint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waypointImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Waypoint")
		case "lon":
			out.Values[i] = ec._Waypoint_lon(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lat":
			out.Values[i] = ec._Waypoint_lat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Waypoint_name(ctx, field, obj)
		case "stop":
			out.Values[i] = ec._Waypoint_stop(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waypointDepartureImplementors = []string{"WaypointDeparture"}

func (ec *executionContext) _WaypointDeparture(ctx context.Context, sel ast.SelectionSet, obj *model.WaypointDeparture) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waypointDepartureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaypointDeparture")
		case "lon":
			out.Values[i] = ec._WaypointDeparture_lon(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lat":
			out.Values[i] = ec._WaypointDeparture_lat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "departure":
			out.Values[i] = ec._WaypointDeparture_departure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stop_id":
			out.Values[i] = ec._WaypointDeparture_stop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stop_name":
			out.Values[i] = ec._WaypointDeparture_stop_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stop_code":
			out.Values[i] = ec._WaypointDeparture_stop_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stop_onestop_id":
			out.Values[i] = ec._WaypointDeparture_stop_onestop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stop_index":
			out.Values[i] = ec._WaypointDeparture_stop_index(ctx, field, obj)
		case "stop_sequence":
			out.Values[i] = ec._WaypointDeparture_stop_sequence(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waypointStopImplementors = []string{"WaypointStop"}

func (ec *executionContext) _WaypointStop(ctx context.Context, sel ast.SelectionSet, obj *model.WaypointStop) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waypointStopImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaypointStop")
		case "lon":
			out.Values[i] = ec._WaypointStop_lon(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lat":
			out.Values[i] = ec._WaypointStop_lat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "departure":
			out.Values[i] = ec._WaypointStop_departure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stop_id":
			out.Values[i] = ec._WaypointStop_stop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stop_name":
			out.Values[i] = ec._WaypointStop_stop_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stop_code":
			out.Values[i] = ec._WaypointStop_stop_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stop_onestop_id":
			out.Values[i] = ec._WaypointStop_stop_onestop_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAgency2githubcominterlineiotransitlandlibservermodelAgency(ctx context.Context, sel ast.SelectionSet, v model.Agency) graphql.Marshaler {
	return ec._Agency(ctx, sel, &v)
}

func (ec *executionContext) marshalNAgency2githubcominterlineiotransitlandlibservermodelAgency(ctx context.Context, sel ast.SelectionSet, v []*model.Agency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAgency2githubcominterlineiotransitlandlibservermodelAgency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAgency2githubcominterlineiotransitlandlibservermodelAgency(ctx context.Context, sel ast.SelectionSet, v *model.Agency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Agency(ctx, sel, v)
}

func (ec *executionContext) marshalNAgencyPlace2githubcominterlineiotransitlandlibservermodelAgencyPlace(ctx context.Context, sel ast.SelectionSet, v *model.AgencyPlace) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AgencyPlace(ctx, sel, v)
}

func (ec *executionContext) marshalNAlert2githubcominterlineiotransitlandlibservermodelAlert(ctx context.Context, sel ast.SelectionSet, v *model.Alert) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Alert(ctx, sel, v)
}

func (ec *executionContext) marshalNBookingRule2githubcominterlineiotransitlandlibservermodelBookingRule(ctx context.Context, sel ast.SelectionSet, v []*model.BookingRule) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBookingRule2githubcominterlineiotransitlandlibservermodelBookingRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBookingRule2githubcominterlineiotransitlandlibservermodelBookingRule(ctx context.Context, sel ast.SelectionSet, v *model.BookingRule) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BookingRule(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCalendar2githubcominterlineiotransitlandlibservermodelCalendar(ctx context.Context, sel ast.SelectionSet, v model.Calendar) graphql.Marshaler {
	return ec._Calendar(ctx, sel, &v)
}

func (ec *executionContext) marshalNCalendar2githubcominterlineiotransitlandlibservermodelCalendar(ctx context.Context, sel ast.SelectionSet, v *model.Calendar) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Calendar(ctx, sel, v)
}

func (ec *executionContext) marshalNCensusDataset2githubcominterlineiotransitlandlibservermodelCensusDataset(ctx context.Context, sel ast.SelectionSet, v *model.CensusDataset) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CensusDataset(ctx, sel, v)
}

func (ec *executionContext) marshalNCensusField2githubcominterlineiotransitlandlibservermodelCensusField(ctx context.Context, sel ast.SelectionSet, v []*model.CensusField) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCensusField2githubcominterlineiotransitlandlibservermodelCensusField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCensusField2githubcominterlineiotransitlandlibservermodelCensusField(ctx context.Context, sel ast.SelectionSet, v *model.CensusField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CensusField(ctx, sel, v)
}

func (ec *executionContext) marshalNCensusGeography2githubcominterlineiotransitlandlibservermodelCensusGeography(ctx context.Context, sel ast.SelectionSet, v *model.CensusGeography) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CensusGeography(ctx, sel, v)
}

func (ec *executionContext) marshalNCensusLayer2githubcominterlineiotransitlandlibservermodelCensusLayer(ctx context.Context, sel ast.SelectionSet, v *model.CensusLayer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CensusLayer(ctx, sel, v)
}

func (ec *executionContext) marshalNCensusSource2githubcominterlineiotransitlandlibservermodelCensusSource(ctx context.Context, sel ast.SelectionSet, v *model.CensusSource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CensusSource(ctx, sel, v)
}

func (ec *executionContext) marshalNCensusTable2githubcominterlineiotransitlandlibservermodelCensusTable(ctx context.Context, sel ast.SelectionSet, v model.CensusTable) graphql.Marshaler {
	return ec._CensusTable(ctx, sel, &v)
}

func (ec *executionContext) marshalNCensusTable2githubcominterlineiotransitlandlibservermodelCensusTable(ctx context.Context, sel ast.SelectionSet, v *model.CensusTable) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CensusTable(ctx, sel, v)
}

func (ec *executionContext) marshalNCensusValue2githubcominterlineiotransitlandlibservermodelCensusValue(ctx context.Context, sel ast.SelectionSet, v []*model.CensusValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCensusValue2githubcominterlineiotransitlandlibservermodelCensusValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNCensusValue2githubcominterlineiotransitlandlibservermodelCensusValue(ctx context.Context, sel ast.SelectionSet, v []*model.CensusValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCensusValue2githubcominterlineiotransitlandlibservermodelCensusValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCensusValue2githubcominterlineiotransitlandlibservermodelCensusValue(ctx context.Context, sel ast.SelectionSet, v *model.CensusValue) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CensusValue(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCounts2githubcominterlineiotransitlandlibttCounts(ctx context.Context, v any) (tt.Counts, error) {
	var res tt.Counts
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCounts2githubcominterlineiotransitlandlibttCounts(ctx context.Context, sel ast.SelectionSet, v tt.Counts) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNDate2githubcominterlineiotransitlandlibttDate(ctx context.Context, v any) (tt.Date, error) {
	var res tt.Date
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2githubcominterlineiotransitlandlibttDate(ctx context.Context, sel ast.SelectionSet, v tt.Date) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDate2githubcominterlineiotransitlandlibttDate(ctx context.Context, v any) ([]*tt.Date, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*tt.Date, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDate2githubcominterlineiotransitlandlibttDate(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNDate2githubcominterlineiotransitlandlibttDate(ctx context.Context, sel ast.SelectionSet, v []*tt.Date) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNDate2githubcominterlineiotransitlandlibttDate(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNDate2githubcominterlineiotransitlandlibttDate(ctx context.Context, v any) (*tt.Date, error) {
	var res = new(tt.Date)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2githubcominterlineiotransitlandlibttDate(ctx context.Context, sel ast.SelectionSet, v *tt.Date) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNDirectionRequest2githubcominterlineiotransitlandlibservermodelDirectionRequest(ctx context.Context, v any) (model.DirectionRequest, error) {
	res, err := ec.unmarshalInputDirectionRequest(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDirections2githubcominterlineiotransitlandlibservermodelDirections(ctx context.Context, sel ast.SelectionSet, v model.Directions) graphql.Marshaler {
	return ec._Directions(ctx, sel, &v)
}

func (ec *executionContext) marshalNDirections2githubcominterlineiotransitlandlibservermodelDirections(ctx context.Context, sel ast.SelectionSet, v *model.Directions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Directions(ctx, sel, v)
}

func (ec *executionContext) marshalNDistance2githubcominterlineiotransitlandlibservermodelDistance(ctx context.Context, sel ast.SelectionSet, v *model.Distance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Distance(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistanceUnit2githubcominterlineiotransitlandlibservermodelDistanceUnit(ctx context.Context, v any) (model.DistanceUnit, error) {
	var res model.DistanceUnit
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistanceUnit2githubcominterlineiotransitlandlibservermodelDistanceUnit(ctx context.Context, sel ast.SelectionSet, v model.DistanceUnit) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDuration2githubcominterlineiotransitlandlibservermodelDuration(ctx context.Context, sel ast.SelectionSet, v *model.Duration) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Duration(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDurationUnit2githubcominterlineiotransitlandlibservermodelDurationUnit(ctx context.Context, v any) (model.DurationUnit, error) {
	var res model.DurationUnit
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDurationUnit2githubcominterlineiotransitlandlibservermodelDurationUnit(ctx context.Context, sel ast.SelectionSet, v model.DurationUnit) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEntityDeleteResult2githubcominterlineiotransitlandlibservermodelEntityDeleteResult(ctx context.Context, sel ast.SelectionSet, v model.EntityDeleteResult) graphql.Marshaler {
	return ec._EntityDeleteResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNEntityDeleteResult2githubcominterlineiotransitlandlibservermodelEntityDeleteResult(ctx context.Context, sel ast.SelectionSet, v *model.EntityDeleteResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EntityDeleteResult(ctx, sel, v)
}

func (ec *executionContext) marshalNFeed2githubcominterlineiotransitlandlibservermodelFeed(ctx context.Context, sel ast.SelectionSet, v model.Feed) graphql.Marshaler {
	return ec._Feed(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeed2githubcominterlineiotransitlandlibservermodelFeed(ctx context.Context, sel ast.SelectionSet, v []*model.Feed) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeed2githubcominterlineiotransitlandlibservermodelFeed(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeed2githubcominterlineiotransitlandlibservermodelFeed(ctx context.Context, sel ast.SelectionSet, v *model.Feed) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Feed(ctx, sel, v)
}

func (ec *executionContext) marshalNFeedFetch2githubcominterlineiotransitlandlibservermodelFeedFetch(ctx context.Context, sel ast.SelectionSet, v *model.FeedFetch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedFetch(ctx, sel, v)
}

func (ec *executionContext) marshalNFeedInfo2githubcominterlineiotransitlandlibservermodelFeedInfo(ctx context.Context, sel ast.SelectionSet, v []*model.FeedInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedInfo2githubcominterlineiotransitlandlibservermodelFeedInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeedInfo2githubcominterlineiotransitlandlibservermodelFeedInfo(ctx context.Context, sel ast.SelectionSet, v *model.FeedInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFeedSpecTypes2githubcominterlineiotransitlandlibservermodelFeedSpecTypes(ctx context.Context, v any) (model.FeedSpecTypes, error) {
	var res model.FeedSpecTypes
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeedSpecTypes2githubcominterlineiotransitlandlibservermodelFeedSpecTypes(ctx context.Context, sel ast.SelectionSet, v model.FeedSpecTypes) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx context.Context, sel ast.SelectionSet, v model.FeedVersion) graphql.Marshaler {
	return ec._FeedVersion(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx context.Context, sel ast.SelectionSet, v []*model.FeedVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedVersion(ctx, sel, v)
}

func (ec *executionContext) marshalNFeedVersionDeleteResult2githubcominterlineiotransitlandlibservermodelFeedVersionDeleteResult(ctx context.Context, sel ast.SelectionSet, v model.FeedVersionDeleteResult) graphql.Marshaler {
	return ec._FeedVersionDeleteResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeedVersionDeleteResult2githubcominterlineiotransitlandlibservermodelFeedVersionDeleteResult(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionDeleteResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedVersionDeleteResult(ctx, sel, v)
}

func (ec *executionContext) marshalNFeedVersionFileInfo2githubcominterlineiotransitlandlibservermodelFeedVersionFileInfo(ctx context.Context, sel ast.SelectionSet, v []*model.FeedVersionFileInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedVersionFileInfo2githubcominterlineiotransitlandlibservermodelFeedVersionFileInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeedVersionFileInfo2githubcominterlineiotransitlandlibservermodelFeedVersionFileInfo(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionFileInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedVersionFileInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNFeedVersionImportResult2githubcominterlineiotransitlandlibservermodelFeedVersionImportResult(ctx context.Context, sel ast.SelectionSet, v model.FeedVersionImportResult) graphql.Marshaler {
	return ec._FeedVersionImportResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeedVersionImportResult2githubcominterlineiotransitlandlibservermodelFeedVersionImportResult(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionImportResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedVersionImportResult(ctx, sel, v)
}

func (ec *executionContext) marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandlibservermodelFeedVersionServiceLevel(ctx context.Context, sel ast.SelectionSet, v []*model.FeedVersionServiceLevel) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandlibservermodelFeedVersionServiceLevel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandlibservermodelFeedVersionServiceLevel(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionServiceLevel) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedVersionServiceLevel(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFeedVersionSetInput2githubcominterlineiotransitlandlibservermodelFeedVersionSetInput(ctx context.Context, v any) (model.FeedVersionSetInput, error) {
	res, err := ec.unmarshalInputFeedVersionSetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeedVersionUnimportResult2githubcominterlineiotransitlandlibservermodelFeedVersionUnimportResult(ctx context.Context, sel ast.SelectionSet, v model.FeedVersionUnimportResult) graphql.Marshaler {
	return ec._FeedVersionUnimportResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeedVersionUnimportResult2githubcominterlineiotransitlandlibservermodelFeedVersionUnimportResult(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionUnimportResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedVersionUnimportResult(ctx, sel, v)
}

func (ec *executionContext) marshalNFlexStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx context.Context, sel ast.SelectionSet, v []*model.StopTime) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFlexStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFlexStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx context.Context, sel ast.SelectionSet, v *model.StopTime) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FlexStopTime(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNFloat2githubcominterlineiotransitlandlibttFloat(ctx context.Context, v any) (tt.Float, error) {
	var res tt.Float
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2githubcominterlineiotransitlandlibttFloat(ctx context.Context, sel ast.SelectionSet, v tt.Float) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFrequency2githubcominterlineiotransitlandlibservermodelFrequency(ctx context.Context, sel ast.SelectionSet, v []*model.Frequency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFrequency2githubcominterlineiotransitlandlibservermodelFrequency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFrequency2githubcominterlineiotransitlandlibservermodelFrequency(ctx context.Context, sel ast.SelectionSet, v *model.Frequency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Frequency(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsAlertTime2githubcominterlineiotransitlandlibservermodelGbfsAlertTime(ctx context.Context, sel ast.SelectionSet, v *model.GbfsAlertTime) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsAlertTime(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsFreeBikeStatus2githubcominterlineiotransitlandlibservermodelGbfsFreeBikeStatus(ctx context.Context, sel ast.SelectionSet, v *model.GbfsFreeBikeStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsFreeBikeStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsGeofenceFeature2githubcominterlineiotransitlandlibservermodelGbfsGeofenceFeature(ctx context.Context, sel ast.SelectionSet, v *model.GbfsGeofenceFeature) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsGeofenceFeature(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsPlanPrice2githubcominterlineiotransitlandlibservermodelGbfsPlanPrice(ctx context.Context, sel ast.SelectionSet, v *model.GbfsPlanPrice) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsPlanPrice(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsStationInformation2githubcominterlineiotransitlandlibservermodelGbfsStationInformation(ctx context.Context, sel ast.SelectionSet, v *model.GbfsStationInformation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsStationInformation(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsSystemAlert2githubcominterlineiotransitlandlibservermodelGbfsSystemAlert(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemAlert) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsSystemAlert(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsSystemCalendar2githubcominterlineiotransitlandlibservermodelGbfsSystemCalendar(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemCalendar) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsSystemCalendar(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsSystemHour2githubcominterlineiotransitlandlibservermodelGbfsSystemHour(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemHour) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsSystemHour(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsSystemPricingPlan2githubcominterlineiotransitlandlibservermodelGbfsSystemPricingPlan(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemPricingPlan) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsSystemPricingPlan(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsVehicleDockAvailable2githubcominterlineiotransitlandlibservermodelGbfsVehicleDockAvailable(ctx context.Context, sel ast.SelectionSet, v *model.GbfsVehicleDockAvailable) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsVehicleDockAvailable(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsVehicleType2githubcominterlineiotransitlandlibservermodelGbfsVehicleType(ctx context.Context, sel ast.SelectionSet, v *model.GbfsVehicleType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsVehicleType(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsVehicleTypeAvailable2githubcominterlineiotransitlandlibservermodelGbfsVehicleTypeAvailable(ctx context.Context, sel ast.SelectionSet, v *model.GbfsVehicleTypeAvailable) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsVehicleTypeAvailable(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGeometry2githubcominterlineiotransitlandlibttGeometry(ctx context.Context, v any) (tt.Geometry, error) {
	var res tt.Geometry
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGeometry2githubcominterlineiotransitlandlibttGeometry(ctx context.Context, sel ast.SelectionSet, v tt.Geometry) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInt2githubcominterlineiotransitlandlibttInt(ctx context.Context, v any) (tt.Int, error) {
	var res tt.Int
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2githubcominterlineiotransitlandlibttInt(ctx context.Context, sel ast.SelectionSet, v tt.Int) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v any) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNItinerary2githubcominterlineiotransitlandlibservermodelItinerary(ctx context.Context, sel ast.SelectionSet, v *model.Itinerary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Itinerary(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLanguage2githubcominterlineiotransitlandlibttLanguage(ctx context.Context, v any) (tt.Language, error) {
	var res tt.Language
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLanguage2githubcominterlineiotransitlandlibttLanguage(ctx context.Context, sel ast.SelectionSet, v tt.Language) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLeg2githubcominterlineiotransitlandlibservermodelLeg(ctx context.Context, sel ast.SelectionSet, v *model.Leg) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Leg(ctx, sel, v)
}

func (ec *executionContext) marshalNLegRoute2githubcominterlineiotransitlandlibservermodelLegRoute(ctx context.Context, sel ast.SelectionSet, v *model.LegRoute) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LegRoute(ctx, sel, v)
}

func (ec *executionContext) marshalNLegRouteAgency2githubcominterlineiotransitlandlibservermodelLegRouteAgency(ctx context.Context, sel ast.SelectionSet, v *model.LegRouteAgency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LegRouteAgency(ctx, sel, v)
}

func (ec *executionContext) marshalNLevel2githubcominterlineiotransitlandlibservermodelLevel(ctx context.Context, sel ast.SelectionSet, v model.Level) graphql.Marshaler {
	return ec._Level(ctx, sel, &v)
}

func (ec *executionContext) marshalNLevel2githubcominterlineiotransitlandlibservermodelLevel(ctx context.Context, sel ast.SelectionSet, v []*model.Level) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLevel2githubcominterlineiotransitlandlibservermodelLevel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLevel2githubcominterlineiotransitlandlibservermodelLevel(ctx context.Context, sel ast.SelectionSet, v *model.Level) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Level(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLevelSetInput2githubcominterlineiotransitlandlibservermodelLevelSetInput(ctx context.Context, v any) (model.LevelSetInput, error) {
	res, err := ec.unmarshalInputLevelSetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNLineString2githubcominterlineiotransitlandlibttLineString(ctx context.Context, v any) (tt.LineString, error) {
	var res tt.LineString
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLineString2githubcominterlineiotransitlandlibttLineString(ctx context.Context, sel ast.SelectionSet, v tt.LineString) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLocation2githubcominterlineiotransitlandlibservermodelLocation(ctx context.Context, sel ast.SelectionSet, v []*model.Location) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLocation2githubcominterlineiotransitlandlibservermodelLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLocation2githubcominterlineiotransitlandlibservermodelLocation(ctx context.Context, sel ast.SelectionSet, v *model.Location) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Location(ctx, sel, v)
}

func (ec *executionContext) marshalNLocationGroup2githubcominterlineiotransitlandlibservermodelLocationGroup(ctx context.Context, sel ast.SelectionSet, v model.LocationGroup) graphql.Marshaler {
	return ec._LocationGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalNLocationGroup2githubcominterlineiotransitlandlibservermodelLocationGroup(ctx context.Context, sel ast.SelectionSet, v []*model.LocationGroup) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLocationGroup2githubcominterlineiotransitlandlibservermodelLocationGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLocationGroup2githubcominterlineiotransitlandlibservermodelLocationGroup(ctx context.Context, sel ast.SelectionSet, v *model.LocationGroup) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LocationGroup(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMap2githubcominterlineiotransitlandlibttMap(ctx context.Context, v any) (tt.Map, error) {
	var res tt.Map
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2githubcominterlineiotransitlandlibttMap(ctx context.Context, sel ast.SelectionSet, v tt.Map) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMe2githubcominterlineiotransitlandlibservermodelMe(ctx context.Context, sel ast.SelectionSet, v model.Me) graphql.Marshaler {
	return ec._Me(ctx, sel, &v)
}

func (ec *executionContext) marshalNMe2githubcominterlineiotransitlandlibservermodelMe(ctx context.Context, sel ast.SelectionSet, v *model.Me) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Me(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMultiPolygon2githubcominterlineiotransitlandlibttMultiPolygon(ctx context.Context, v any) (tt.MultiPolygon, error) {
	var res tt.MultiPolygon
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMultiPolygon2githubcominterlineiotransitlandlibttMultiPolygon(ctx context.Context, sel ast.SelectionSet, v tt.MultiPolygon) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOperator2githubcominterlineiotransitlandlibservermodelOperator(ctx context.Context, sel ast.SelectionSet, v []*model.Operator) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOperator2githubcominterlineiotransitlandlibservermodelOperator(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOperator2githubcominterlineiotransitlandlibservermodelOperator(ctx context.Context, sel ast.SelectionSet, v *model.Operator) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Operator(ctx, sel, v)
}

func (ec *executionContext) marshalNPathway2githubcominterlineiotransitlandlibservermodelPathway(ctx context.Context, sel ast.SelectionSet, v model.Pathway) graphql.Marshaler {
	return ec._Pathway(ctx, sel, &v)
}

func (ec *executionContext) marshalNPathway2githubcominterlineiotransitlandlibservermodelPathway(ctx context.Context, sel ast.SelectionSet, v []*model.Pathway) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPathway2githubcominterlineiotransitlandlibservermodelPathway(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPathway2githubcominterlineiotransitlandlibservermodelPathway(ctx context.Context, sel ast.SelectionSet, v *model.Pathway) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Pathway(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPathwaySetInput2githubcominterlineiotransitlandlibservermodelPathwaySetInput(ctx context.Context, v any) (model.PathwaySetInput, error) {
	res, err := ec.unmarshalInputPathwaySetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPlace2githubcominterlineiotransitlandlibservermodelPlace(ctx context.Context, sel ast.SelectionSet, v *model.Place) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Place(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPoint2githubcominterlineiotransitlandlibttPoint(ctx context.Context, v any) (tt.Point, error) {
	var res tt.Point
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPoint2githubcominterlineiotransitlandlibttPoint(ctx context.Context, sel ast.SelectionSet, v tt.Point) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRTTimeRange2githubcominterlineiotransitlandlibservermodelRTTimeRange(ctx context.Context, sel ast.SelectionSet, v *model.RTTimeRange) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RTTimeRange(ctx, sel, v)
}

func (ec *executionContext) marshalNRTTranslation2githubcominterlineiotransitlandlibservermodelRTTranslation(ctx context.Context, sel ast.SelectionSet, v []*model.RTTranslation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRTTranslation2githubcominterlineiotransitlandlibservermodelRTTranslation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRTTranslation2githubcominterlineiotransitlandlibservermodelRTTranslation(ctx context.Context, sel ast.SelectionSet, v *model.RTTranslation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RTTranslation(ctx, sel, v)
}

func (ec *executionContext) marshalNRoute2githubcominterlineiotransitlandlibservermodelRoute(ctx context.Context, sel ast.SelectionSet, v model.Route) graphql.Marshaler {
	return ec._Route(ctx, sel, &v)
}

func (ec *executionContext) marshalNRoute2githubcominterlineiotransitlandlibservermodelRoute(ctx context.Context, sel ast.SelectionSet, v []*model.Route) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoute2githubcominterlineiotransitlandlibservermodelRoute(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRoute2githubcominterlineiotransitlandlibservermodelRoute(ctx context.Context, sel ast.SelectionSet, v *model.Route) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Route(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteGeometry2githubcominterlineiotransitlandlibservermodelRouteGeometry(ctx context.Context, sel ast.SelectionSet, v []*model.RouteGeometry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRouteGeometry2githubcominterlineiotransitlandlibservermodelRouteGeometry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRouteGeometry2githubcominterlineiotransitlandlibservermodelRouteGeometry(ctx context.Context, sel ast.SelectionSet, v *model.RouteGeometry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteGeometry(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteHeadway2githubcominterlineiotransitlandlibservermodelRouteHeadway(ctx context.Context, sel ast.SelectionSet, v []*model.RouteHeadway) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRouteHeadway2githubcominterlineiotransitlandlibservermodelRouteHeadway(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRouteHeadway2githubcominterlineiotransitlandlibservermodelRouteHeadway(ctx context.Context, sel ast.SelectionSet, v *model.RouteHeadway) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteHeadway(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteStop2githubcominterlineiotransitlandlibservermodelRouteStop(ctx context.Context, sel ast.SelectionSet, v []*model.RouteStop) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRouteStop2githubcominterlineiotransitlandlibservermodelRouteStop(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRouteStop2githubcominterlineiotransitlandlibservermodelRouteStop(ctx context.Context, sel ast.SelectionSet, v *model.RouteStop) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteStop(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteStopBuffer2githubcominterlineiotransitlandlibservermodelRouteStopBuffer(ctx context.Context, sel ast.SelectionSet, v model.RouteStopBuffer) graphql.Marshaler {
	return ec._RouteStopBuffer(ctx, sel, &v)
}

func (ec *executionContext) marshalNRouteStopBuffer2githubcominterlineiotransitlandlibservermodelRouteStopBuffer(ctx context.Context, sel ast.SelectionSet, v *model.RouteStopBuffer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteStopBuffer(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteStopPattern2githubcominterlineiotransitlandlibservermodelRouteStopPattern(ctx context.Context, sel ast.SelectionSet, v *model.RouteStopPattern) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteStopPattern(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSeconds2githubcominterlineiotransitlandlibttSeconds(ctx context.Context, v any) (tt.Seconds, error) {
	var res tt.Seconds
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSeconds2githubcominterlineiotransitlandlibttSeconds(ctx context.Context, sel ast.SelectionSet, v tt.Seconds) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSeconds2githubcominterlineiotransitlandlibttSeconds(ctx context.Context, v any) (*tt.Seconds, error) {
	var res = new(tt.Seconds)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSeconds2githubcominterlineiotransitlandlibttSeconds(ctx context.Context, sel ast.SelectionSet, v *tt.Seconds) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNSegment2githubcominterlineiotransitlandlibservermodelSegment(ctx context.Context, sel ast.SelectionSet, v model.Segment) graphql.Marshaler {
	return ec._Segment(ctx, sel, &v)
}

func (ec *executionContext) marshalNSegment2githubcominterlineiotransitlandlibservermodelSegment(ctx context.Context, sel ast.SelectionSet, v *model.Segment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Segment(ctx, sel, v)
}

func (ec *executionContext) marshalNSegmentPattern2githubcominterlineiotransitlandlibservermodelSegmentPattern(ctx context.Context, sel ast.SelectionSet, v *model.SegmentPattern) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SegmentPattern(ctx, sel, v)
}

func (ec *executionContext) marshalNStep2githubcominterlineiotransitlandlibservermodelStep(ctx context.Context, sel ast.SelectionSet, v *model.Step) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Step(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStepMode2githubcominterlineiotransitlandlibservermodelStepMode(ctx context.Context, v any) (model.StepMode, error) {
	var res model.StepMode
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStepMode2githubcominterlineiotransitlandlibservermodelStepMode(ctx context.Context, sel ast.SelectionSet, v model.StepMode) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx context.Context, sel ast.SelectionSet, v model.Stop) graphql.Marshaler {
	return ec._Stop(ctx, sel, &v)
}

func (ec *executionContext) marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx context.Context, sel ast.SelectionSet, v []*model.Stop) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx context.Context, sel ast.SelectionSet, v *model.Stop) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Stop(ctx, sel, v)
}

func (ec *executionContext) marshalNStopObservation2githubcominterlineiotransitlandlibservermodelStopObservation(ctx context.Context, sel ast.SelectionSet, v *model.StopObservation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StopObservation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStopSetInput2githubcominterlineiotransitlandlibservermodelStopSetInput(ctx context.Context, v any) (model.StopSetInput, error) {
	res, err := ec.unmarshalInputStopSetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx context.Context, sel ast.SelectionSet, v []*model.StopTime) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx context.Context, sel ast.SelectionSet, v []*model.StopTime) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx context.Context, sel ast.SelectionSet, v *model.StopTime) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StopTime(ctx, sel, v)
}

func (ec *executionContext) marshalNStopTimeEvent2githubcominterlineiotransitlandlibservermodelStopTimeEvent(ctx context.Context, sel ast.SelectionSet, v model.StopTimeEvent) graphql.Marshaler {
	return ec._StopTimeEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNStopTimeEvent2githubcominterlineiotransitlandlibservermodelStopTimeEvent(ctx context.Context, sel ast.SelectionSet, v *model.StopTimeEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StopTimeEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2githubcominterlineiotransitlandlibttString(ctx context.Context, v any) (tt.String, error) {
	var res tt.String
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2githubcominterlineiotransitlandlibttString(ctx context.Context, sel ast.SelectionSet, v tt.String) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (*string, error) {
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTimezone2githubcominterlineiotransitlandlibttTimezone(ctx context.Context, v any) (tt.Timezone, error) {
	var res tt.Timezone
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTimezone2githubcominterlineiotransitlandlibttTimezone(ctx context.Context, sel ast.SelectionSet, v tt.Timezone) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTrip2githubcominterlineiotransitlandlibservermodelTrip(ctx context.Context, sel ast.SelectionSet, v model.Trip) graphql.Marshaler {
	return ec._Trip(ctx, sel, &v)
}

func (ec *executionContext) marshalNTrip2githubcominterlineiotransitlandlibservermodelTrip(ctx context.Context, sel ast.SelectionSet, v []*model.Trip) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTrip2githubcominterlineiotransitlandlibservermodelTrip(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTrip2githubcominterlineiotransitlandlibservermodelTrip(ctx context.Context, sel ast.SelectionSet, v *model.Trip) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Trip(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUrl2githubcominterlineiotransitlandlibttUrl(ctx context.Context, v any) (tt.Url, error) {
	var res tt.Url
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUrl2githubcominterlineiotransitlandlibttUrl(ctx context.Context, sel ast.SelectionSet, v tt.Url) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNValidationRealtimeResult2githubcominterlineiotransitlandlibservermodelValidationRealtimeResult(ctx context.Context, sel ast.SelectionSet, v *model.ValidationRealtimeResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValidationRealtimeResult(ctx, sel, v)
}

func (ec *executionContext) marshalNValidationReport2githubcominterlineiotransitlandlibservermodelValidationReport(ctx context.Context, sel ast.SelectionSet, v *model.ValidationReport) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValidationReport(ctx, sel, v)
}

func (ec *executionContext) marshalNValidationReportError2githubcominterlineiotransitlandlibservermodelValidationReportError(ctx context.Context, sel ast.SelectionSet, v []*model.ValidationReportError) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValidationReportError2githubcominterlineiotransitlandlibservermodelValidationReportError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNValidationReportError2githubcominterlineiotransitlandlibservermodelValidationReportError(ctx context.Context, sel ast.SelectionSet, v *model.ValidationReportError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValidationReportError(ctx, sel, v)
}

func (ec *executionContext) marshalNValidationReportErrorGroup2githubcominterlineiotransitlandlibservermodelValidationReportErrorGroup(ctx context.Context, sel ast.SelectionSet, v []*model.ValidationReportErrorGroup) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValidationReportErrorGroup2githubcominterlineiotransitlandlibservermodelValidationReportErrorGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNValidationReportErrorGroup2githubcominterlineiotransitlandlibservermodelValidationReportErrorGroup(ctx context.Context, sel ast.SelectionSet, v *model.ValidationReportErrorGroup) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValidationReportErrorGroup(ctx, sel, v)
}

func (ec *executionContext) marshalNWaypoint2githubcominterlineiotransitlandlibservermodelWaypoint(ctx context.Context, sel ast.SelectionSet, v *model.Waypoint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Waypoint(ctx, sel, v)
}

func (ec *executionContext) marshalNWaypointDeparture2githubcominterlineiotransitlandlibservermodelWaypointDeparture(ctx context.Context, sel ast.SelectionSet, v *model.WaypointDeparture) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WaypointDeparture(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWaypointInput2githubcominterlineiotransitlandlibservermodelWaypointInput(ctx context.Context, v any) (*model.WaypointInput, error) {
	res, err := ec.unmarshalInputWaypointInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAgency2githubcominterlineiotransitlandlibservermodelAgency(ctx context.Context, sel ast.SelectionSet, v []*model.Agency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAgency2githubcominterlineiotransitlandlibservermodelAgency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAgencyFilter2githubcominterlineiotransitlandlibservermodelAgencyFilter(ctx context.Context, v any) (*model.AgencyFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAgencyFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAgencyLocationFilter2githubcominterlineiotransitlandlibservermodelAgencyLocationFilter(ctx context.Context, v any) (*model.AgencyLocationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAgencyLocationFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAgencyPlace2githubcominterlineiotransitlandlibservermodelAgencyPlace(ctx context.Context, sel ast.SelectionSet, v []*model.AgencyPlace) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAgencyPlace2githubcominterlineiotransitlandlibservermodelAgencyPlace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAgencyPlaceFilter2githubcominterlineiotransitlandlibservermodelAgencyPlaceFilter(ctx context.Context, v any) (*model.AgencyPlaceFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAgencyPlaceFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAlert2githubcominterlineiotransitlandlibservermodelAlert(ctx context.Context, sel ast.SelectionSet, v []*model.Alert) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAlert2githubcominterlineiotransitlandlibservermodelAlert(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAny2interface(ctx context.Context, v any) (any, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAny2interface(ctx context.Context, sel ast.SelectionSet, v any) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalAny(v)
	return res
}

func (ec *executionContext) marshalOBookingRule2githubcominterlineiotransitlandlibservermodelBookingRule(ctx context.Context, sel ast.SelectionSet, v *model.BookingRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BookingRule(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBookingRuleFilter2githubcominterlineiotransitlandlibservermodelBookingRuleFilter(ctx context.Context, v any) (*model.BookingRuleFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBookingRuleFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBool2githubcominterlineiotransitlandlibttBool(ctx context.Context, v any) (tt.Bool, error) {
	var res tt.Bool
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBool2githubcominterlineiotransitlandlibttBool(ctx context.Context, sel ast.SelectionSet, v tt.Bool) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2githubcominterlineiotransitlandlibttBool(ctx context.Context, v any) (tt.Bool, error) {
	var res tt.Bool
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2githubcominterlineiotransitlandlibttBool(ctx context.Context, sel ast.SelectionSet, v tt.Bool) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOBoundingBox2githubcominterlineiotransitlandlibservermodelBoundingBox(ctx context.Context, v any) (*model.BoundingBox, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBoundingBox(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCalendar2githubcominterlineiotransitlandlibservermodelCalendar(ctx context.Context, sel ast.SelectionSet, v *model.Calendar) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Calendar(ctx, sel, v)
}

func (ec *executionContext) marshalOCensusDataset2githubcominterlineiotransitlandlibservermodelCensusDataset(ctx context.Context, sel ast.SelectionSet, v []*model.CensusDataset) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCensusDataset2githubcominterlineiotransitlandlibservermodelCensusDataset(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOCensusDatasetFilter2githubcominterlineiotransitlandlibservermodelCensusDatasetFilter(ctx context.Context, v any) (*model.CensusDatasetFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCensusDatasetFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCensusDatasetGeographyFilter2githubcominterlineiotransitlandlibservermodelCensusDatasetGeographyFilter(ctx context.Context, v any) (*model.CensusDatasetGeographyFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCensusDatasetGeographyFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCensusDatasetGeographyLocationFilter2githubcominterlineiotransitlandlibservermodelCensusDatasetGeographyLocationFilter(ctx context.Context, v any) (*model.CensusDatasetGeographyLocationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCensusDatasetGeographyLocationFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCensusGeography2githubcominterlineiotransitlandlibservermodelCensusGeography(ctx context.Context, sel ast.SelectionSet, v []*model.CensusGeography) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCensusGeography2githubcominterlineiotransitlandlibservermodelCensusGeography(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOCensusGeographyFilter2githubcominterlineiotransitlandlibservermodelCensusGeographyFilter(ctx context.Context, v any) (*model.CensusGeographyFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCensusGeographyFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCensusLayer2githubcominterlineiotransitlandlibservermodelCensusLayer(ctx context.Context, sel ast.SelectionSet, v []*model.CensusLayer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCensusLayer2githubcominterlineiotransitlandlibservermodelCensusLayer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCensusLayer2githubcominterlineiotransitlandlibservermodelCensusLayer(ctx context.Context, sel ast.SelectionSet, v *model.CensusLayer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CensusLayer(ctx, sel, v)
}

func (ec *executionContext) marshalOCensusSource2githubcominterlineiotransitlandlibservermodelCensusSource(ctx context.Context, sel ast.SelectionSet, v []*model.CensusSource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCensusSource2githubcominterlineiotransitlandlibservermodelCensusSource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCensusSource2githubcominterlineiotransitlandlibservermodelCensusSource(ctx context.Context, sel ast.SelectionSet, v *model.CensusSource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CensusSource(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCensusSourceFilter2githubcominterlineiotransitlandlibservermodelCensusSourceFilter(ctx context.Context, v any) (*model.CensusSourceFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCensusSourceFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCensusSourceGeographyFilter2githubcominterlineiotransitlandlibservermodelCensusSourceGeographyFilter(ctx context.Context, v any) (*model.CensusSourceGeographyFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCensusSourceGeographyFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCensusTable2githubcominterlineiotransitlandlibservermodelCensusTable(ctx context.Context, sel ast.SelectionSet, v []*model.CensusTable) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCensusTable2githubcominterlineiotransitlandlibservermodelCensusTable(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOCensusTableFilter2githubcominterlineiotransitlandlibservermodelCensusTableFilter(ctx context.Context, v any) (*model.CensusTableFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCensusTableFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCensusValue2githubcominterlineiotransitlandlibservermodelCensusValue(ctx context.Context, sel ast.SelectionSet, v *model.CensusValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CensusValue(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCensusValueFilter2githubcominterlineiotransitlandlibservermodelCensusValueFilter(ctx context.Context, v any) (*model.CensusValueFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCensusValueFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOColor2githubcominterlineiotransitlandlibttColor(ctx context.Context, v any) (tt.Color, error) {
	var res tt.Color
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOColor2githubcominterlineiotransitlandlibttColor(ctx context.Context, sel ast.SelectionSet, v tt.Color) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx context.Context, v any) (tt.Date, error) {
	var res tt.Date
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODate2githubcominterlineiotransitlandlibttDate(ctx context.Context, sel ast.SelectionSet, v tt.Date) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalODate2githubcominterlineiotransitlandlibttDate(ctx context.Context, v any) (*tt.Date, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Date)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODate2githubcominterlineiotransitlandlibttDate(ctx context.Context, sel ast.SelectionSet, v *tt.Date) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalODistance2githubcominterlineiotransitlandlibservermodelDistance(ctx context.Context, sel ast.SelectionSet, v *model.Distance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Distance(ctx, sel, v)
}

func (ec *executionContext) marshalODuration2githubcominterlineiotransitlandlibservermodelDuration(ctx context.Context, sel ast.SelectionSet, v *model.Duration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Duration(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEmail2githubcominterlineiotransitlandlibttEmail(ctx context.Context, v any) (tt.Email, error) {
	var res tt.Email
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEmail2githubcominterlineiotransitlandlibttEmail(ctx context.Context, sel ast.SelectionSet, v tt.Email) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOFeature2githubcominterlineiotransitlandlibservermodelFeature(ctx context.Context, v any) ([]*model.Feature, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.Feature, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFeature2githubcominterlineiotransitlandlibservermodelFeature(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFeature2githubcominterlineiotransitlandlibservermodelFeature(ctx context.Context, v any) (*model.Feature, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeature(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeed2githubcominterlineiotransitlandlibservermodelFeed(ctx context.Context, sel ast.SelectionSet, v []*model.Feed) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeed2githubcominterlineiotransitlandlibservermodelFeed(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOFeedAuthorization2githubcominterlineiotransitlandlibservermodelFeedAuthorization(ctx context.Context, sel ast.SelectionSet, v *model.FeedAuthorization) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedAuthorization(ctx, sel, v)
}

func (ec *executionContext) marshalOFeedFetch2githubcominterlineiotransitlandlibservermodelFeedFetch(ctx context.Context, sel ast.SelectionSet, v []*model.FeedFetch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedFetch2githubcominterlineiotransitlandlibservermodelFeedFetch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFeedFetchFilter2githubcominterlineiotransitlandlibservermodelFeedFetchFilter(ctx context.Context, v any) (*model.FeedFetchFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedFetchFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFeedFilter2githubcominterlineiotransitlandlibservermodelFeedFilter(ctx context.Context, v any) (*model.FeedFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeedLicense2githubcominterlineiotransitlandlibservermodelFeedLicense(ctx context.Context, sel ast.SelectionSet, v *model.FeedLicense) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedLicense(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFeedSourceUrl2githubcominterlineiotransitlandlibservermodelFeedSourceURL(ctx context.Context, v any) (*model.FeedSourceURL, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedSourceUrl(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFeedSourceUrlTypes2githubcominterlineiotransitlandlibservermodelFeedSourceURLTypes(ctx context.Context, v any) (*model.FeedSourceURLTypes, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FeedSourceURLTypes)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeedSourceUrlTypes2githubcominterlineiotransitlandlibservermodelFeedSourceURLTypes(ctx context.Context, sel ast.SelectionSet, v *model.FeedSourceURLTypes) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFeedSpecTypes2githubcominterlineiotransitlandlibservermodelFeedSpecTypes(ctx context.Context, v any) ([]model.FeedSpecTypes, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.FeedSpecTypes, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFeedSpecTypes2githubcominterlineiotransitlandlibservermodelFeedSpecTypes(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFeedSpecTypes2githubcominterlineiotransitlandlibservermodelFeedSpecTypes(ctx context.Context, sel ast.SelectionSet, v []model.FeedSpecTypes) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedSpecTypes2githubcominterlineiotransitlandlibservermodelFeedSpecTypes(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFeedSpecTypes2githubcominterlineiotransitlandlibservermodelFeedSpecTypes(ctx context.Context, v any) (*model.FeedSpecTypes, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FeedSpecTypes)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeedSpecTypes2githubcominterlineiotransitlandlibservermodelFeedSpecTypes(ctx context.Context, sel ast.SelectionSet, v *model.FeedSpecTypes) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFeedState2githubcominterlineiotransitlandlibservermodelFeedState(ctx context.Context, sel ast.SelectionSet, v *model.FeedState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedState(ctx, sel, v)
}

func (ec *executionContext) marshalOFeedUrls2githubcominterlineiotransitlandlibservermodelFeedUrls(ctx context.Context, sel ast.SelectionSet, v *model.FeedUrls) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedUrls(ctx, sel, v)
}

func (ec *executionContext) marshalOFeedVersion2githubcominterlineiotransitlandlibservermodelFeedVersion(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedVersion(ctx, sel, v)
}

func (ec *executionContext) marshalOFeedVersionFetchResult2githubcominterlineiotransitlandlibservermodelFeedVersionFetchResult(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionFetchResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedVersionFetchResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFeedVersionFilter2githubcominterlineiotransitlandlibservermodelFeedVersionFilter(ctx context.Context, v any) (*model.FeedVersionFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedVersionFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeedVersionGtfsImport2githubcominterlineiotransitlandlibservermodelFeedVersionGtfsImport(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionGtfsImport) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedVersionGtfsImport(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFeedVersionInput2githubcominterlineiotransitlandlibservermodelFeedVersionInput(ctx context.Context, v any) (*model.FeedVersionInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedVersionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFeedVersionServiceLevelFilter2githubcominterlineiotransitlandlibservermodelFeedVersionServiceLevelFilter(ctx context.Context, v any) (*model.FeedVersionServiceLevelFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedVersionServiceLevelFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeedVersionServiceWindow2githubcominterlineiotransitlandlibservermodelFeedVersionServiceWindow(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionServiceWindow) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedVersionServiceWindow(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx context.Context, v any) (tt.Float, error) {
	var res tt.Float
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2githubcominterlineiotransitlandlibttFloat(ctx context.Context, sel ast.SelectionSet, v tt.Float) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloat(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalFloat(*v)
	return res
}

func (ec *executionContext) unmarshalOFocusPoint2githubcominterlineiotransitlandlibservermodelFocusPoint(ctx context.Context, v any) (*model.FocusPoint, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFocusPoint(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGbfsAlertTime2githubcominterlineiotransitlandlibservermodelGbfsAlertTime(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsAlertTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsAlertTime2githubcominterlineiotransitlandlibservermodelGbfsAlertTime(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGbfsBikeRequest2githubcominterlineiotransitlandlibservermodelGbfsBikeRequest(ctx context.Context, v any) (*model.GbfsBikeRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGbfsBikeRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGbfsBrandAsset2githubcominterlineiotransitlandlibservermodelGbfsBrandAsset(ctx context.Context, sel ast.SelectionSet, v *model.GbfsBrandAsset) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsBrandAsset(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGbfsDockRequest2githubcominterlineiotransitlandlibservermodelGbfsDockRequest(ctx context.Context, v any) (*model.GbfsDockRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGbfsDockRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGbfsFeed2githubcominterlineiotransitlandlibservermodelGbfsFeed(ctx context.Context, sel ast.SelectionSet, v *model.GbfsFeed) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsFeed(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsFreeBikeStatus2githubcominterlineiotransitlandlibservermodelGbfsFreeBikeStatus(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsFreeBikeStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsFreeBikeStatus2githubcominterlineiotransitlandlibservermodelGbfsFreeBikeStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsGeofenceFeature2githubcominterlineiotransitlandlibservermodelGbfsGeofenceFeature(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsGeofenceFeature) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsGeofenceFeature2githubcominterlineiotransitlandlibservermodelGbfsGeofenceFeature(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsGeofenceRule2githubcominterlineiotransitlandlibservermodelGbfsGeofenceRule(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsGeofenceRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGbfsGeofenceRule2githubcominterlineiotransitlandlibservermodelGbfsGeofenceRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGbfsGeofenceRule2githubcominterlineiotransitlandlibservermodelGbfsGeofenceRule(ctx context.Context, sel ast.SelectionSet, v *model.GbfsGeofenceRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsGeofenceRule(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsPlanPrice2githubcominterlineiotransitlandlibservermodelGbfsPlanPrice(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsPlanPrice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsPlanPrice2githubcominterlineiotransitlandlibservermodelGbfsPlanPrice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsRentalApp2githubcominterlineiotransitlandlibservermodelGbfsRentalApp(ctx context.Context, sel ast.SelectionSet, v *model.GbfsRentalApp) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsRentalApp(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsRentalApps2githubcominterlineiotransitlandlibservermodelGbfsRentalApps(ctx context.Context, sel ast.SelectionSet, v *model.GbfsRentalApps) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsRentalApps(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsRentalUris2githubcominterlineiotransitlandlibservermodelGbfsRentalUris(ctx context.Context, sel ast.SelectionSet, v *model.GbfsRentalUris) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsRentalUris(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsStationInformation2githubcominterlineiotransitlandlibservermodelGbfsStationInformation(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsStationInformation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsStationInformation2githubcominterlineiotransitlandlibservermodelGbfsStationInformation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsStationInformation2githubcominterlineiotransitlandlibservermodelGbfsStationInformation(ctx context.Context, sel ast.SelectionSet, v *model.GbfsStationInformation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsStationInformation(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsStationStatus2githubcominterlineiotransitlandlibservermodelGbfsStationStatus(ctx context.Context, sel ast.SelectionSet, v *model.GbfsStationStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsStationStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsSystemAlert2githubcominterlineiotransitlandlibservermodelGbfsSystemAlert(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsSystemAlert) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsSystemAlert2githubcominterlineiotransitlandlibservermodelGbfsSystemAlert(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsSystemCalendar2githubcominterlineiotransitlandlibservermodelGbfsSystemCalendar(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsSystemCalendar) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsSystemCalendar2githubcominterlineiotransitlandlibservermodelGbfsSystemCalendar(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsSystemHour2githubcominterlineiotransitlandlibservermodelGbfsSystemHour(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsSystemHour) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsSystemHour2githubcominterlineiotransitlandlibservermodelGbfsSystemHour(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsSystemInformation2githubcominterlineiotransitlandlibservermodelGbfsSystemInformation(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemInformation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsSystemInformation(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsSystemPricingPlan2githubcominterlineiotransitlandlibservermodelGbfsSystemPricingPlan(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsSystemPricingPlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsSystemPricingPlan2githubcominterlineiotransitlandlibservermodelGbfsSystemPricingPlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsSystemPricingPlan2githubcominterlineiotransitlandlibservermodelGbfsSystemPricingPlan(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemPricingPlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsSystemPricingPlan(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsSystemRegion2githubcominterlineiotransitlandlibservermodelGbfsSystemRegion(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemRegion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsSystemRegion(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsVehicleAssets2githubcominterlineiotransitlandlibservermodelGbfsVehicleAssets(ctx context.Context, sel ast.SelectionSet, v *model.GbfsVehicleAssets) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsVehicleAssets(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsVehicleDockAvailable2githubcominterlineiotransitlandlibservermodelGbfsVehicleDockAvailable(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsVehicleDockAvailable) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsVehicleDockAvailable2githubcominterlineiotransitlandlibservermodelGbfsVehicleDockAvailable(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsVehicleType2githubcominterlineiotransitlandlibservermodelGbfsVehicleType(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsVehicleType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsVehicleType2githubcominterlineiotransitlandlibservermodelGbfsVehicleType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsVehicleType2githubcominterlineiotransitlandlibservermodelGbfsVehicleType(ctx context.Context, sel ast.SelectionSet, v *model.GbfsVehicleType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsVehicleType(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsVehicleTypeAvailable2githubcominterlineiotransitlandlibservermodelGbfsVehicleTypeAvailable(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsVehicleTypeAvailable) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsVehicleTypeAvailable2githubcominterlineiotransitlandlibservermodelGbfsVehicleTypeAvailable(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx context.Context, v any) (tt.Geometry, error) {
	var res tt.Geometry
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx context.Context, sel ast.SelectionSet, v tt.Geometry) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx context.Context, v any) (*tt.Geometry, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Geometry)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGeometry2githubcominterlineiotransitlandlibttGeometry(ctx context.Context, sel ast.SelectionSet, v *tt.Geometry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOImportStatus2githubcominterlineiotransitlandlibservermodelImportStatus(ctx context.Context, v any) (*model.ImportStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ImportStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOImportStatus2githubcominterlineiotransitlandlibservermodelImportStatus(ctx context.Context, sel ast.SelectionSet, v *model.ImportStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOInt2githubcominterlineiotransitlandlibttInt(ctx context.Context, v any) (tt.Int, error) {
	var res tt.Int
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2githubcominterlineiotransitlandlibttInt(ctx context.Context, sel ast.SelectionSet, v tt.Int) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) ([]*int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []*int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOInt2int(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOItinerary2githubcominterlineiotransitlandlibservermodelItinerary(ctx context.Context, sel ast.SelectionSet, v []*model.Itinerary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItinerary2githubcominterlineiotransitlandlibservermodelItinerary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOLanguage2githubcominterlineiotransitlandlibttLanguage(ctx context.Context, v any) (tt.Language, error) {
	var res tt.Language
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLanguage2githubcominterlineiotransitlandlibttLanguage(ctx context.Context, sel ast.SelectionSet, v tt.Language) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalOLeg2githubcominterlineiotransitlandlibservermodelLeg(ctx context.Context, sel ast.SelectionSet, v []*model.Leg) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLeg2githubcominterlineiotransitlandlibservermodelLeg(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLegTrip2githubcominterlineiotransitlandlibservermodelLegTrip(ctx context.Context, sel ast.SelectionSet, v *model.LegTrip) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LegTrip(ctx, sel, v)
}

func (ec *executionContext) marshalOLevel2githubcominterlineiotransitlandlibservermodelLevel(ctx context.Context, sel ast.SelectionSet, v *model.Level) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Level(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLevelSetInput2githubcominterlineiotransitlandlibservermodelLevelSetInput(ctx context.Context, v any) (*model.LevelSetInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLevelSetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLicenseFilter2githubcominterlineiotransitlandlibservermodelLicenseFilter(ctx context.Context, v any) (*model.LicenseFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLicenseFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLicenseValue2githubcominterlineiotransitlandlibservermodelLicenseValue(ctx context.Context, v any) (*model.LicenseValue, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.LicenseValue)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLicenseValue2githubcominterlineiotransitlandlibservermodelLicenseValue(ctx context.Context, sel ast.SelectionSet, v *model.LicenseValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLineString2githubcominterlineiotransitlandlibttLineString(ctx context.Context, v any) (*tt.LineString, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.LineString)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLineString2githubcominterlineiotransitlandlibttLineString(ctx context.Context, sel ast.SelectionSet, v *tt.LineString) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOLocation2githubcominterlineiotransitlandlibservermodelLocation(ctx context.Context, sel ast.SelectionSet, v *model.Location) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Location(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLocationFilter2githubcominterlineiotransitlandlibservermodelLocationFilter(ctx context.Context, v any) (*model.LocationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLocationFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLocationGroup2githubcominterlineiotransitlandlibservermodelLocationGroup(ctx context.Context, sel ast.SelectionSet, v *model.LocationGroup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LocationGroup(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLocationGroupFilter2githubcominterlineiotransitlandlibservermodelLocationGroupFilter(ctx context.Context, v any) (*model.LocationGroupFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLocationGroupFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMap2githubcominterlineiotransitlandlibttMap(ctx context.Context, v any) (*tt.Map, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Map)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2githubcominterlineiotransitlandlibttMap(ctx context.Context, sel ast.SelectionSet, v *tt.Map) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOMultiPolygon2githubcominterlineiotransitlandlibttMultiPolygon(ctx context.Context, v any) (*tt.MultiPolygon, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.MultiPolygon)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMultiPolygon2githubcominterlineiotransitlandlibttMultiPolygon(ctx context.Context, sel ast.SelectionSet, v *tt.MultiPolygon) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOOperator2githubcominterlineiotransitlandlibservermodelOperator(ctx context.Context, sel ast.SelectionSet, v []*model.Operator) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOperator2githubcominterlineiotransitlandlibservermodelOperator(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOOperator2githubcominterlineiotransitlandlibservermodelOperator(ctx context.Context, sel ast.SelectionSet, v *model.Operator) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Operator(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOperatorFilter2githubcominterlineiotransitlandlibservermodelOperatorFilter(ctx context.Context, v any) (*model.OperatorFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOperatorFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPlace2githubcominterlineiotransitlandlibservermodelPlace(ctx context.Context, sel ast.SelectionSet, v []*model.Place) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlace2githubcominterlineiotransitlandlibservermodelPlace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPlaceAggregationLevel2githubcominterlineiotransitlandlibservermodelPlaceAggregationLevel(ctx context.Context, v any) (*model.PlaceAggregationLevel, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.PlaceAggregationLevel)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPlaceAggregationLevel2githubcominterlineiotransitlandlibservermodelPlaceAggregationLevel(ctx context.Context, sel ast.SelectionSet, v *model.PlaceAggregationLevel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPlaceFilter2githubcominterlineiotransitlandlibservermodelPlaceFilter(ctx context.Context, v any) (*model.PlaceFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPlaceFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPoint2githubcominterlineiotransitlandlibttPoint(ctx context.Context, v any) (*tt.Point, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Point)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPoint2githubcominterlineiotransitlandlibttPoint(ctx context.Context, sel ast.SelectionSet, v *tt.Point) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPointRadius2githubcominterlineiotransitlandlibservermodelPointRadius(ctx context.Context, v any) (*model.PointRadius, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPointRadius(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx context.Context, v any) (*tt.Polygon, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Polygon)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPolygon2githubcominterlineiotransitlandlibttPolygon(ctx context.Context, sel ast.SelectionSet, v *tt.Polygon) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalORTTimeRange2githubcominterlineiotransitlandlibservermodelRTTimeRange(ctx context.Context, sel ast.SelectionSet, v []*model.RTTimeRange) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRTTimeRange2githubcominterlineiotransitlandlibservermodelRTTimeRange(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalORTTranslation2githubcominterlineiotransitlandlibservermodelRTTranslation(ctx context.Context, sel ast.SelectionSet, v []*model.RTTranslation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRTTranslation2githubcominterlineiotransitlandlibservermodelRTTranslation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalORTVehicleDescriptor2githubcominterlineiotransitlandlibservermodelRTVehicleDescriptor(ctx context.Context, sel ast.SelectionSet, v *model.RTVehicleDescriptor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RTVehicleDescriptor(ctx, sel, v)
}

func (ec *executionContext) unmarshalORelativeDate2githubcominterlineiotransitlandlibservermodelRelativeDate(ctx context.Context, v any) (*model.RelativeDate, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.RelativeDate)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORelativeDate2githubcominterlineiotransitlandlibservermodelRelativeDate(ctx context.Context, sel ast.SelectionSet, v *model.RelativeDate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalORouteAttribute2githubcominterlineiotransitlandlibservermodelRouteAttribute(ctx context.Context, sel ast.SelectionSet, v *model.RouteAttribute) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RouteAttribute(ctx, sel, v)
}

func (ec *executionContext) unmarshalORouteFilter2githubcominterlineiotransitlandlibservermodelRouteFilter(ctx context.Context, v any) (*model.RouteFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRouteFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORouteLocationFilter2githubcominterlineiotransitlandlibservermodelRouteLocationFilter(ctx context.Context, v any) (*model.RouteLocationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRouteLocationFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORouteStopPattern2githubcominterlineiotransitlandlibservermodelRouteStopPattern(ctx context.Context, sel ast.SelectionSet, v []*model.RouteStopPattern) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRouteStopPattern2githubcominterlineiotransitlandlibservermodelRouteStopPattern(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOScheduleRelationship2githubcominterlineiotransitlandlibservermodelScheduleRelationship(ctx context.Context, v any) (*model.ScheduleRelationship, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ScheduleRelationship)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOScheduleRelationship2githubcominterlineiotransitlandlibservermodelScheduleRelationship(ctx context.Context, sel ast.SelectionSet, v *model.ScheduleRelationship) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx context.Context, v any) (tt.Seconds, error) {
	var res tt.Seconds
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx context.Context, sel ast.SelectionSet, v tt.Seconds) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx context.Context, v any) ([]*tt.Seconds, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*tt.Seconds, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx context.Context, sel ast.SelectionSet, v []*tt.Seconds) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNSeconds2githubcominterlineiotransitlandlibttSeconds(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx context.Context, v any) (*tt.Seconds, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Seconds)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSeconds2githubcominterlineiotransitlandlibttSeconds(ctx context.Context, sel ast.SelectionSet, v *tt.Seconds) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOSegment2githubcominterlineiotransitlandlibservermodelSegment(ctx context.Context, sel ast.SelectionSet, v []*model.Segment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSegment2githubcominterlineiotransitlandlibservermodelSegment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSegmentFilter2githubcominterlineiotransitlandlibservermodelSegmentFilter(ctx context.Context, v any) (*model.SegmentFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSegmentFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSegmentPattern2githubcominterlineiotransitlandlibservermodelSegmentPattern(ctx context.Context, sel ast.SelectionSet, v []*model.SegmentPattern) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSegmentPattern2githubcominterlineiotransitlandlibservermodelSegmentPattern(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSegmentPatternFilter2githubcominterlineiotransitlandlibservermodelSegmentPatternFilter(ctx context.Context, v any) (*model.SegmentPatternFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSegmentPatternFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOServiceCoversFilter2githubcominterlineiotransitlandlibservermodelServiceCoversFilter(ctx context.Context, v any) (*model.ServiceCoversFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputServiceCoversFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOShape2githubcominterlineiotransitlandlibservermodelShape(ctx context.Context, sel ast.SelectionSet, v *model.Shape) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Shape(ctx, sel, v)
}

func (ec *executionContext) marshalOStep2githubcominterlineiotransitlandlibservermodelStep(ctx context.Context, sel ast.SelectionSet, v []*model.Step) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStep2githubcominterlineiotransitlandlibservermodelStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOStepMode2githubcominterlineiotransitlandlibservermodelStepMode(ctx context.Context, v any) (*model.StepMode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.StepMode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStepMode2githubcominterlineiotransitlandlibservermodelStepMode(ctx context.Context, sel ast.SelectionSet, v *model.StepMode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOStop2githubcominterlineiotransitlandlibservermodelStop(ctx context.Context, sel ast.SelectionSet, v []*model.Stop) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStop2githubcominterlineiotransitlandlibservermodelStop(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOStop2githubcominterlineiotransitlandlibservermodelStop(ctx context.Context, sel ast.SelectionSet, v *model.Stop) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Stop(ctx, sel, v)
}

func (ec *executionContext) unmarshalOStopBuffer2githubcominterlineiotransitlandlibservermodelStopBuffer(ctx context.Context, v any) (*model.StopBuffer, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStopBuffer(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStopExternalReference2githubcominterlineiotransitlandlibservermodelStopExternalReference(ctx context.Context, sel ast.SelectionSet, v *model.StopExternalReference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StopExternalReference(ctx, sel, v)
}

func (ec *executionContext) unmarshalOStopExternalReferenceSetInput2githubcominterlineiotransitlandlibservermodelStopExternalReferenceSetInput(ctx context.Context, v any) (*model.StopExternalReferenceSetInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStopExternalReferenceSetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOStopFilter2githubcominterlineiotransitlandlibservermodelStopFilter(ctx context.Context, v any) (*model.StopFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStopFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOStopLocationFilter2githubcominterlineiotransitlandlibservermodelStopLocationFilter(ctx context.Context, v any) (*model.StopLocationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStopLocationFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStopObservation2githubcominterlineiotransitlandlibservermodelStopObservation(ctx context.Context, sel ast.SelectionSet, v []*model.StopObservation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStopObservation2githubcominterlineiotransitlandlibservermodelStopObservation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOStopObservationFilter2githubcominterlineiotransitlandlibservermodelStopObservationFilter(ctx context.Context, v any) (*model.StopObservationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStopObservationFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStopPlace2githubcominterlineiotransitlandlibservermodelStopPlace(ctx context.Context, sel ast.SelectionSet, v *model.StopPlace) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StopPlace(ctx, sel, v)
}

func (ec *executionContext) unmarshalOStopSetInput2githubcominterlineiotransitlandlibservermodelStopSetInput(ctx context.Context, v any) (*model.StopSetInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStopSetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStopTime2githubcominterlineiotransitlandlibservermodelStopTime(ctx context.Context, sel ast.SelectionSet, v *model.StopTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StopTime(ctx, sel, v)
}

func (ec *executionContext) unmarshalOStopTimeFilter2githubcominterlineiotransitlandlibservermodelStopTimeFilter(ctx context.Context, v any) (*model.StopTimeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStopTimeFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2githubcominterlineiotransitlandlibttString(ctx context.Context, v any) (tt.String, error) {
	var res tt.String
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2githubcominterlineiotransitlandlibttString(ctx context.Context, sel ast.SelectionSet, v tt.String) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStrings2githubcominterlineiotransitlandlibttStrings(ctx context.Context, v any) (tt.Strings, error) {
	var res tt.Strings
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStrings2githubcominterlineiotransitlandlibttStrings(ctx context.Context, sel ast.SelectionSet, v tt.Strings) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOTags2githubcominterlineiotransitlandlibttTags(ctx context.Context, v any) (tt.Tags, error) {
	var res tt.Tags
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTags2githubcominterlineiotransitlandlibttTags(ctx context.Context, sel ast.SelectionSet, v tt.Tags) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOTags2githubcominterlineiotransitlandlibttTags(ctx context.Context, v any) (*tt.Tags, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Tags)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTags2githubcominterlineiotransitlandlibttTags(ctx context.Context, sel ast.SelectionSet, v *tt.Tags) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTime2githubcominterlineiotransitlandlibttTime(ctx context.Context, v any) (tt.Time, error) {
	var res tt.Time
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2githubcominterlineiotransitlandlibttTime(ctx context.Context, sel ast.SelectionSet, v tt.Time) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) unmarshalOTimezone2githubcominterlineiotransitlandlibttTimezone(ctx context.Context, v any) (tt.Timezone, error) {
	var res tt.Timezone
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTimezone2githubcominterlineiotransitlandlibttTimezone(ctx context.Context, sel ast.SelectionSet, v tt.Timezone) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalOTrip2githubcominterlineiotransitlandlibservermodelTrip(ctx context.Context, sel ast.SelectionSet, v []*model.Trip) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTrip2githubcominterlineiotransitlandlibservermodelTrip(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTripFilter2githubcominterlineiotransitlandlibservermodelTripFilter(ctx context.Context, v any) (*model.TripFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTripFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTripStopTimeFilter2githubcominterlineiotransitlandlibservermodelTripStopTimeFilter(ctx context.Context, v any) (*model.TripStopTimeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTripStopTimeFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx context.Context, v any) (*graphql.Upload, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUpload(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx context.Context, sel ast.SelectionSet, v *graphql.Upload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalUpload(*v)
	return res
}

func (ec *executionContext) unmarshalOUrl2githubcominterlineiotransitlandlibttUrl(ctx context.Context, v any) (tt.Url, error) {
	var res tt.Url
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUrl2githubcominterlineiotransitlandlibttUrl(ctx context.Context, sel ast.SelectionSet, v tt.Url) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOUrl2githubcominterlineiotransitlandlibttUrl(ctx context.Context, v any) (*tt.Url, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Url)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUrl2githubcominterlineiotransitlandlibttUrl(ctx context.Context, sel ast.SelectionSet, v *tt.Url) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOValidationRealtimeResult2githubcominterlineiotransitlandlibservermodelValidationRealtimeResult(ctx context.Context, sel ast.SelectionSet, v []*model.ValidationRealtimeResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValidationRealtimeResult2githubcominterlineiotransitlandlibservermodelValidationRealtimeResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOValidationReport2githubcominterlineiotransitlandlibservermodelValidationReport(ctx context.Context, sel ast.SelectionSet, v []*model.ValidationReport) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValidationReport2githubcominterlineiotransitlandlibservermodelValidationReport(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOValidationReport2githubcominterlineiotransitlandlibservermodelValidationReport(ctx context.Context, sel ast.SelectionSet, v *model.ValidationReport) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ValidationReport(ctx, sel, v)
}

func (ec *executionContext) marshalOValidationReportDetails2githubcominterlineiotransitlandlibservermodelValidationReportDetails(ctx context.Context, sel ast.SelectionSet, v *model.ValidationReportDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ValidationReportDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalOValidationReportFilter2githubcominterlineiotransitlandlibservermodelValidationReportFilter(ctx context.Context, v any) (*model.ValidationReportFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputValidationReportFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWaypoint2githubcominterlineiotransitlandlibservermodelWaypoint(ctx context.Context, sel ast.SelectionSet, v *model.Waypoint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Waypoint(ctx, sel, v)
}

func (ec *executionContext) marshalOWaypointDeparture2githubcominterlineiotransitlandlibservermodelWaypointDeparture(ctx context.Context, sel ast.SelectionSet, v []*model.WaypointDeparture) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWaypointDeparture2githubcominterlineiotransitlandlibservermodelWaypointDeparture(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWaypointInput2githubcominterlineiotransitlandlibservermodelWaypointInput(ctx context.Context, v any) (*model.WaypointInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWaypointInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWaypointStop2githubcominterlineiotransitlandlibservermodelWaypointStop(ctx context.Context, sel ast.SelectionSet, v *model.WaypointStop) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WaypointStop(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
